/* auto-generated on 2025-04-03 18:48:00 -0400. Do not edit! */
/* begin file src/simdutf.cpp */
#include "simdutf.h"

/* begin file src/encoding_types.cpp */
namespace simdutf
{
    bool match_system(endianness e)
    {
#if SIMDUTF_IS_BIG_ENDIAN
        return e == endianness::BIG;
#else
        return e == endianness::LITTLE;
#endif
    }

    std::string to_string(encoding_type bom)
    {
        switch (bom)
        {
            case UTF16_LE:
                return "UTF16 little-endian";
            case UTF16_BE:
                return "UTF16 big-endian";
            case UTF32_LE:
                return "UTF32 little-endian";
            case UTF32_BE:
                return "UTF32 big-endian";
            case UTF8:
                return "UTF8";
            case unspecified:
                return "unknown";
            default:
                return "error";
        }
    }

    namespace BOM
    {
        // Note that BOM for UTF8 is discouraged.
        encoding_type check_bom(const uint8_t* byte, size_t length)
        {
            if (length >= 2 && byte[0] == 0xff and byte[1] == 0xfe)
            {
                if (length >= 4 && byte[2] == 0x00 and byte[3] == 0x0)
                {
                    return encoding_type::UTF32_LE;
                }
                else
                {
                    return encoding_type::UTF16_LE;
                }
            }
            else if (length >= 2 && byte[0] == 0xfe and byte[1] == 0xff)
            {
                return encoding_type::UTF16_BE;
            }
            else if (length >= 4 && byte[0] == 0x00 and byte[1] == 0x00 and byte[2] == 0xfe and byte[3] == 0xff)
            {
                return encoding_type::UTF32_BE;
            }
            else if (length >= 4 && byte[0] == 0xef and byte[1] == 0xbb and byte[2] == 0xbf)
            {
                return encoding_type::UTF8;
            }
            return encoding_type::unspecified;
        }

        encoding_type check_bom(const char* byte, size_t length)
        {
            return check_bom(reinterpret_cast<const uint8_t*>(byte), length);
        }

        size_t bom_byte_size(encoding_type bom)
        {
            switch (bom)
            {
                case UTF16_LE:
                    return 2;
                case UTF16_BE:
                    return 2;
                case UTF32_LE:
                    return 4;
                case UTF32_BE:
                    return 4;
                case UTF8:
                    return 3;
                case unspecified:
                    return 0;
                default:
                    return 0;
            }
        }

    } // namespace BOM
} // namespace simdutf
/* end file src/encoding_types.cpp */
/* begin file src/error.cpp */
namespace simdutf
{
    // deliberately empty
}
/* end file src/error.cpp */
// The large tables should be included once and they
// should not depend on a kernel.
/* begin file src/tables/utf8_to_utf16_tables.h */
#ifndef SIMDUTF_UTF8_TO_UTF16_TABLES_H
    #define SIMDUTF_UTF8_TO_UTF16_TABLES_H
    #include <cstdint>

namespace simdutf
{
    namespace
    {
        namespace tables
        {
            namespace utf8_to_utf16
            {
                /**
                 * utf8bigindex uses about 8 kB
                 * shufutf8 uses about 3344 B
                 *
                 * So we use a bit over 11 kB. It would be
                 * easy to save about 4 kB by only
                 * storing the index in utf8bigindex, and
                 * deriving the consumed bytes otherwise.
                 * However, this may come at a significant (10% to 20%)
                 * performance penalty.
                 */

                const uint8_t shufutf8[209][16] = {
                    { 0, 255, 1, 255, 2, 255, 3, 255, 4, 255, 5, 255, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 2, 255, 3, 255, 4, 255, 6, 5, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 2, 255, 3, 255, 5, 4, 6, 255, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 2, 255, 3, 255, 5, 4, 7, 6, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 2, 255, 4, 3, 5, 255, 6, 255, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 2, 255, 4, 3, 5, 255, 7, 6, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 2, 255, 4, 3, 6, 5, 7, 255, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 2, 255, 4, 3, 6, 5, 8, 7, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 3, 2, 4, 255, 5, 255, 6, 255, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 3, 2, 4, 255, 5, 255, 7, 6, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 3, 2, 4, 255, 6, 5, 7, 255, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 3, 2, 4, 255, 6, 5, 8, 7, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 3, 2, 5, 4, 6, 255, 7, 255, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 3, 2, 5, 4, 6, 255, 8, 7, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 3, 2, 5, 4, 7, 6, 8, 255, 0, 0, 0, 0 },
                    { 0, 255, 1, 255, 3, 2, 5, 4, 7, 6, 9, 8, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 3, 255, 4, 255, 5, 255, 6, 255, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 3, 255, 4, 255, 5, 255, 7, 6, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 3, 255, 4, 255, 6, 5, 7, 255, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 3, 255, 4, 255, 6, 5, 8, 7, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 3, 255, 5, 4, 6, 255, 7, 255, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 3, 255, 5, 4, 6, 255, 8, 7, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 3, 255, 5, 4, 7, 6, 8, 255, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 3, 255, 5, 4, 7, 6, 9, 8, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 4, 3, 5, 255, 6, 255, 7, 255, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 4, 3, 5, 255, 6, 255, 8, 7, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 4, 3, 5, 255, 7, 6, 8, 255, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 4, 3, 5, 255, 7, 6, 9, 8, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 4, 3, 6, 5, 7, 255, 8, 255, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 4, 3, 6, 5, 7, 255, 9, 8, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 4, 3, 6, 5, 8, 7, 9, 255, 0, 0, 0, 0 },
                    { 0, 255, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 3, 255, 4, 255, 5, 255, 6, 255, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 3, 255, 4, 255, 5, 255, 7, 6, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 3, 255, 4, 255, 6, 5, 7, 255, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 3, 255, 4, 255, 6, 5, 8, 7, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 3, 255, 5, 4, 6, 255, 7, 255, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 3, 255, 5, 4, 6, 255, 8, 7, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 3, 255, 5, 4, 7, 6, 8, 255, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 3, 255, 5, 4, 7, 6, 9, 8, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 4, 3, 5, 255, 6, 255, 7, 255, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 4, 3, 5, 255, 6, 255, 8, 7, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 4, 3, 5, 255, 7, 6, 8, 255, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 4, 3, 5, 255, 7, 6, 9, 8, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 4, 3, 6, 5, 7, 255, 8, 255, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 4, 3, 6, 5, 7, 255, 9, 8, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 4, 3, 6, 5, 8, 7, 9, 255, 0, 0, 0, 0 },
                    { 1, 0, 2, 255, 4, 3, 6, 5, 8, 7, 10, 9, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 4, 255, 5, 255, 6, 255, 7, 255, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 4, 255, 5, 255, 6, 255, 8, 7, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 4, 255, 5, 255, 7, 6, 8, 255, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 4, 255, 5, 255, 7, 6, 9, 8, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 4, 255, 6, 5, 7, 255, 8, 255, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 4, 255, 6, 5, 7, 255, 9, 8, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 4, 255, 6, 5, 8, 7, 9, 255, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 4, 255, 6, 5, 8, 7, 10, 9, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 5, 4, 6, 255, 7, 255, 8, 255, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 5, 4, 6, 255, 7, 255, 9, 8, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 5, 4, 6, 255, 8, 7, 9, 255, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 5, 4, 6, 255, 8, 7, 10, 9, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 5, 4, 7, 6, 8, 255, 9, 255, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 5, 4, 7, 6, 8, 255, 10, 9, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 255, 0, 0, 0, 0 },
                    { 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 2, 255, 255, 255, 3, 255, 255, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 2, 255, 255, 255, 4, 3, 255, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 2, 255, 255, 255, 5, 4, 3, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 3, 2, 255, 255, 4, 255, 255, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 3, 2, 255, 255, 5, 4, 255, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 3, 2, 255, 255, 6, 5, 4, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 4, 3, 2, 255, 5, 255, 255, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 4, 3, 2, 255, 6, 5, 255, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 4, 3, 2, 255, 7, 6, 5, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 3, 255, 255, 255, 4, 255, 255, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 3, 255, 255, 255, 5, 4, 255, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 3, 255, 255, 255, 6, 5, 4, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 4, 3, 255, 255, 5, 255, 255, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 4, 3, 255, 255, 6, 5, 255, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 4, 3, 255, 255, 7, 6, 5, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 5, 4, 3, 255, 6, 255, 255, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 5, 4, 3, 255, 7, 6, 255, 255 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 5, 4, 3, 255, 8, 7, 6, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 4, 255, 255, 255, 5, 255, 255, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 4, 255, 255, 255, 6, 5, 255, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 4, 255, 255, 255, 7, 6, 5, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 5, 4, 255, 255, 6, 255, 255, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 5, 4, 255, 255, 7, 6, 255, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 5, 4, 255, 255, 8, 7, 6, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 6, 5, 4, 255, 7, 255, 255, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 6, 5, 4, 255, 8, 7, 255, 255 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 6, 5, 4, 255, 9, 8, 7, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 3, 255, 255, 255, 4, 255, 255, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 3, 255, 255, 255, 5, 4, 255, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 3, 255, 255, 255, 6, 5, 4, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 4, 3, 255, 255, 5, 255, 255, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 4, 3, 255, 255, 6, 5, 255, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 4, 3, 255, 255, 7, 6, 5, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 5, 4, 3, 255, 6, 255, 255, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 5, 4, 3, 255, 7, 6, 255, 255 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 5, 4, 3, 255, 8, 7, 6, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 4, 255, 255, 255, 5, 255, 255, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 4, 255, 255, 255, 6, 5, 255, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 4, 255, 255, 255, 7, 6, 5, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 5, 4, 255, 255, 6, 255, 255, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 5, 4, 255, 255, 7, 6, 255, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 5, 4, 255, 255, 8, 7, 6, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 6, 5, 4, 255, 7, 255, 255, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 6, 5, 4, 255, 8, 7, 255, 255 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 6, 5, 4, 255, 9, 8, 7, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 5, 255, 255, 255, 6, 255, 255, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 5, 255, 255, 255, 7, 6, 255, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 5, 255, 255, 255, 8, 7, 6, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 6, 5, 255, 255, 7, 255, 255, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 6, 5, 255, 255, 8, 7, 255, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 6, 5, 255, 255, 9, 8, 7, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 7, 6, 5, 255, 8, 255, 255, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 7, 6, 5, 255, 9, 8, 255, 255 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 7, 6, 5, 255, 10, 9, 8, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 4, 255, 255, 255, 5, 255, 255, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 4, 255, 255, 255, 6, 5, 255, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 4, 255, 255, 255, 7, 6, 5, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 5, 4, 255, 255, 6, 255, 255, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 5, 4, 255, 255, 7, 6, 255, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 5, 4, 255, 255, 8, 7, 6, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 6, 5, 4, 255, 7, 255, 255, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 6, 5, 4, 255, 8, 7, 255, 255 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 6, 5, 4, 255, 9, 8, 7, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 5, 255, 255, 255, 6, 255, 255, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 5, 255, 255, 255, 7, 6, 255, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 5, 255, 255, 255, 8, 7, 6, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 6, 5, 255, 255, 7, 255, 255, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 6, 5, 255, 255, 8, 7, 255, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 6, 5, 255, 255, 9, 8, 7, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 7, 6, 5, 255, 8, 255, 255, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 7, 6, 5, 255, 9, 8, 255, 255 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 7, 6, 5, 255, 10, 9, 8, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 6, 255, 255, 255, 7, 255, 255, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 6, 255, 255, 255, 8, 7, 255, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 6, 255, 255, 255, 9, 8, 7, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 7, 6, 255, 255, 8, 255, 255, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 7, 6, 255, 255, 9, 8, 255, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 7, 6, 255, 255, 10, 9, 8, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 8, 7, 6, 255, 9, 255, 255, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 8, 7, 6, 255, 10, 9, 255, 255 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 8, 7, 6, 255, 11, 10, 9, 255 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 2, 255, 255, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 3, 2, 255, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 4, 3, 2, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 1, 255, 255, 255, 5, 4, 3, 2, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 3, 255, 255, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 4, 3, 255, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 5, 4, 3, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 2, 1, 255, 255, 6, 5, 4, 3, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 4, 255, 255, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 5, 4, 255, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 6, 5, 4, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 3, 2, 1, 255, 7, 6, 5, 4, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 4, 3, 2, 1, 5, 255, 255, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 4, 3, 2, 1, 6, 5, 255, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 4, 3, 2, 1, 7, 6, 5, 255, 0, 0, 0, 0 },
                    { 0, 255, 255, 255, 4, 3, 2, 1, 8, 7, 6, 5, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 3, 255, 255, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 4, 3, 255, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 5, 4, 3, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 2, 255, 255, 255, 6, 5, 4, 3, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 4, 255, 255, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 5, 4, 255, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 6, 5, 4, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 3, 2, 255, 255, 7, 6, 5, 4, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 5, 255, 255, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 6, 5, 255, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 7, 6, 5, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 4, 3, 2, 255, 8, 7, 6, 5, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 5, 4, 3, 2, 6, 255, 255, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 5, 4, 3, 2, 7, 6, 255, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 5, 4, 3, 2, 8, 7, 6, 255, 0, 0, 0, 0 },
                    { 1, 0, 255, 255, 5, 4, 3, 2, 9, 8, 7, 6, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 4, 255, 255, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 5, 4, 255, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 6, 5, 4, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 3, 255, 255, 255, 7, 6, 5, 4, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 5, 255, 255, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 6, 5, 255, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 7, 6, 5, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 4, 3, 255, 255, 8, 7, 6, 5, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 6, 255, 255, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 7, 6, 255, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 8, 7, 6, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 5, 4, 3, 255, 9, 8, 7, 6, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 6, 5, 4, 3, 7, 255, 255, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 6, 5, 4, 3, 8, 7, 255, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 6, 5, 4, 3, 9, 8, 7, 255, 0, 0, 0, 0 },
                    { 2, 1, 0, 255, 6, 5, 4, 3, 10, 9, 8, 7, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 4, 255, 255, 255, 5, 255, 255, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 4, 255, 255, 255, 6, 5, 255, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 4, 255, 255, 255, 7, 6, 5, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 4, 255, 255, 255, 8, 7, 6, 5, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 5, 4, 255, 255, 6, 255, 255, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 5, 4, 255, 255, 7, 6, 255, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 5, 4, 255, 255, 8, 7, 6, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 5, 4, 255, 255, 9, 8, 7, 6, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 6, 5, 4, 255, 7, 255, 255, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 6, 5, 4, 255, 8, 7, 255, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 6, 5, 4, 255, 9, 8, 7, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 6, 5, 4, 255, 10, 9, 8, 7, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 7, 6, 5, 4, 8, 255, 255, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 7, 6, 5, 4, 9, 8, 255, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 7, 6, 5, 4, 10, 9, 8, 255, 0, 0, 0, 0 },
                    { 3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 0, 0, 0, 0 }
                };
                /* number of two bytes : 64 */
                /* number of two + three bytes : 145 */
                /* number of two + three + four bytes : 209 */
                const uint8_t utf8bigindex[4096][2] = {
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 },
                    { 161, 4 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 147, 5 }, { 209, 12 },
                    { 150, 5 }, { 162, 5 }, { 65, 5 }, { 209, 12 }, { 153, 5 }, { 165, 5 }, { 67, 5 },
                    { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 148, 6 }, { 209, 12 }, { 151, 6 }, { 163, 6 }, { 66, 6 }, { 209, 12 }, { 154, 6 },
                    { 166, 6 }, { 68, 6 }, { 178, 6 }, { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 },
                    { 157, 6 }, { 169, 6 }, { 70, 6 }, { 181, 6 }, { 76, 6 }, { 94, 6 }, { 65, 5 },
                    { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 152, 7 },
                    { 164, 7 }, { 145, 3 }, { 209, 12 }, { 155, 7 }, { 167, 7 }, { 69, 7 }, { 179, 7 },
                    { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 170, 7 }, { 71, 7 },
                    { 182, 7 }, { 77, 7 }, { 95, 7 }, { 65, 5 }, { 194, 7 }, { 83, 7 }, { 101, 7 },
                    { 67, 5 }, { 119, 7 }, { 73, 5 }, { 91, 5 }, { 1, 7 }, { 209, 12 }, { 209, 12 },
                    { 173, 7 }, { 148, 6 }, { 185, 7 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 },
                    { 85, 7 }, { 103, 7 }, { 68, 6 }, { 121, 7 }, { 74, 6 }, { 92, 6 }, { 2, 7 },
                    { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 76, 6 }, { 94, 6 },
                    { 4, 7 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 8, 7 }, { 118, 6 }, { 16, 7 },
                    { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 }, { 156, 8 }, { 168, 8 }, { 146, 4 },
                    { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 }, { 171, 8 },
                    { 72, 8 }, { 183, 8 }, { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 },
                    { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 },
                    { 209, 12 }, { 174, 8 }, { 148, 6 }, { 186, 8 }, { 80, 8 }, { 98, 8 }, { 66, 6 },
                    { 198, 8 }, { 86, 8 }, { 104, 8 }, { 68, 6 }, { 122, 8 }, { 74, 6 }, { 92, 6 },
                    { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 }, { 76, 6 },
                    { 94, 6 }, { 5, 8 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 9, 8 }, { 118, 6 },
                    { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 },
                    { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 },
                    { 112, 8 }, { 71, 7 }, { 130, 8 }, { 77, 7 }, { 95, 7 }, { 6, 8 }, { 194, 7 },
                    { 83, 7 }, { 101, 7 }, { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 },
                    { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 },
                    { 66, 6 }, { 197, 7 }, { 85, 7 }, { 103, 7 }, { 12, 8 }, { 121, 7 }, { 20, 8 },
                    { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 },
                    { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 },
                    { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 },
                    { 160, 9 }, { 172, 9 }, { 147, 5 }, { 184, 9 }, { 150, 5 }, { 162, 5 }, { 65, 5 },
                    { 196, 9 }, { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 },
                    { 64, 4 }, { 209, 12 }, { 209, 12 }, { 175, 9 }, { 148, 6 }, { 187, 9 }, { 81, 9 },
                    { 99, 9 }, { 66, 6 }, { 199, 9 }, { 87, 9 }, { 105, 9 }, { 68, 6 }, { 123, 9 },
                    { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 }, { 111, 9 }, { 70, 6 },
                    { 129, 9 }, { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 },
                    { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 190, 9 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 202, 9 },
                    { 89, 9 }, { 107, 9 }, { 69, 7 }, { 125, 9 }, { 75, 7 }, { 93, 7 }, { 64, 4 },
                    { 209, 12 }, { 158, 7 }, { 113, 9 }, { 71, 7 }, { 131, 9 }, { 77, 7 }, { 95, 7 },
                    { 7, 9 }, { 194, 7 }, { 83, 7 }, { 101, 7 }, { 11, 9 }, { 119, 7 }, { 19, 9 },
                    { 35, 9 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 137, 9 },
                    { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 103, 7 }, { 13, 9 },
                    { 121, 7 }, { 21, 9 }, { 37, 9 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 },
                    { 70, 6 }, { 127, 7 }, { 25, 9 }, { 41, 9 }, { 4, 7 }, { 193, 6 }, { 82, 6 },
                    { 49, 9 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 },
                    { 205, 9 }, { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 },
                    { 64, 4 }, { 209, 12 }, { 159, 8 }, { 115, 9 }, { 72, 8 }, { 133, 9 }, { 78, 8 },
                    { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 },
                    { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 },
                    { 139, 9 }, { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 }, { 104, 8 },
                    { 14, 9 }, { 122, 8 }, { 22, 9 }, { 38, 9 }, { 3, 8 }, { 209, 12 }, { 157, 6 },
                    { 110, 8 }, { 70, 6 }, { 128, 8 }, { 26, 9 }, { 42, 9 }, { 5, 8 }, { 193, 6 },
                    { 82, 6 }, { 50, 9 }, { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 },
                    { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 },
                    { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 },
                    { 28, 9 }, { 44, 9 }, { 6, 8 }, { 194, 7 }, { 83, 7 }, { 52, 9 }, { 10, 8 },
                    { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 },
                    { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 },
                    { 56, 9 }, { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 },
                    { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 },
                    { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 },
                    { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 147, 5 },
                    { 209, 12 }, { 150, 5 }, { 162, 5 }, { 65, 5 }, { 209, 12 }, { 153, 5 }, { 165, 5 },
                    { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 },
                    { 176, 10 }, { 148, 6 }, { 188, 10 }, { 151, 6 }, { 163, 6 }, { 66, 6 }, { 200, 10 },
                    { 154, 6 }, { 166, 6 }, { 68, 6 }, { 178, 6 }, { 74, 6 }, { 92, 6 }, { 64, 4 },
                    { 209, 12 }, { 157, 6 }, { 169, 6 }, { 70, 6 }, { 181, 6 }, { 76, 6 }, { 94, 6 },
                    { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 },
                    { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 191, 10 },
                    { 152, 7 }, { 164, 7 }, { 145, 3 }, { 203, 10 }, { 90, 10 }, { 108, 10 }, { 69, 7 },
                    { 126, 10 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 114, 10 },
                    { 71, 7 }, { 132, 10 }, { 77, 7 }, { 95, 7 }, { 65, 5 }, { 194, 7 }, { 83, 7 },
                    { 101, 7 }, { 67, 5 }, { 119, 7 }, { 73, 5 }, { 91, 5 }, { 1, 7 }, { 209, 12 },
                    { 209, 12 }, { 173, 7 }, { 148, 6 }, { 138, 10 }, { 79, 7 }, { 97, 7 }, { 66, 6 },
                    { 197, 7 }, { 85, 7 }, { 103, 7 }, { 68, 6 }, { 121, 7 }, { 74, 6 }, { 92, 6 },
                    { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 76, 6 },
                    { 94, 6 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 8, 7 }, { 118, 6 },
                    { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 206, 10 }, { 156, 8 }, { 168, 8 },
                    { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 },
                    { 116, 10 }, { 72, 8 }, { 134, 10 }, { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 },
                    { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 },
                    { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 }, { 140, 10 }, { 80, 8 }, { 98, 8 },
                    { 66, 6 }, { 198, 8 }, { 86, 8 }, { 104, 8 }, { 15, 10 }, { 122, 8 }, { 23, 10 },
                    { 39, 10 }, { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 },
                    { 27, 10 }, { 43, 10 }, { 5, 8 }, { 193, 6 }, { 82, 6 }, { 51, 10 }, { 9, 8 },
                    { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 },
                    { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 },
                    { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 }, { 29, 10 }, { 45, 10 }, { 6, 8 },
                    { 194, 7 }, { 83, 7 }, { 53, 10 }, { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 },
                    { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 },
                    { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 57, 10 }, { 12, 8 }, { 121, 7 },
                    { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 },
                    { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 },
                    { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 },
                    { 209, 12 }, { 160, 9 }, { 172, 9 }, { 147, 5 }, { 184, 9 }, { 150, 5 }, { 162, 5 },
                    { 65, 5 }, { 196, 9 }, { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 },
                    { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 175, 9 }, { 148, 6 }, { 142, 10 },
                    { 81, 9 }, { 99, 9 }, { 66, 6 }, { 199, 9 }, { 87, 9 }, { 105, 9 }, { 68, 6 },
                    { 123, 9 }, { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 }, { 111, 9 },
                    { 70, 6 }, { 129, 9 }, { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 },
                    { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 190, 9 }, { 152, 7 }, { 164, 7 }, { 145, 3 },
                    { 202, 9 }, { 89, 9 }, { 107, 9 }, { 69, 7 }, { 125, 9 }, { 75, 7 }, { 93, 7 },
                    { 64, 4 }, { 209, 12 }, { 158, 7 }, { 113, 9 }, { 71, 7 }, { 131, 9 }, { 30, 10 },
                    { 46, 10 }, { 7, 9 }, { 194, 7 }, { 83, 7 }, { 54, 10 }, { 11, 9 }, { 119, 7 },
                    { 19, 9 }, { 35, 9 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 },
                    { 137, 9 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 58, 10 },
                    { 13, 9 }, { 121, 7 }, { 21, 9 }, { 37, 9 }, { 2, 7 }, { 209, 12 }, { 157, 6 },
                    { 109, 7 }, { 70, 6 }, { 127, 7 }, { 25, 9 }, { 41, 9 }, { 4, 7 }, { 193, 6 },
                    { 82, 6 }, { 49, 9 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 145, 3 }, { 205, 9 }, { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 },
                    { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 }, { 115, 9 }, { 72, 8 }, { 133, 9 },
                    { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 },
                    { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 },
                    { 148, 6 }, { 139, 9 }, { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 },
                    { 60, 10 }, { 14, 9 }, { 122, 8 }, { 22, 9 }, { 38, 9 }, { 3, 8 }, { 209, 12 },
                    { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 }, { 26, 9 }, { 42, 9 }, { 5, 8 },
                    { 193, 6 }, { 82, 6 }, { 50, 9 }, { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 },
                    { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 },
                    { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 },
                    { 130, 8 }, { 28, 9 }, { 44, 9 }, { 6, 8 }, { 194, 7 }, { 83, 7 }, { 52, 9 },
                    { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 },
                    { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 },
                    { 85, 7 }, { 56, 9 }, { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 },
                    { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 },
                    { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 },
                    { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 },
                    { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 147, 5 }, { 209, 12 }, { 150, 5 }, { 162, 5 }, { 65, 5 }, { 209, 12 }, { 153, 5 },
                    { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 148, 6 }, { 209, 12 }, { 151, 6 }, { 163, 6 }, { 66, 6 },
                    { 209, 12 }, { 154, 6 }, { 166, 6 }, { 68, 6 }, { 178, 6 }, { 74, 6 }, { 92, 6 },
                    { 64, 4 }, { 209, 12 }, { 157, 6 }, { 169, 6 }, { 70, 6 }, { 181, 6 }, { 76, 6 },
                    { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 },
                    { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 192, 11 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 204, 11 }, { 155, 7 }, { 167, 7 },
                    { 69, 7 }, { 179, 7 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 },
                    { 170, 7 }, { 71, 7 }, { 182, 7 }, { 77, 7 }, { 95, 7 }, { 65, 5 }, { 194, 7 },
                    { 83, 7 }, { 101, 7 }, { 67, 5 }, { 119, 7 }, { 73, 5 }, { 91, 5 }, { 1, 7 },
                    { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 185, 7 }, { 79, 7 }, { 97, 7 },
                    { 66, 6 }, { 197, 7 }, { 85, 7 }, { 103, 7 }, { 68, 6 }, { 121, 7 }, { 74, 6 },
                    { 92, 6 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 },
                    { 76, 6 }, { 94, 6 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 8, 7 },
                    { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 207, 11 }, { 156, 8 },
                    { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 },
                    { 159, 8 }, { 117, 11 }, { 72, 8 }, { 135, 11 }, { 78, 8 }, { 96, 8 }, { 65, 5 },
                    { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 },
                    { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 }, { 141, 11 }, { 80, 8 },
                    { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 }, { 104, 8 }, { 68, 6 }, { 122, 8 },
                    { 74, 6 }, { 92, 6 }, { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 },
                    { 128, 8 }, { 76, 6 }, { 94, 6 }, { 5, 8 }, { 193, 6 }, { 82, 6 }, { 100, 6 },
                    { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 },
                    { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 },
                    { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 }, { 77, 7 }, { 95, 7 },
                    { 6, 8 }, { 194, 7 }, { 83, 7 }, { 101, 7 }, { 10, 8 }, { 119, 7 }, { 18, 8 },
                    { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 },
                    { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 103, 7 }, { 12, 8 },
                    { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 },
                    { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 },
                    { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 },
                    { 64, 4 }, { 209, 12 }, { 160, 9 }, { 172, 9 }, { 147, 5 }, { 184, 9 }, { 150, 5 },
                    { 162, 5 }, { 65, 5 }, { 196, 9 }, { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 },
                    { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 175, 9 }, { 148, 6 },
                    { 143, 11 }, { 81, 9 }, { 99, 9 }, { 66, 6 }, { 199, 9 }, { 87, 9 }, { 105, 9 },
                    { 68, 6 }, { 123, 9 }, { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 },
                    { 111, 9 }, { 70, 6 }, { 129, 9 }, { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 },
                    { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 190, 9 }, { 152, 7 }, { 164, 7 },
                    { 145, 3 }, { 202, 9 }, { 89, 9 }, { 107, 9 }, { 69, 7 }, { 125, 9 }, { 75, 7 },
                    { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 113, 9 }, { 71, 7 }, { 131, 9 },
                    { 31, 11 }, { 47, 11 }, { 7, 9 }, { 194, 7 }, { 83, 7 }, { 55, 11 }, { 11, 9 },
                    { 119, 7 }, { 19, 9 }, { 35, 9 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 },
                    { 148, 6 }, { 137, 9 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 },
                    { 59, 11 }, { 13, 9 }, { 121, 7 }, { 21, 9 }, { 37, 9 }, { 2, 7 }, { 209, 12 },
                    { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 25, 9 }, { 41, 9 }, { 4, 7 },
                    { 193, 6 }, { 82, 6 }, { 49, 9 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 145, 3 }, { 205, 9 }, { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 },
                    { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 }, { 115, 9 }, { 72, 8 },
                    { 133, 9 }, { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 },
                    { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 },
                    { 174, 8 }, { 148, 6 }, { 139, 9 }, { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 },
                    { 86, 8 }, { 61, 11 }, { 14, 9 }, { 122, 8 }, { 22, 9 }, { 38, 9 }, { 3, 8 },
                    { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 }, { 26, 9 }, { 42, 9 },
                    { 5, 8 }, { 193, 6 }, { 82, 6 }, { 50, 9 }, { 9, 8 }, { 118, 6 }, { 17, 8 },
                    { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 },
                    { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 },
                    { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 },
                    { 71, 7 }, { 130, 8 }, { 28, 9 }, { 44, 9 }, { 6, 8 }, { 194, 7 }, { 83, 7 },
                    { 52, 9 }, { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 },
                    { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 },
                    { 197, 7 }, { 85, 7 }, { 56, 9 }, { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 },
                    { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 },
                    { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 },
                    { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 147, 5 }, { 209, 12 }, { 150, 5 }, { 162, 5 }, { 65, 5 }, { 209, 12 },
                    { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 },
                    { 209, 12 }, { 209, 12 }, { 176, 10 }, { 148, 6 }, { 188, 10 }, { 151, 6 }, { 163, 6 },
                    { 66, 6 }, { 200, 10 }, { 154, 6 }, { 166, 6 }, { 68, 6 }, { 178, 6 }, { 74, 6 },
                    { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 }, { 169, 6 }, { 70, 6 }, { 181, 6 },
                    { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 },
                    { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 191, 10 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 203, 10 }, { 90, 10 },
                    { 108, 10 }, { 69, 7 }, { 126, 10 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 },
                    { 158, 7 }, { 114, 10 }, { 71, 7 }, { 132, 10 }, { 77, 7 }, { 95, 7 }, { 65, 5 },
                    { 194, 7 }, { 83, 7 }, { 101, 7 }, { 67, 5 }, { 119, 7 }, { 73, 5 }, { 91, 5 },
                    { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 138, 10 }, { 79, 7 },
                    { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 103, 7 }, { 68, 6 }, { 121, 7 },
                    { 74, 6 }, { 92, 6 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 },
                    { 127, 7 }, { 76, 6 }, { 94, 6 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 100, 6 },
                    { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 206, 10 },
                    { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 },
                    { 209, 12 }, { 159, 8 }, { 116, 10 }, { 72, 8 }, { 134, 10 }, { 78, 8 }, { 96, 8 },
                    { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 },
                    { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 }, { 140, 10 },
                    { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 }, { 62, 11 }, { 15, 10 },
                    { 122, 8 }, { 23, 10 }, { 39, 10 }, { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 },
                    { 70, 6 }, { 128, 8 }, { 27, 10 }, { 43, 10 }, { 5, 8 }, { 193, 6 }, { 82, 6 },
                    { 51, 10 }, { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 },
                    { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 },
                    { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 }, { 29, 10 },
                    { 45, 10 }, { 6, 8 }, { 194, 7 }, { 83, 7 }, { 53, 10 }, { 10, 8 }, { 119, 7 },
                    { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 },
                    { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 57, 10 },
                    { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 },
                    { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 },
                    { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 },
                    { 161, 4 }, { 64, 4 }, { 209, 12 }, { 160, 9 }, { 172, 9 }, { 147, 5 }, { 184, 9 },
                    { 150, 5 }, { 162, 5 }, { 65, 5 }, { 196, 9 }, { 153, 5 }, { 165, 5 }, { 67, 5 },
                    { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 175, 9 },
                    { 148, 6 }, { 142, 10 }, { 81, 9 }, { 99, 9 }, { 66, 6 }, { 199, 9 }, { 87, 9 },
                    { 105, 9 }, { 68, 6 }, { 123, 9 }, { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 },
                    { 157, 6 }, { 111, 9 }, { 70, 6 }, { 129, 9 }, { 76, 6 }, { 94, 6 }, { 65, 5 },
                    { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 190, 9 }, { 152, 7 },
                    { 164, 7 }, { 145, 3 }, { 202, 9 }, { 89, 9 }, { 107, 9 }, { 69, 7 }, { 125, 9 },
                    { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 113, 9 }, { 71, 7 },
                    { 131, 9 }, { 30, 10 }, { 46, 10 }, { 7, 9 }, { 194, 7 }, { 83, 7 }, { 54, 10 },
                    { 11, 9 }, { 119, 7 }, { 19, 9 }, { 35, 9 }, { 1, 7 }, { 209, 12 }, { 209, 12 },
                    { 173, 7 }, { 148, 6 }, { 137, 9 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 },
                    { 85, 7 }, { 58, 10 }, { 13, 9 }, { 121, 7 }, { 21, 9 }, { 37, 9 }, { 2, 7 },
                    { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 25, 9 }, { 41, 9 },
                    { 4, 7 }, { 193, 6 }, { 82, 6 }, { 49, 9 }, { 8, 7 }, { 118, 6 }, { 16, 7 },
                    { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 145, 3 }, { 205, 9 }, { 156, 8 }, { 168, 8 }, { 146, 4 },
                    { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 }, { 115, 9 },
                    { 72, 8 }, { 133, 9 }, { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 },
                    { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 },
                    { 209, 12 }, { 174, 8 }, { 148, 6 }, { 139, 9 }, { 80, 8 }, { 98, 8 }, { 66, 6 },
                    { 198, 8 }, { 86, 8 }, { 60, 10 }, { 14, 9 }, { 122, 8 }, { 22, 9 }, { 38, 9 },
                    { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 }, { 26, 9 },
                    { 42, 9 }, { 5, 8 }, { 193, 6 }, { 82, 6 }, { 50, 9 }, { 9, 8 }, { 118, 6 },
                    { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 },
                    { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 },
                    { 112, 8 }, { 71, 7 }, { 130, 8 }, { 28, 9 }, { 44, 9 }, { 6, 8 }, { 194, 7 },
                    { 83, 7 }, { 52, 9 }, { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 },
                    { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 },
                    { 66, 6 }, { 197, 7 }, { 85, 7 }, { 56, 9 }, { 12, 8 }, { 121, 7 }, { 20, 8 },
                    { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 },
                    { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 },
                    { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 147, 5 }, { 209, 12 }, { 150, 5 }, { 162, 5 }, { 65, 5 },
                    { 209, 12 }, { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 },
                    { 64, 4 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 148, 6 }, { 209, 12 }, { 151, 6 },
                    { 163, 6 }, { 66, 6 }, { 209, 12 }, { 154, 6 }, { 166, 6 }, { 68, 6 }, { 178, 6 },
                    { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 }, { 169, 6 }, { 70, 6 },
                    { 181, 6 }, { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 },
                    { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 209, 12 },
                    { 155, 7 }, { 167, 7 }, { 69, 7 }, { 179, 7 }, { 75, 7 }, { 93, 7 }, { 64, 4 },
                    { 209, 12 }, { 158, 7 }, { 170, 7 }, { 71, 7 }, { 182, 7 }, { 77, 7 }, { 95, 7 },
                    { 65, 5 }, { 194, 7 }, { 83, 7 }, { 101, 7 }, { 67, 5 }, { 119, 7 }, { 73, 5 },
                    { 91, 5 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 185, 7 },
                    { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 103, 7 }, { 68, 6 },
                    { 121, 7 }, { 74, 6 }, { 92, 6 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 },
                    { 70, 6 }, { 127, 7 }, { 76, 6 }, { 94, 6 }, { 4, 7 }, { 193, 6 }, { 82, 6 },
                    { 100, 6 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 },
                    { 208, 12 }, { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 },
                    { 64, 4 }, { 209, 12 }, { 159, 8 }, { 171, 8 }, { 72, 8 }, { 183, 8 }, { 78, 8 },
                    { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 },
                    { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 },
                    { 186, 8 }, { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 }, { 104, 8 },
                    { 68, 6 }, { 122, 8 }, { 74, 6 }, { 92, 6 }, { 3, 8 }, { 209, 12 }, { 157, 6 },
                    { 110, 8 }, { 70, 6 }, { 128, 8 }, { 76, 6 }, { 94, 6 }, { 5, 8 }, { 193, 6 },
                    { 82, 6 }, { 100, 6 }, { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 },
                    { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 },
                    { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 },
                    { 77, 7 }, { 95, 7 }, { 6, 8 }, { 194, 7 }, { 83, 7 }, { 101, 7 }, { 10, 8 },
                    { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 },
                    { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 },
                    { 103, 7 }, { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 },
                    { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 },
                    { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 },
                    { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 160, 9 }, { 172, 9 }, { 147, 5 },
                    { 184, 9 }, { 150, 5 }, { 162, 5 }, { 65, 5 }, { 196, 9 }, { 153, 5 }, { 165, 5 },
                    { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 },
                    { 175, 9 }, { 148, 6 }, { 144, 12 }, { 81, 9 }, { 99, 9 }, { 66, 6 }, { 199, 9 },
                    { 87, 9 }, { 105, 9 }, { 68, 6 }, { 123, 9 }, { 74, 6 }, { 92, 6 }, { 64, 4 },
                    { 209, 12 }, { 157, 6 }, { 111, 9 }, { 70, 6 }, { 129, 9 }, { 76, 6 }, { 94, 6 },
                    { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 },
                    { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 190, 9 },
                    { 152, 7 }, { 164, 7 }, { 145, 3 }, { 202, 9 }, { 89, 9 }, { 107, 9 }, { 69, 7 },
                    { 125, 9 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 113, 9 },
                    { 71, 7 }, { 131, 9 }, { 77, 7 }, { 95, 7 }, { 7, 9 }, { 194, 7 }, { 83, 7 },
                    { 101, 7 }, { 11, 9 }, { 119, 7 }, { 19, 9 }, { 35, 9 }, { 1, 7 }, { 209, 12 },
                    { 209, 12 }, { 173, 7 }, { 148, 6 }, { 137, 9 }, { 79, 7 }, { 97, 7 }, { 66, 6 },
                    { 197, 7 }, { 85, 7 }, { 103, 7 }, { 13, 9 }, { 121, 7 }, { 21, 9 }, { 37, 9 },
                    { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 25, 9 },
                    { 41, 9 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 49, 9 }, { 8, 7 }, { 118, 6 },
                    { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 205, 9 }, { 156, 8 }, { 168, 8 },
                    { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 },
                    { 115, 9 }, { 72, 8 }, { 133, 9 }, { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 },
                    { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 },
                    { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 }, { 139, 9 }, { 80, 8 }, { 98, 8 },
                    { 66, 6 }, { 198, 8 }, { 86, 8 }, { 104, 8 }, { 14, 9 }, { 122, 8 }, { 22, 9 },
                    { 38, 9 }, { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 },
                    { 26, 9 }, { 42, 9 }, { 5, 8 }, { 193, 6 }, { 82, 6 }, { 50, 9 }, { 9, 8 },
                    { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 },
                    { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 },
                    { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 }, { 28, 9 }, { 44, 9 }, { 6, 8 },
                    { 194, 7 }, { 83, 7 }, { 52, 9 }, { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 },
                    { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 },
                    { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 56, 9 }, { 12, 8 }, { 121, 7 },
                    { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 },
                    { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 },
                    { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 147, 5 }, { 209, 12 }, { 150, 5 }, { 162, 5 },
                    { 65, 5 }, { 209, 12 }, { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 },
                    { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 176, 10 }, { 148, 6 }, { 188, 10 },
                    { 151, 6 }, { 163, 6 }, { 66, 6 }, { 200, 10 }, { 154, 6 }, { 166, 6 }, { 68, 6 },
                    { 178, 6 }, { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 }, { 169, 6 },
                    { 70, 6 }, { 181, 6 }, { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 },
                    { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 191, 10 }, { 152, 7 }, { 164, 7 }, { 145, 3 },
                    { 203, 10 }, { 90, 10 }, { 108, 10 }, { 69, 7 }, { 126, 10 }, { 75, 7 }, { 93, 7 },
                    { 64, 4 }, { 209, 12 }, { 158, 7 }, { 114, 10 }, { 71, 7 }, { 132, 10 }, { 77, 7 },
                    { 95, 7 }, { 65, 5 }, { 194, 7 }, { 83, 7 }, { 101, 7 }, { 67, 5 }, { 119, 7 },
                    { 73, 5 }, { 91, 5 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 },
                    { 138, 10 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 103, 7 },
                    { 68, 6 }, { 121, 7 }, { 74, 6 }, { 92, 6 }, { 2, 7 }, { 209, 12 }, { 157, 6 },
                    { 109, 7 }, { 70, 6 }, { 127, 7 }, { 76, 6 }, { 94, 6 }, { 4, 7 }, { 193, 6 },
                    { 82, 6 }, { 100, 6 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 145, 3 }, { 206, 10 }, { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 },
                    { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 }, { 116, 10 }, { 72, 8 }, { 134, 10 },
                    { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 },
                    { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 },
                    { 148, 6 }, { 140, 10 }, { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 },
                    { 63, 12 }, { 15, 10 }, { 122, 8 }, { 23, 10 }, { 39, 10 }, { 3, 8 }, { 209, 12 },
                    { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 }, { 27, 10 }, { 43, 10 }, { 5, 8 },
                    { 193, 6 }, { 82, 6 }, { 51, 10 }, { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 },
                    { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 },
                    { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 },
                    { 130, 8 }, { 29, 10 }, { 45, 10 }, { 6, 8 }, { 194, 7 }, { 83, 7 }, { 53, 10 },
                    { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 },
                    { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 },
                    { 85, 7 }, { 57, 10 }, { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 },
                    { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 },
                    { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 },
                    { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 },
                    { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 160, 9 }, { 172, 9 },
                    { 147, 5 }, { 184, 9 }, { 150, 5 }, { 162, 5 }, { 65, 5 }, { 196, 9 }, { 153, 5 },
                    { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 },
                    { 209, 12 }, { 175, 9 }, { 148, 6 }, { 142, 10 }, { 81, 9 }, { 99, 9 }, { 66, 6 },
                    { 199, 9 }, { 87, 9 }, { 105, 9 }, { 68, 6 }, { 123, 9 }, { 74, 6 }, { 92, 6 },
                    { 64, 4 }, { 209, 12 }, { 157, 6 }, { 111, 9 }, { 70, 6 }, { 129, 9 }, { 76, 6 },
                    { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 },
                    { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 190, 9 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 202, 9 }, { 89, 9 }, { 107, 9 },
                    { 69, 7 }, { 125, 9 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 },
                    { 113, 9 }, { 71, 7 }, { 131, 9 }, { 30, 10 }, { 46, 10 }, { 7, 9 }, { 194, 7 },
                    { 83, 7 }, { 54, 10 }, { 11, 9 }, { 119, 7 }, { 19, 9 }, { 35, 9 }, { 1, 7 },
                    { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 137, 9 }, { 79, 7 }, { 97, 7 },
                    { 66, 6 }, { 197, 7 }, { 85, 7 }, { 58, 10 }, { 13, 9 }, { 121, 7 }, { 21, 9 },
                    { 37, 9 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 },
                    { 25, 9 }, { 41, 9 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 49, 9 }, { 8, 7 },
                    { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 205, 9 }, { 156, 8 },
                    { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 },
                    { 159, 8 }, { 115, 9 }, { 72, 8 }, { 133, 9 }, { 78, 8 }, { 96, 8 }, { 65, 5 },
                    { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 },
                    { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 }, { 139, 9 }, { 80, 8 },
                    { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 }, { 60, 10 }, { 14, 9 }, { 122, 8 },
                    { 22, 9 }, { 38, 9 }, { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 },
                    { 128, 8 }, { 26, 9 }, { 42, 9 }, { 5, 8 }, { 193, 6 }, { 82, 6 }, { 50, 9 },
                    { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 },
                    { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 },
                    { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 }, { 28, 9 }, { 44, 9 },
                    { 6, 8 }, { 194, 7 }, { 83, 7 }, { 52, 9 }, { 10, 8 }, { 119, 7 }, { 18, 8 },
                    { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 },
                    { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 56, 9 }, { 12, 8 },
                    { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 },
                    { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 },
                    { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 },
                    { 64, 4 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 147, 5 }, { 209, 12 }, { 150, 5 },
                    { 162, 5 }, { 65, 5 }, { 209, 12 }, { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 },
                    { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 148, 6 },
                    { 209, 12 }, { 151, 6 }, { 163, 6 }, { 66, 6 }, { 209, 12 }, { 154, 6 }, { 166, 6 },
                    { 68, 6 }, { 178, 6 }, { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 },
                    { 169, 6 }, { 70, 6 }, { 181, 6 }, { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 },
                    { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 192, 11 }, { 152, 7 }, { 164, 7 },
                    { 145, 3 }, { 204, 11 }, { 155, 7 }, { 167, 7 }, { 69, 7 }, { 179, 7 }, { 75, 7 },
                    { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 170, 7 }, { 71, 7 }, { 182, 7 },
                    { 77, 7 }, { 95, 7 }, { 65, 5 }, { 194, 7 }, { 83, 7 }, { 101, 7 }, { 67, 5 },
                    { 119, 7 }, { 73, 5 }, { 91, 5 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 },
                    { 148, 6 }, { 185, 7 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 },
                    { 103, 7 }, { 68, 6 }, { 121, 7 }, { 74, 6 }, { 92, 6 }, { 2, 7 }, { 209, 12 },
                    { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 76, 6 }, { 94, 6 }, { 4, 7 },
                    { 193, 6 }, { 82, 6 }, { 100, 6 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 145, 3 }, { 207, 11 }, { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 },
                    { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 }, { 117, 11 }, { 72, 8 },
                    { 135, 11 }, { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 },
                    { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 },
                    { 174, 8 }, { 148, 6 }, { 141, 11 }, { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 },
                    { 86, 8 }, { 104, 8 }, { 68, 6 }, { 122, 8 }, { 74, 6 }, { 92, 6 }, { 3, 8 },
                    { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 }, { 76, 6 }, { 94, 6 },
                    { 5, 8 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 9, 8 }, { 118, 6 }, { 17, 8 },
                    { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 },
                    { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 },
                    { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 },
                    { 71, 7 }, { 130, 8 }, { 77, 7 }, { 95, 7 }, { 6, 8 }, { 194, 7 }, { 83, 7 },
                    { 101, 7 }, { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 },
                    { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 },
                    { 197, 7 }, { 85, 7 }, { 103, 7 }, { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 },
                    { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 },
                    { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 },
                    { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 160, 9 },
                    { 172, 9 }, { 147, 5 }, { 184, 9 }, { 150, 5 }, { 162, 5 }, { 65, 5 }, { 196, 9 },
                    { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 },
                    { 209, 12 }, { 209, 12 }, { 175, 9 }, { 148, 6 }, { 143, 11 }, { 81, 9 }, { 99, 9 },
                    { 66, 6 }, { 199, 9 }, { 87, 9 }, { 105, 9 }, { 68, 6 }, { 123, 9 }, { 74, 6 },
                    { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 }, { 111, 9 }, { 70, 6 }, { 129, 9 },
                    { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 },
                    { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 190, 9 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 202, 9 }, { 89, 9 },
                    { 107, 9 }, { 69, 7 }, { 125, 9 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 },
                    { 158, 7 }, { 113, 9 }, { 71, 7 }, { 131, 9 }, { 31, 11 }, { 47, 11 }, { 7, 9 },
                    { 194, 7 }, { 83, 7 }, { 55, 11 }, { 11, 9 }, { 119, 7 }, { 19, 9 }, { 35, 9 },
                    { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 137, 9 }, { 79, 7 },
                    { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 59, 11 }, { 13, 9 }, { 121, 7 },
                    { 21, 9 }, { 37, 9 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 },
                    { 127, 7 }, { 25, 9 }, { 41, 9 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 49, 9 },
                    { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 205, 9 },
                    { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 },
                    { 209, 12 }, { 159, 8 }, { 115, 9 }, { 72, 8 }, { 133, 9 }, { 78, 8 }, { 96, 8 },
                    { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 },
                    { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 }, { 139, 9 },
                    { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 }, { 61, 11 }, { 14, 9 },
                    { 122, 8 }, { 22, 9 }, { 38, 9 }, { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 },
                    { 70, 6 }, { 128, 8 }, { 26, 9 }, { 42, 9 }, { 5, 8 }, { 193, 6 }, { 82, 6 },
                    { 50, 9 }, { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 },
                    { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 },
                    { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 }, { 28, 9 },
                    { 44, 9 }, { 6, 8 }, { 194, 7 }, { 83, 7 }, { 52, 9 }, { 10, 8 }, { 119, 7 },
                    { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 },
                    { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 56, 9 },
                    { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 },
                    { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 },
                    { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 145, 3 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 },
                    { 161, 4 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 147, 5 }, { 209, 12 },
                    { 150, 5 }, { 162, 5 }, { 65, 5 }, { 209, 12 }, { 153, 5 }, { 165, 5 }, { 67, 5 },
                    { 177, 5 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 176, 10 },
                    { 148, 6 }, { 188, 10 }, { 151, 6 }, { 163, 6 }, { 66, 6 }, { 200, 10 }, { 154, 6 },
                    { 166, 6 }, { 68, 6 }, { 178, 6 }, { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 },
                    { 157, 6 }, { 169, 6 }, { 70, 6 }, { 181, 6 }, { 76, 6 }, { 94, 6 }, { 65, 5 },
                    { 193, 6 }, { 82, 6 }, { 100, 6 }, { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 },
                    { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 191, 10 }, { 152, 7 },
                    { 164, 7 }, { 145, 3 }, { 203, 10 }, { 90, 10 }, { 108, 10 }, { 69, 7 }, { 126, 10 },
                    { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 114, 10 }, { 71, 7 },
                    { 132, 10 }, { 77, 7 }, { 95, 7 }, { 65, 5 }, { 194, 7 }, { 83, 7 }, { 101, 7 },
                    { 67, 5 }, { 119, 7 }, { 73, 5 }, { 91, 5 }, { 1, 7 }, { 209, 12 }, { 209, 12 },
                    { 173, 7 }, { 148, 6 }, { 138, 10 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 },
                    { 85, 7 }, { 103, 7 }, { 68, 6 }, { 121, 7 }, { 74, 6 }, { 92, 6 }, { 2, 7 },
                    { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 76, 6 }, { 94, 6 },
                    { 4, 7 }, { 193, 6 }, { 82, 6 }, { 100, 6 }, { 8, 7 }, { 118, 6 }, { 16, 7 },
                    { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 145, 3 }, { 206, 10 }, { 156, 8 }, { 168, 8 }, { 146, 4 },
                    { 180, 8 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 }, { 159, 8 }, { 116, 10 },
                    { 72, 8 }, { 134, 10 }, { 78, 8 }, { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 },
                    { 102, 8 }, { 67, 5 }, { 120, 8 }, { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 },
                    { 209, 12 }, { 174, 8 }, { 148, 6 }, { 140, 10 }, { 80, 8 }, { 98, 8 }, { 66, 6 },
                    { 198, 8 }, { 86, 8 }, { 62, 11 }, { 15, 10 }, { 122, 8 }, { 23, 10 }, { 39, 10 },
                    { 3, 8 }, { 209, 12 }, { 157, 6 }, { 110, 8 }, { 70, 6 }, { 128, 8 }, { 27, 10 },
                    { 43, 10 }, { 5, 8 }, { 193, 6 }, { 82, 6 }, { 51, 10 }, { 9, 8 }, { 118, 6 },
                    { 17, 8 }, { 33, 8 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 189, 8 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 },
                    { 69, 7 }, { 124, 8 }, { 75, 7 }, { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 },
                    { 112, 8 }, { 71, 7 }, { 130, 8 }, { 29, 10 }, { 45, 10 }, { 6, 8 }, { 194, 7 },
                    { 83, 7 }, { 53, 10 }, { 10, 8 }, { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 },
                    { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 },
                    { 66, 6 }, { 197, 7 }, { 85, 7 }, { 57, 10 }, { 12, 8 }, { 121, 7 }, { 20, 8 },
                    { 36, 8 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 },
                    { 24, 8 }, { 40, 8 }, { 4, 7 }, { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 },
                    { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 146, 4 }, { 209, 12 }, { 149, 4 }, { 161, 4 }, { 64, 4 }, { 209, 12 },
                    { 160, 9 }, { 172, 9 }, { 147, 5 }, { 184, 9 }, { 150, 5 }, { 162, 5 }, { 65, 5 },
                    { 196, 9 }, { 153, 5 }, { 165, 5 }, { 67, 5 }, { 177, 5 }, { 73, 5 }, { 91, 5 },
                    { 64, 4 }, { 209, 12 }, { 209, 12 }, { 175, 9 }, { 148, 6 }, { 142, 10 }, { 81, 9 },
                    { 99, 9 }, { 66, 6 }, { 199, 9 }, { 87, 9 }, { 105, 9 }, { 68, 6 }, { 123, 9 },
                    { 74, 6 }, { 92, 6 }, { 64, 4 }, { 209, 12 }, { 157, 6 }, { 111, 9 }, { 70, 6 },
                    { 129, 9 }, { 76, 6 }, { 94, 6 }, { 65, 5 }, { 193, 6 }, { 82, 6 }, { 100, 6 },
                    { 67, 5 }, { 118, 6 }, { 73, 5 }, { 91, 5 }, { 0, 6 }, { 209, 12 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 190, 9 }, { 152, 7 }, { 164, 7 }, { 145, 3 }, { 202, 9 },
                    { 89, 9 }, { 107, 9 }, { 69, 7 }, { 125, 9 }, { 75, 7 }, { 93, 7 }, { 64, 4 },
                    { 209, 12 }, { 158, 7 }, { 113, 9 }, { 71, 7 }, { 131, 9 }, { 30, 10 }, { 46, 10 },
                    { 7, 9 }, { 194, 7 }, { 83, 7 }, { 54, 10 }, { 11, 9 }, { 119, 7 }, { 19, 9 },
                    { 35, 9 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 }, { 148, 6 }, { 137, 9 },
                    { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 }, { 58, 10 }, { 13, 9 },
                    { 121, 7 }, { 21, 9 }, { 37, 9 }, { 2, 7 }, { 209, 12 }, { 157, 6 }, { 109, 7 },
                    { 70, 6 }, { 127, 7 }, { 25, 9 }, { 41, 9 }, { 4, 7 }, { 193, 6 }, { 82, 6 },
                    { 49, 9 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 }, { 0, 6 }, { 209, 12 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 145, 3 },
                    { 205, 9 }, { 156, 8 }, { 168, 8 }, { 146, 4 }, { 180, 8 }, { 149, 4 }, { 161, 4 },
                    { 64, 4 }, { 209, 12 }, { 159, 8 }, { 115, 9 }, { 72, 8 }, { 133, 9 }, { 78, 8 },
                    { 96, 8 }, { 65, 5 }, { 195, 8 }, { 84, 8 }, { 102, 8 }, { 67, 5 }, { 120, 8 },
                    { 73, 5 }, { 91, 5 }, { 64, 4 }, { 209, 12 }, { 209, 12 }, { 174, 8 }, { 148, 6 },
                    { 139, 9 }, { 80, 8 }, { 98, 8 }, { 66, 6 }, { 198, 8 }, { 86, 8 }, { 60, 10 },
                    { 14, 9 }, { 122, 8 }, { 22, 9 }, { 38, 9 }, { 3, 8 }, { 209, 12 }, { 157, 6 },
                    { 110, 8 }, { 70, 6 }, { 128, 8 }, { 26, 9 }, { 42, 9 }, { 5, 8 }, { 193, 6 },
                    { 82, 6 }, { 50, 9 }, { 9, 8 }, { 118, 6 }, { 17, 8 }, { 33, 8 }, { 0, 6 },
                    { 209, 12 }, { 209, 12 }, { 209, 12 }, { 209, 12 }, { 189, 8 }, { 152, 7 }, { 164, 7 },
                    { 145, 3 }, { 201, 8 }, { 88, 8 }, { 106, 8 }, { 69, 7 }, { 124, 8 }, { 75, 7 },
                    { 93, 7 }, { 64, 4 }, { 209, 12 }, { 158, 7 }, { 112, 8 }, { 71, 7 }, { 130, 8 },
                    { 28, 9 }, { 44, 9 }, { 6, 8 }, { 194, 7 }, { 83, 7 }, { 52, 9 }, { 10, 8 },
                    { 119, 7 }, { 18, 8 }, { 34, 8 }, { 1, 7 }, { 209, 12 }, { 209, 12 }, { 173, 7 },
                    { 148, 6 }, { 136, 8 }, { 79, 7 }, { 97, 7 }, { 66, 6 }, { 197, 7 }, { 85, 7 },
                    { 56, 9 }, { 12, 8 }, { 121, 7 }, { 20, 8 }, { 36, 8 }, { 2, 7 }, { 209, 12 },
                    { 157, 6 }, { 109, 7 }, { 70, 6 }, { 127, 7 }, { 24, 8 }, { 40, 8 }, { 4, 7 },
                    { 193, 6 }, { 82, 6 }, { 48, 8 }, { 8, 7 }, { 118, 6 }, { 16, 7 }, { 32, 7 },
                    { 0, 6 }
                };
            } // namespace utf8_to_utf16
        } // namespace tables
    } // unnamed namespace
} // namespace simdutf

#endif // SIMDUTF_UTF8_TO_UTF16_TABLES_H
/* end file src/tables/utf8_to_utf16_tables.h */
/* begin file src/tables/utf16_to_utf8_tables.h */
// file generated by scripts/sse_convert_utf16_to_utf8.py
#ifndef SIMDUTF_UTF16_TO_UTF8_TABLES_H
    #define SIMDUTF_UTF16_TO_UTF8_TABLES_H

namespace simdutf
{
    namespace
    {
        namespace tables
        {
            namespace utf16_to_utf8
            {

                // 1 byte for length, 16 bytes for mask
                const uint8_t pack_1_2_utf8_bytes[256][17] = {
                    { 16, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14 },
                    { 15, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80 },
                    { 15, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80 },
                    { 14, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 15, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80 },
                    { 14, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 14, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80 },
                    { 14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 15, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80 },
                    { 14, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 7, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80 },
                    { 14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 7, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 7, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 7, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 15, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80 },
                    { 14, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 6, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 6, 9, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 6, 8, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 5, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 6, 9, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 6, 8, 11, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 3, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 3, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 6, 9, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 1, 0, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 2, 4, 6, 8, 10, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 15, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80 },
                    { 14, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80 },
                    { 13, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 4, 7, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 7, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 7, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 7, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 5, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 7, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 7, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 3, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 3, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 7, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 1, 0, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 2, 4, 7, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 14, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80 },
                    { 13, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 2, 5, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 5, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 13, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 4, 6, 9, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 6, 8, 11, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 3, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 3, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 6, 9, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 1, 0, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 2, 4, 6, 8, 10, 13, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 13, 1, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80 },
                    { 12, 0, 3, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 2, 5, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 5, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 3, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 3, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 5, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 1, 0, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 2, 5, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 12, 1, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 3, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 3, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 3, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 0, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 2, 4, 6, 9, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 1, 0, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 2, 4, 6, 8, 11, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 11, 1, 0, 3, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 3, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 1, 0, 3, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 3, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 1, 0, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 2, 4, 6, 9, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 1, 0, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 0, 2, 4, 6, 8, 10, 12, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 }
                };

                // 1 byte for length, 16 bytes for mask
                const uint8_t pack_1_2_3_utf8_bytes[256][17] = {
                    { 12, 2, 3, 1, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 11, 3, 1, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 0, 6, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 2, 3, 1, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 11, 2, 3, 1, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 3, 1, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 7, 5, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 2, 3, 1, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 3, 1, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 4, 10, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 2, 3, 1, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 6, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 3, 1, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 2, 3, 1, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 7, 5, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 2, 3, 1, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 3, 1, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 4, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 11, 2, 3, 1, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 3, 1, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 6, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 2, 3, 1, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 2, 3, 1, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 3, 1, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 7, 5, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 2, 3, 1, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 4, 11, 9, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 2, 3, 1, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 3, 1, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 0, 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 2, 3, 1, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 3, 1, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 2, 3, 1, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 7, 5, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 2, 3, 1, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 4, 8, 14, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 2, 3, 1, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 6, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 3, 1, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 2, 3, 1, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 7, 5, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 2, 3, 1, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 3, 1, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 4, 10, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 2, 3, 1, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 3, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 6, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 2, 3, 1, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 2, 3, 1, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 5, 2, 3, 1, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 3, 1, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 0, 7, 5, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 2, 3, 1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 3, 1, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 0, 4, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 2, 3, 1, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 6, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 3, 1, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 3, 1, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 0, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 2, 3, 1, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 3, 1, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 0, 7, 5, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 2, 3, 1, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 3, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 4, 11, 9, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 2, 3, 1, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 3, 1, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 0, 6, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 2, 3, 1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 3, 1, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 0, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 2, 3, 1, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 3, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 7, 5, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 2, 3, 1, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 3, 1, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 0, 4, 8, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 11, 2, 3, 1, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 3, 1, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 6, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 2, 3, 1, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 2, 3, 1, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 3, 1, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 7, 5, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 2, 3, 1, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 4, 10, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 2, 3, 1, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 6, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 2, 3, 1, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 4, 3, 1, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 0, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 2, 3, 1, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 3, 1, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 7, 5, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 2, 3, 1, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 4, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 10, 2, 3, 1, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 3, 1, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 0, 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 2, 3, 1, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 3, 1, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 2, 3, 1, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 7, 5, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 2, 3, 1, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 4, 11, 9, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 2, 3, 1, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 6, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 3, 1, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 2, 3, 1, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 7, 5, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 2, 3, 1, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 3, 1, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 4, 8, 15, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 2, 3, 1, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 3, 1, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 0, 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 2, 3, 1, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 3, 1, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 2, 3, 1, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 7, 5, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 2, 3, 1, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 4, 10, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 2, 3, 1, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 3, 1, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 0, 6, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 2, 3, 1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 3, 1, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 0, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 2, 3, 1, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 3, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 7, 5, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 2, 3, 1, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 3, 1, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 0, 4, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 9, 2, 3, 1, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 3, 1, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 6, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 3, 1, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 2, 3, 1, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 7, 5, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 2, 3, 1, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 3, 1, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 4, 11, 9, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 2, 3, 1, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 3, 1, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 6, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 3, 1, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 3, 1, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 0, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 2, 3, 1, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 3, 1, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 0, 7, 5, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 2, 3, 1, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 3, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 3, 1, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 4, 8, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 }
                };

            } // namespace utf16_to_utf8
        } // namespace tables
    } // unnamed namespace
} // namespace simdutf

#endif // SIMDUTF_UTF16_TO_UTF8_TABLES_H
/* end file src/tables/utf16_to_utf8_tables.h */
/* begin file src/tables/utf32_to_utf16_tables.h */
// file generated by scripts/sse_convert_utf32_to_utf16.py
#ifndef SIMDUTF_UTF32_TO_UTF16_TABLES_H
    #define SIMDUTF_UTF32_TO_UTF16_TABLES_H

namespace simdutf
{
    namespace
    {
        namespace tables
        {
            namespace utf32_to_utf16
            {

                const uint8_t pack_utf32_to_utf16le[16][16] = {
                    { 0, 1, 4, 5, 8, 9, 12, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 2, 3, 4, 5, 8, 9, 12, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 4, 5, 6, 7, 8, 9, 12, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 4, 5, 8, 9, 10, 11, 12, 13, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0x80, 0x80 },
                    { 0, 1, 4, 5, 8, 9, 12, 13, 14, 15, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 2, 3, 4, 5, 8, 9, 12, 13, 14, 15, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 0x80, 0x80 },
                    { 0, 1, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 0x80, 0x80, 0x80, 0x80 },
                    { 0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 0x80, 0x80 },
                    { 0, 1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0x80, 0x80 },
                    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
                };

                const uint8_t pack_utf32_to_utf16be[16][16] = {
                    { 1, 0, 5, 4, 9, 8, 13, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 3, 2, 5, 4, 9, 8, 13, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 5, 4, 7, 6, 9, 8, 13, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 13, 12, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 5, 4, 9, 8, 11, 10, 13, 12, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 3, 2, 5, 4, 9, 8, 11, 10, 13, 12, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 0x80, 0x80 },
                    { 1, 0, 5, 4, 9, 8, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 3, 2, 5, 4, 9, 8, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 5, 4, 7, 6, 9, 8, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 13, 12, 15, 14, 0x80, 0x80 },
                    { 1, 0, 5, 4, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80, 0x80, 0x80 },
                    { 1, 0, 3, 2, 5, 4, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 1, 0, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 0x80, 0x80 },
                    { 1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14 },
                };

            } // namespace utf32_to_utf16
        } // namespace tables
    } // unnamed namespace
} // namespace simdutf

#endif // SIMDUTF_UTF16_TO_UTF8_TABLES_H
/* end file src/tables/utf32_to_utf16_tables.h */
// End of tables.

// Implementations: they need to be setup before including
// scalar/* code, as the scalar code is sometimes enabled
// only for peculiar build targets.

// The best choice should always come first!
/* begin file src/simdutf/arm64.h */
#ifndef SIMDUTF_ARM64_H
    #define SIMDUTF_ARM64_H

    #ifdef SIMDUTF_FALLBACK_H
        #error "arm64.h must be included before fallback.h"
    #endif

    #ifndef SIMDUTF_IMPLEMENTATION_ARM64
        #define SIMDUTF_IMPLEMENTATION_ARM64 (SIMDUTF_IS_ARM64)
    #endif
    #if SIMDUTF_IMPLEMENTATION_ARM64 && SIMDUTF_IS_ARM64
        #define SIMDUTF_CAN_ALWAYS_RUN_ARM64 1
    #else
        #define SIMDUTF_CAN_ALWAYS_RUN_ARM64 0
    #endif

    #if SIMDUTF_IMPLEMENTATION_ARM64

namespace simdutf
{
    /**
     * Implementation for NEON (ARMv8).
     */
    namespace arm64
    {
    } // namespace arm64
} // namespace simdutf

        /* begin file src/simdutf/arm64/implementation.h */
        #ifndef SIMDUTF_ARM64_IMPLEMENTATION_H
            #define SIMDUTF_ARM64_IMPLEMENTATION_H

namespace simdutf
{
    namespace arm64
    {

        namespace
        {
            using namespace simdutf;
        }

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation("arm64", "ARM NEON",
                      internal::instruction_set::NEON)
            {
            }
            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;
            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;
        };

    } // namespace arm64
} // namespace simdutf

        #endif // SIMDUTF_ARM64_IMPLEMENTATION_H
        /* end file src/simdutf/arm64/implementation.h */

        /* begin file src/simdutf/arm64/begin.h */
        // redefining SIMDUTF_IMPLEMENTATION to "arm64"
        // #define SIMDUTF_IMPLEMENTATION arm64
        #define SIMDUTF_SIMD_HAS_BYTEMASK 1
    /* end file src/simdutf/arm64/begin.h */

    // Declarations
        /* begin file src/simdutf/arm64/intrinsics.h */
        #ifndef SIMDUTF_ARM64_INTRINSICS_H
            #define SIMDUTF_ARM64_INTRINSICS_H

            // This should be the correct header whether
            // you use visual studio or other compilers.
            #include <arm_neon.h>

        #endif //  SIMDUTF_ARM64_INTRINSICS_H
        /* end file src/simdutf/arm64/intrinsics.h */
        /* begin file src/simdutf/arm64/bitmanipulation.h */
        #ifndef SIMDUTF_ARM64_BITMANIPULATION_H
            #define SIMDUTF_ARM64_BITMANIPULATION_H

namespace simdutf
{
    namespace arm64
    {
        namespace
        {

            /* result might be undefined when input_num is zero */
            simdutf_really_inline int count_ones(uint64_t input_num)
            {
                return vaddv_u8(vcnt_u8(vcreate_u8(input_num)));
            }

            #if SIMDUTF_NEED_TRAILING_ZEROES
            simdutf_really_inline int trailing_zeroes(uint64_t input_num)
            {
                #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
                unsigned long ret;
                // Search the mask data from least significant bit (LSB)
                // to the most significant bit (MSB) for a set bit (1).
                _BitScanForward64(&ret, input_num);
                return (int)ret;
                #else // SIMDUTF_REGULAR_VISUAL_STUDIO
                return __builtin_ctzll(input_num);
                #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
            }
            #endif

        } // unnamed namespace
    } // namespace arm64
} // namespace simdutf

        #endif // SIMDUTF_ARM64_BITMANIPULATION_H
        /* end file src/simdutf/arm64/bitmanipulation.h */
        /* begin file src/simdutf/arm64/simd.h */
        #ifndef SIMDUTF_ARM64_SIMD_H
            #define SIMDUTF_ARM64_SIMD_H

            #include <type_traits>

namespace simdutf
{
    namespace arm64
    {
        namespace
        {
            namespace simd
            {

            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
                namespace
                {
                                // Start of private section with Visual Studio workaround

                #ifndef simdutf_make_uint8x16_t
                    #define simdutf_make_uint8x16_t(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, \
                        x11, x12, x13, x14, x15, x16)                                        \
                        ([=]() {                                                             \
                            uint8_t array[16] = { x1, x2, x3, x4, x5, x6, x7, x8,            \
                                x9, x10, x11, x12, x13, x14, x15, x16 };                     \
                            return vld1q_u8(array);                                          \
                        }())
                #endif
                #ifndef simdutf_make_int8x16_t
                    #define simdutf_make_int8x16_t(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, \
                        x11, x12, x13, x14, x15, x16)                                       \
                        ([=]() {                                                            \
                            int8_t array[16] = { x1, x2, x3, x4, x5, x6, x7, x8,            \
                                x9, x10, x11, x12, x13, x14, x15, x16 };                    \
                            return vld1q_s8(array);                                         \
                        }())
                #endif

                #ifndef simdutf_make_uint8x8_t
                    #define simdutf_make_uint8x8_t(x1, x2, x3, x4, x5, x6, x7, x8) \
                        ([=]() {                                                   \
                            uint8_t array[8] = { x1, x2, x3, x4, x5, x6, x7, x8 }; \
                            return vld1_u8(array);                                 \
                        }())
                #endif
                #ifndef simdutf_make_int8x8_t
                    #define simdutf_make_int8x8_t(x1, x2, x3, x4, x5, x6, x7, x8) \
                        ([=]() {                                                  \
                            int8_t array[8] = { x1, x2, x3, x4, x5, x6, x7, x8 }; \
                            return vld1_s8(array);                                \
                        }())
                #endif
                #ifndef simdutf_make_uint16x8_t
                    #define simdutf_make_uint16x8_t(x1, x2, x3, x4, x5, x6, x7, x8) \
                        ([=]() {                                                    \
                            uint16_t array[8] = { x1, x2, x3, x4, x5, x6, x7, x8 }; \
                            return vld1q_u16(array);                                \
                        }())
                #endif
                #ifndef simdutf_make_int16x8_t
                    #define simdutf_make_int16x8_t(x1, x2, x3, x4, x5, x6, x7, x8) \
                        ([=]() {                                                   \
                            int16_t array[8] = { x1, x2, x3, x4, x5, x6, x7, x8 }; \
                            return vld1q_s16(array);                               \
                        }())
                #endif

                    // End of private section with Visual Studio workaround
                } // namespace
            #endif // SIMDUTF_REGULAR_VISUAL_STUDIO

                template <typename T>
                struct simd8;

                //
                // Base class of simd8<uint8_t> and simd8<bool>, both of which use uint8x16_t
                // internally.
                //
                template <typename T, typename Mask = simd8<bool>>
                struct base_u8
                {
                    uint8x16_t value;
                    static const int SIZE = sizeof(value);
                    void dump() const
                    {
                        uint8_t temp[16];
                        vst1q_u8(temp, *this);
                        printf("[%04x, %04x, %04x, %04x, %04x, %04x, %04x, %04x,%04x, %04x, %04x, "
                               "%04x, %04x, %04x, %04x, %04x]\n",
                            temp[0], temp[1], temp[2], temp[3], temp[4], temp[5], temp[6],
                            temp[7], temp[8], temp[9], temp[10], temp[11], temp[12], temp[13],
                            temp[14], temp[15]);
                    }
                    // Conversion from/to SIMD register
                    simdutf_really_inline base_u8(const uint8x16_t _value)
                        : value(_value)
                    {
                    }
                    simdutf_really_inline operator const uint8x16_t&() const
                    {
                        return this->value;
                    }
                    simdutf_really_inline operator uint8x16_t&() { return this->value; }
                    simdutf_really_inline T first() const { return vgetq_lane_u8(*this, 0); }
                    simdutf_really_inline T last() const { return vgetq_lane_u8(*this, 15); }

                    // Bit operations
                    simdutf_really_inline simd8<T> operator|(const simd8<T> other) const
                    {
                        return vorrq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<T> operator&(const simd8<T> other) const
                    {
                        return vandq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<T> operator^(const simd8<T> other) const
                    {
                        return veorq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<T> bit_andnot(const simd8<T> other) const
                    {
                        return vbicq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
                    simdutf_really_inline simd8<T>& operator|=(const simd8<T> other)
                    {
                        auto this_cast = static_cast<simd8<T>*>(this);
                        *this_cast = *this_cast | other;
                        return *this_cast;
                    }
                    simdutf_really_inline simd8<T>& operator&=(const simd8<T> other)
                    {
                        auto this_cast = static_cast<simd8<T>*>(this);
                        *this_cast = *this_cast & other;
                        return *this_cast;
                    }
                    simdutf_really_inline simd8<T>& operator^=(const simd8<T> other)
                    {
                        auto this_cast = static_cast<simd8<T>*>(this);
                        *this_cast = *this_cast ^ other;
                        return *this_cast;
                    }

                    friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
                        const simd8<T> rhs)
                    {
                        return vceqq_u8(lhs, rhs);
                    }

                    template <int N = 1>
                    simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const
                    {
                        return vextq_u8(prev_chunk, *this, 16 - N);
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd8<bool> : base_u8<bool>
                {
                    typedef uint16_t bitmask_t;
                    typedef uint32_t bitmask2_t;

                    static simdutf_really_inline simd8<bool> splat(bool _value)
                    {
                        return vmovq_n_u8(uint8_t(-(!!_value)));
                    }

                    simdutf_really_inline simd8(const uint8x16_t _value)
                        : base_u8<bool>(_value)
                    {
                    }
                    // False constructor
                    simdutf_really_inline simd8()
                        : simd8(vdupq_n_u8(0))
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(bool _value)
                        : simd8(splat(_value))
                    {
                    }
                    simdutf_really_inline void store(uint8_t dst[16]) const
                    {
                        return vst1q_u8(dst, *this);
                    }

                    // We return uint32_t instead of uint16_t because that seems to be more
                    // efficient for most purposes (cutting it down to uint16_t costs performance
                    // in some compilers).
                    simdutf_really_inline uint32_t to_bitmask() const
                    {
            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
                        const uint8x16_t bit_mask = simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
                            0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
            #else
                        const uint8x16_t bit_mask = { 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
                            0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80 };
            #endif
                        auto minput = *this & bit_mask;
                        uint8x16_t tmp = vpaddq_u8(minput, minput);
                        tmp = vpaddq_u8(tmp, tmp);
                        tmp = vpaddq_u8(tmp, tmp);
                        return vgetq_lane_u16(vreinterpretq_u16_u8(tmp), 0);
                    }

                    // Returns 4-bit out of each byte, alternating between the high 4 bits and low
                    // bits result it is 64 bit. This method is expected to be faster than none()
                    // and is equivalent when the vector register is the result of a comparison,
                    // with byte values 0xff and 0x00.
                    simdutf_really_inline uint64_t to_bitmask64() const
                    {
                        return vget_lane_u64(
                            vreinterpret_u64_u8(vshrn_n_u16(vreinterpretq_u16_u8(*this), 4)), 0);
                    }

                    simdutf_really_inline bool any() const
                    {
                        return vmaxvq_u32(vreinterpretq_u32_u8(*this)) != 0;
                    }
                    simdutf_really_inline bool none() const
                    {
                        return vmaxvq_u32(vreinterpretq_u32_u8(*this)) == 0;
                    }
                    simdutf_really_inline bool all() const
                    {
                        return vminvq_u32(vreinterpretq_u32_u8(*this)) == 0xFFFFF;
                    }
                };

                // Unsigned bytes
                template <>
                struct simd8<uint8_t> : base_u8<uint8_t>
                {
                    static simdutf_really_inline simd8<uint8_t> splat(uint8_t _value)
                    {
                        return vmovq_n_u8(_value);
                    }
                    static simdutf_really_inline simd8<uint8_t> zero() { return vdupq_n_u8(0); }
                    static simdutf_really_inline simd8<uint8_t> load(const uint8_t* values)
                    {
                        return vld1q_u8(values);
                    }
                    simdutf_really_inline simd8(const uint8x16_t _value)
                        : base_u8<uint8_t>(_value)
                    {
                    }
                    // Zero constructor
                    simdutf_really_inline simd8()
                        : simd8(zero())
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const uint8_t values[16])
                        : simd8(load(values))
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(uint8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                            // Member-by-member initialization
            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
                    simdutf_really_inline
                    simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
                        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
                        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
                        : simd8(simdutf_make_uint8x16_t(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
                              v10, v11, v12, v13, v14, v15))
                    {
                    }
            #else
                    simdutf_really_inline
                    simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
                        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
                        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
                        : simd8(uint8x16_t { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                              v13, v14, v15 })
                    {
                    }
            #endif

                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<uint8_t>
                    repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
                        uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
                        uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
                        uint8_t v15)
                    {
                        return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15);
                    }

                    // Store to array
                    simdutf_really_inline void store(uint8_t dst[16]) const
                    {
                        return vst1q_u8(dst, *this);
                    }

                    // Saturated math
                    simdutf_really_inline simd8<uint8_t>
                    saturating_add(const simd8<uint8_t> other) const
                    {
                        return vqaddq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    saturating_sub(const simd8<uint8_t> other) const
                    {
                        return vqsubq_u8(*this, other);
                    }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd8<uint8_t>
                    operator+(const simd8<uint8_t> other) const
                    {
                        return vaddq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    operator-(const simd8<uint8_t> other) const
                    {
                        return vsubq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>& operator+=(const simd8<uint8_t> other)
                    {
                        *this = *this + other;
                        return *this;
                    }
                    simdutf_really_inline simd8<uint8_t>& operator-=(const simd8<uint8_t> other)
                    {
                        *this = *this - other;
                        return *this;
                    }

                    // Order-specific operations
                    simdutf_really_inline uint8_t max_val() const { return vmaxvq_u8(*this); }
                    simdutf_really_inline uint8_t min_val() const { return vminvq_u8(*this); }
                    simdutf_really_inline simd8<uint8_t>
                    max_val(const simd8<uint8_t> other) const
                    {
                        return vmaxq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    min_val(const simd8<uint8_t> other) const
                    {
                        return vminq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator<=(const simd8<uint8_t> other) const
                    {
                        return vcleq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator>=(const simd8<uint8_t> other) const
                    {
                        return vcgeq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator<(const simd8<uint8_t> other) const
                    {
                        return vcltq_u8(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator>(const simd8<uint8_t> other) const
                    {
                        return vcgtq_u8(*this, other);
                    }
                    // Same as >, but instead of guaranteeing all 1's == true, false = 0 and true
                    // = nonzero. For ARM, returns all 1's.
                    simdutf_really_inline simd8<uint8_t>
                    gt_bits(const simd8<uint8_t> other) const
                    {
                        return simd8<uint8_t>(*this > other);
                    }
                    // Same as <, but instead of guaranteeing all 1's == true, false = 0 and true
                    // = nonzero. For ARM, returns all 1's.
                    simdutf_really_inline simd8<uint8_t>
                    lt_bits(const simd8<uint8_t> other) const
                    {
                        return simd8<uint8_t>(*this < other);
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const
                    {
                        return vtstq_u8(*this, bits);
                    }
                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->max_val() < 0b10000000u;
                    }

                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        return this->max_val() != 0;
                    }
                    simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const
                    {
                        return (*this & bits).any_bits_set_anywhere();
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shr() const
                    {
                        return vshrq_n_u8(*this, N);
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shl() const
                    {
                        return vshlq_n_u8(*this, N);
                    }
                    simdutf_really_inline uint16_t sum_bytes() const { return vaddvq_u8(*this); }

                    // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
                    // for out of range values)
                    template <typename L>
                    simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const
                    {
                        return lookup_table.apply_lookup_16_to(*this);
                    }

                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
                        L replace5, L replace6, L replace7, L replace8, L replace9,
                        L replace10, L replace11, L replace12, L replace13, L replace14,
                        L replace15) const
                    {
                        return lookup_16(simd8<L>::repeat_16(
                            replace0, replace1, replace2, replace3, replace4, replace5, replace6,
                            replace7, replace8, replace9, replace10, replace11, replace12,
                            replace13, replace14, replace15));
                    }

                    template <typename T>
                    simdutf_really_inline simd8<uint8_t>
                    apply_lookup_16_to(const simd8<T> original) const
                    {
                        return vqtbl1q_u8(*this, simd8<uint8_t>(original));
                    }
                };

                // Signed bytes
                template <>
                struct simd8<int8_t>
                {
                    int8x16_t value;
                    static const int SIZE = sizeof(value);

                    static simdutf_really_inline simd8<int8_t> splat(int8_t _value)
                    {
                        return vmovq_n_s8(_value);
                    }
                    static simdutf_really_inline simd8<int8_t> zero() { return vdupq_n_s8(0); }
                    static simdutf_really_inline simd8<int8_t> load(const int8_t values[16])
                    {
                        return vld1q_s8(values);
                    }

                    // Use ST2 instead of UXTL+UXTL2 to interleave zeroes. UXTL is actually a
                    // USHLL #0, and shifting in NEON is actually quite slow.
                    //
                    // While this needs the registers to be in a specific order, bigger cores can
                    // interleave these with no overhead, and it still performs decently on little
                    // cores.
                    //    movi  v1.3d, #0
                    //      mov   v0.16b, value[0]
                    //    st2   {v0.16b, v1.16b}, [ptr], #32
                    //      mov   v0.16b, value[1]
                    //    st2   {v0.16b, v1.16b}, [ptr], #32
                    //    ...
                    template <endianness big_endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* p) const
                    {
                        int8x16x2_t pair = match_system(big_endian)
                            ? int8x16x2_t { { this->value, vmovq_n_s8(0) } }
                            : int8x16x2_t { { vmovq_n_s8(0), this->value } };
                        vst2q_s8(reinterpret_cast<int8_t*>(p), pair);
                    }

                    // currently unused
                    // Technically this could be done with ST4 like in store_ascii_as_utf16, but
                    // it is very much not worth it, as explicitly mentioned in the ARM Cortex-X1
                    // Core Software Optimization Guide:
                    //   4.18 Complex ASIMD instructions
                    //     The bandwidth of [ST4 with element size less than 64b] is limited by
                    //     decode constraints and it is advisable to avoid them when high
                    //     performing code is desired.
                    // Instead, it is better to use ZIP1+ZIP2 and two ST2.
                    simdutf_really_inline void store_ascii_as_utf32(char32_t* p) const
                    {
                        const uint16x8_t low = vreinterpretq_u16_s8(vzip1q_s8(this->value, vmovq_n_s8(0)));
                        const uint16x8_t high = vreinterpretq_u16_s8(vzip2q_s8(this->value, vmovq_n_s8(0)));
                        const uint16x8x2_t low_pair { { low, vmovq_n_u16(0) } };
                        vst2q_u16(reinterpret_cast<uint16_t*>(p), low_pair);
                        const uint16x8x2_t high_pair { { high, vmovq_n_u16(0) } };
                        vst2q_u16(reinterpret_cast<uint16_t*>(p + 8), high_pair);
                    }

                    // In places where the table can be reused, which is most uses in simdutf, it
                    // is worth it to do 4 table lookups, as there is no direct zero extension
                    // from u8 to u32.
                    simdutf_really_inline void store_ascii_as_utf32_tbl(char32_t* p) const
                    {
                        const simd8<uint8_t> tb1 { 0, 255, 255, 255, 1, 255, 255, 255,
                            2, 255, 255, 255, 3, 255, 255, 255 };
                        const simd8<uint8_t> tb2 { 4, 255, 255, 255, 5, 255, 255, 255,
                            6, 255, 255, 255, 7, 255, 255, 255 };
                        const simd8<uint8_t> tb3 { 8, 255, 255, 255, 9, 255, 255, 255,
                            10, 255, 255, 255, 11, 255, 255, 255 };
                        const simd8<uint8_t> tb4 { 12, 255, 255, 255, 13, 255, 255, 255,
                            14, 255, 255, 255, 15, 255, 255, 255 };

                        // encourage store pairing and interleaving
                        const auto shuf1 = this->apply_lookup_16_to(tb1);
                        const auto shuf2 = this->apply_lookup_16_to(tb2);
                        shuf1.store(reinterpret_cast<int8_t*>(p));
                        shuf2.store(reinterpret_cast<int8_t*>(p + 4));

                        const auto shuf3 = this->apply_lookup_16_to(tb3);
                        const auto shuf4 = this->apply_lookup_16_to(tb4);
                        shuf3.store(reinterpret_cast<int8_t*>(p + 8));
                        shuf4.store(reinterpret_cast<int8_t*>(p + 12));
                    }
                    // Conversion from/to SIMD register
                    simdutf_really_inline simd8(const int8x16_t _value)
                        : value { _value }
                    {
                    }
                    simdutf_really_inline operator const int8x16_t&() const
                    {
                        return this->value;
                    }
            #ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
                    simdutf_really_inline operator const uint8x16_t() const
                    {
                        return vreinterpretq_u8_s8(this->value);
                    }
            #endif
                    simdutf_really_inline operator int8x16_t&() { return this->value; }

                    // Zero constructor
                    simdutf_really_inline simd8()
                        : simd8(zero())
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(int8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const int8_t* values)
                        : simd8(load(values))
                    {
                    }
                            // Member-by-member initialization
            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
                    simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
                        int8_t v4, int8_t v5, int8_t v6, int8_t v7,
                        int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                        : simd8(simdutf_make_int8x16_t(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
                              v10, v11, v12, v13, v14, v15))
                    {
                    }
            #else
                    simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
                        int8_t v4, int8_t v5, int8_t v6, int8_t v7,
                        int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                        : simd8(int8x16_t { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                              v13, v14, v15 })
                    {
                    }
            #endif
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<int8_t>
                    repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
                        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                    {
                        return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15);
                    }

                    // Store to array
                    simdutf_really_inline void store(int8_t dst[16]) const
                    {
                        return vst1q_s8(dst, value);
                    }
                            // Explicit conversion to/from unsigned
                            //
                            // Under Visual Studio/ARM64 uint8x16_t and int8x16_t are apparently the same
                            // type. In theory, we could check this occurrence with std::same_as and
                            // std::enabled_if but it is C++14 and relatively ugly and hard to read.
            #ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
                    simdutf_really_inline explicit simd8(const uint8x16_t other)
                        : simd8(vreinterpretq_s8_u8(other))
                    {
                    }
            #endif
                    simdutf_really_inline operator simd8<uint8_t>() const
                    {
                        return vreinterpretq_u8_s8(this->value);
                    }

                    simdutf_really_inline simd8<int8_t>
                    operator|(const simd8<int8_t> other) const
                    {
                        return vorrq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<int8_t>
                    operator&(const simd8<int8_t> other) const
                    {
                        return vandq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<int8_t>
                    operator^(const simd8<int8_t> other) const
                    {
                        return veorq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<int8_t>
                    bit_andnot(const simd8<int8_t> other) const
                    {
                        return vbicq_s8(value, other.value);
                    }

                    // Math
                    simdutf_really_inline simd8<int8_t>
                    operator+(const simd8<int8_t> other) const
                    {
                        return vaddq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<int8_t>
                    operator-(const simd8<int8_t> other) const
                    {
                        return vsubq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<int8_t>& operator+=(const simd8<int8_t> other)
                    {
                        *this = *this + other;
                        return *this;
                    }
                    simdutf_really_inline simd8<int8_t>& operator-=(const simd8<int8_t> other)
                    {
                        *this = *this - other;
                        return *this;
                    }

                    simdutf_really_inline int8_t max_val() const { return vmaxvq_s8(value); }
                    simdutf_really_inline int8_t min_val() const { return vminvq_s8(value); }
                    simdutf_really_inline bool is_ascii() const { return this->min_val() >= 0; }

                    // Order-sensitive comparisons
                    simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const
                    {
                        return vmaxq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const
                    {
                        return vminq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const
                    {
                        return vcgtq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const
                    {
                        return vcltq_s8(value, other.value);
                    }
                    simdutf_really_inline simd8<bool>
                    operator==(const simd8<int8_t> other) const
                    {
                        return vceqq_s8(value, other.value);
                    }

                    template <int N = 1>
                    simdutf_really_inline simd8<int8_t>
                    prev(const simd8<int8_t> prev_chunk) const
                    {
                        return vextq_s8(prev_chunk, *this, 16 - N);
                    }

                    // Perform a lookup assuming no value is larger than 16
                    template <typename L>
                    simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const
                    {
                        return lookup_table.apply_lookup_16_to(*this);
                    }
                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
                        L replace5, L replace6, L replace7, L replace8, L replace9,
                        L replace10, L replace11, L replace12, L replace13, L replace14,
                        L replace15) const
                    {
                        return lookup_16(simd8<L>::repeat_16(
                            replace0, replace1, replace2, replace3, replace4, replace5, replace6,
                            replace7, replace8, replace9, replace10, replace11, replace12,
                            replace13, replace14, replace15));
                    }

                    template <typename T>
                    simdutf_really_inline simd8<int8_t>
                    apply_lookup_16_to(const simd8<T> original) const
                    {
                        return vqtbl1q_s8(*this, simd8<uint8_t>(original));
                    }
                };

                template <typename T>
                struct simd8x64
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
                    static_assert(NUM_CHUNKS == 4,
                        "ARM kernel should use four registers per 64-byte block.");
                    simd8<T> chunks[NUM_CHUNKS];

                    simd8x64(const simd8x64<T>& o) = delete; // no copy allowed
                    simd8x64<T>&
                    operator=(const simd8<T> other)
                        = delete; // no assignment allowed
                    simd8x64() = delete; // no default constructor allowed

                    simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
                        const simd8<T> chunk2, const simd8<T> chunk3)
                        : chunks { chunk0, chunk1, chunk2, chunk3 }
                    {
                    }
                    simdutf_really_inline simd8x64(const T* ptr)
                        : chunks { simd8<T>::load(ptr),
                            simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
                            simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
                            simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
                        this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
                        this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
                    }

                    simdutf_really_inline simd8x64<T>& operator|=(const simd8x64<T>& other)
                    {
                        this->chunks[0] |= other.chunks[0];
                        this->chunks[1] |= other.chunks[1];
                        this->chunks[2] |= other.chunks[2];
                        this->chunks[3] |= other.chunks[3];
                        return *this;
                    }

                    simdutf_really_inline simd8<T> reduce_or() const
                    {
                        return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);
                    }

                    simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }

                    template <endianness endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 1);
                        this->chunks[2].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 2);
                        this->chunks[3].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 3);
                    }

                    simdutf_really_inline void store_ascii_as_utf32(char32_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 1);
                        this->chunks[2].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 2);
                        this->chunks[3].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 3);
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
                        const uint8x16_t bit_mask = simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
                            0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
            #else
                        const uint8x16_t bit_mask = { 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
                            0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80 };
            #endif
                        // Add each of the elements next to each other, successively, to stuff each
                        // 8 byte mask into one.
                        uint8x16_t sum0 = vpaddq_u8(vandq_u8(uint8x16_t(this->chunks[0]), bit_mask),
                            vandq_u8(uint8x16_t(this->chunks[1]), bit_mask));
                        uint8x16_t sum1 = vpaddq_u8(vandq_u8(uint8x16_t(this->chunks[2]), bit_mask),
                            vandq_u8(uint8x16_t(this->chunks[3]), bit_mask));
                        sum0 = vpaddq_u8(sum0, sum1);
                        sum0 = vpaddq_u8(sum0, sum0);
                        return vgetq_lane_u64(vreinterpretq_u64_u8(sum0), 0);
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
                            this->chunks[2] == mask, this->chunks[3] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
                            this->chunks[2] <= mask, this->chunks[3] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);

                        return simd8x64<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
                            (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
                            (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);
                        return simd8x64<bool>(
                            (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
                            (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
                            (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
                            (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
                            this->chunks[2] < mask, this->chunks[3] < mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
                            this->chunks[2] > mask, this->chunks[3] > mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
                            this->chunks[2] >= mask, this->chunks[3] >= mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const
                    {
                        const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
                        return simd8x64<bool>(simd8<uint8_t>(uint8x16_t(this->chunks[0])) >= mask,
                            simd8<uint8_t>(uint8x16_t(this->chunks[1])) >= mask,
                            simd8<uint8_t>(uint8x16_t(this->chunks[2])) >= mask,
                            simd8<uint8_t>(uint8x16_t(this->chunks[3])) >= mask)
                            .to_bitmask();
                    }
                }; // struct simd8x64<T>
                /* begin file src/simdutf/arm64/simd16-inl.h */
                template <typename T>
                struct simd16;

                template <typename T, typename Mask = simd16<bool>>
                struct base_u16
                {
                    uint16x8_t value;
                    /// the size of vector in bytes
                    static const int SIZE = sizeof(value);
                    /// the number of elements of type T a vector can hold
                    static const int ELEMENTS = SIZE / sizeof(T);
                    // Conversion from/to SIMD register
                    simdutf_really_inline base_u16() = default;
                    simdutf_really_inline base_u16(const uint16x8_t _value)
                        : value(_value)
                    {
                    }
                    simdutf_really_inline operator const uint16x8_t&() const
                    {
                        return this->value;
                    }
                    simdutf_really_inline operator uint16x8_t&() { return this->value; }
                    // Bit operations
                    simdutf_really_inline simd16<T> operator|(const simd16<T> other) const
                    {
                        return vorrq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<T> operator&(const simd16<T> other) const
                    {
                        return vandq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<T> operator^(const simd16<T> other) const
                    {
                        return veorq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<T> bit_andnot(const simd16<T> other) const
                    {
                        return vbicq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
                    simdutf_really_inline simd16<T>& operator|=(const simd16<T> other)
                    {
                        auto this_cast = static_cast<simd16<T>*>(this);
                        *this_cast = *this_cast | other;
                        return *this_cast;
                    }
                    simdutf_really_inline simd16<T>& operator&=(const simd16<T> other)
                    {
                        auto this_cast = static_cast<simd16<T>*>(this);
                        *this_cast = *this_cast & other;
                        return *this_cast;
                    }
                    simdutf_really_inline simd16<T>& operator^=(const simd16<T> other)
                    {
                        auto this_cast = static_cast<simd16<T>*>(this);
                        *this_cast = *this_cast ^ other;
                        return *this_cast;
                    }

                    friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
                        const simd16<T> rhs)
                    {
                        return vceqq_u16(lhs, rhs);
                    }

                    template <int N = 1>
                    simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const
                    {
                        return vextq_u18(prev_chunk, *this, 8 - N);
                    }
                };

                template <typename T, typename Mask = simd16<bool>>
                struct base16 : base_u16<T>
                {
                    typedef uint16_t bitmask_t;
                    typedef uint32_t bitmask2_t;

                    simdutf_really_inline base16()
                        : base_u16<T>()
                    {
                    }
                    simdutf_really_inline base16(const uint16x8_t _value)
                        : base_u16<T>(_value)
                    {
                    }
                    template <typename Pointer>
                    simdutf_really_inline base16(const Pointer* ptr)
                        : base16(vld1q_u16(ptr))
                    {
                    }

                    static const int SIZE = sizeof(base_u16<T>::value);
                    void dump() const
                    {
                        uint16_t temp[8];
                        vst1q_u16(temp, *this);
                        printf("[%04x, %04x, %04x, %04x, %04x, %04x, %04x, %04x]\n", temp[0],
                            temp[1], temp[2], temp[3], temp[4], temp[5], temp[6], temp[7]);
                    }
                    template <int N = 1>
                    simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const
                    {
                        return vextq_u18(prev_chunk, *this, 8 - N);
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd16<bool> : base16<bool>
                {
                    static simdutf_really_inline simd16<bool> splat(bool _value)
                    {
                        return vmovq_n_u16(uint16_t(-(!!_value)));
                    }

                    simdutf_really_inline simd16()
                        : base16()
                    {
                    }
                    simdutf_really_inline simd16(const uint16x8_t _value)
                        : base16<bool>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(bool _value)
                        : base16<bool>(splat(_value))
                    {
                    }
                };

                template <typename T>
                struct base16_numeric : base16<T>
                {
                    static simdutf_really_inline simd16<T> splat(T _value)
                    {
                        return vmovq_n_u16(_value);
                    }
                    static simdutf_really_inline simd16<T> zero() { return vdupq_n_u16(0); }
                    static simdutf_really_inline simd16<T> load(const T values[8])
                    {
                        return vld1q_u16(reinterpret_cast<const uint16_t*>(values));
                    }

                    simdutf_really_inline base16_numeric()
                        : base16<T>()
                    {
                    }
                    simdutf_really_inline base16_numeric(const uint16x8_t _value)
                        : base16<T>(_value)
                    {
                    }

                    // Store to array
                    simdutf_really_inline void store(T dst[8]) const
                    {
                        return vst1q_u16(dst, *this);
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd16<T> operator+(const simd16<T> other) const
                    {
                        return vaddq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<T> operator-(const simd16<T> other) const
                    {
                        return vsubq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<T>& operator+=(const simd16<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd16<T>*>(this);
                    }
                    simdutf_really_inline simd16<T>& operator-=(const simd16<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd16<T>*>(this);
                    }
                };

                // Signed code units
                template <>
                struct simd16<int16_t> : base16_numeric<int16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<int16_t>()
                    {
                    }
            #ifndef SIMDUTF_REGULAR_VISUAL_STUDIO
                    simdutf_really_inline simd16(const uint16x8_t _value)
                        : base16_numeric<int16_t>(_value)
                    {
                    }
            #endif
                    simdutf_really_inline simd16(const int16x8_t _value)
                        : base16_numeric<int16_t>(vreinterpretq_u16_s16(_value))
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(int16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const int16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const int16_t*>(values)))
                    {
                    }
                    simdutf_really_inline operator simd16<uint16_t>() const;
                    simdutf_really_inline operator const uint16x8_t&() const
                    {
                        return this->value;
                    }
                    simdutf_really_inline operator const int16x8_t() const
                    {
                        return vreinterpretq_s16_u16(this->value);
                    }

                    simdutf_really_inline int16_t max_val() const
                    {
                        return vmaxvq_s16(vreinterpretq_s16_u16(this->value));
                    }
                    simdutf_really_inline int16_t min_val() const
                    {
                        return vminvq_s16(vreinterpretq_s16_u16(this->value));
                    }
                    // Order-sensitive comparisons
                    simdutf_really_inline simd16<int16_t>
                    max_val(const simd16<int16_t> other) const
                    {
                        return vmaxq_s16(vreinterpretq_s16_u16(this->value),
                            vreinterpretq_s16_u16(other.value));
                    }
                    simdutf_really_inline simd16<int16_t>
                    min_val(const simd16<int16_t> other) const
                    {
                        return vmaxq_s16(vreinterpretq_s16_u16(this->value),
                            vreinterpretq_s16_u16(other.value));
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<int16_t> other) const
                    {
                        return vcgtq_s16(vreinterpretq_s16_u16(this->value),
                            vreinterpretq_s16_u16(other.value));
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<int16_t> other) const
                    {
                        return vcltq_s16(vreinterpretq_s16_u16(this->value),
                            vreinterpretq_s16_u16(other.value));
                    }
                };

                // Unsigned code units
                template <>
                struct simd16<uint16_t> : base16_numeric<uint16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<uint16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const uint16x8_t _value)
                        : base16_numeric<uint16_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(uint16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const uint16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const uint16_t*>(values)))
                    {
                    }

                    simdutf_really_inline int16_t max_val() const { return vmaxvq_u16(*this); }
                    simdutf_really_inline int16_t min_val() const { return vminvq_u16(*this); }
                    // Saturated math
                    simdutf_really_inline simd16<uint16_t>
                    saturating_add(const simd16<uint16_t> other) const
                    {
                        return vqaddq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    saturating_sub(const simd16<uint16_t> other) const
                    {
                        return vqsubq_u16(*this, other);
                    }

                    // Order-specific operations
                    simdutf_really_inline simd16<uint16_t>
                    max_val(const simd16<uint16_t> other) const
                    {
                        return vmaxq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    min_val(const simd16<uint16_t> other) const
                    {
                        return vminq_u16(*this, other);
                    }
                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    gt_bits(const simd16<uint16_t> other) const
                    {
                        return this->saturating_sub(other);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    lt_bits(const simd16<uint16_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<=(const simd16<uint16_t> other) const
                    {
                        return vcleq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>=(const simd16<uint16_t> other) const
                    {
                        return vcgeq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<uint16_t> other) const
                    {
                        return vcgtq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<uint16_t> other) const
                    {
                        return vcltq_u16(*this, other);
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd16<bool> bits_not_set() const
                    {
                        return *this == uint16_t(0);
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shr() const
                    {
                        return simd16<uint16_t>(vshrq_n_u16(*this, N));
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shl() const
                    {
                        return simd16<uint16_t>(vshlq_n_u16(*this, N));
                    }

                    // logical operations
                    simdutf_really_inline simd16<uint16_t>
                    operator|(const simd16<uint16_t> other) const
                    {
                        return vorrq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    operator&(const simd16<uint16_t> other) const
                    {
                        return vandq_u16(*this, other);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    operator^(const simd16<uint16_t> other) const
                    {
                        return veorq_u16(*this, other);
                    }

                    // Pack with the unsigned saturation of two uint16_t code units into single
                    // uint8_t vector
                    static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t>& v0,
                        const simd16<uint16_t>& v1)
                    {
                        return vqmovn_high_u16(vqmovn_u16(v0), v1);
                    }

                    // Change the endianness
                    simdutf_really_inline simd16<uint16_t> swap_bytes() const
                    {
                        return vreinterpretq_u16_u8(vrev16q_u8(vreinterpretq_u8_u16(*this)));
                    }
                    void dump() const
                    {
                        uint16_t temp[8];
                        vst1q_u16(temp, *this);
                        printf("[%04x, %04x, %04x, %04x, %04x, %04x, %04x, %04x]\n", temp[0],
                            temp[1], temp[2], temp[3], temp[4], temp[5], temp[6], temp[7]);
                    }

                    simdutf_really_inline uint32_t sum() const { return vaddlvq_u16(value); }
                };
                simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const
                {
                    return this->value;
                }

                template <typename T>
                struct simd16x32
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
                    static_assert(NUM_CHUNKS == 4,
                        "ARM kernel should use four registers per 64-byte block.");
                    simd16<T> chunks[NUM_CHUNKS];

                    simd16x32(const simd16x32<T>& o) = delete; // no copy allowed
                    simd16x32<T>&
                    operator=(const simd16<T> other)
                        = delete; // no assignment allowed
                    simd16x32() = delete; // no default constructor allowed

                    simdutf_really_inline
                    simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
                        const simd16<T> chunk2, const simd16<T> chunk3)
                        : chunks { chunk0, chunk1, chunk2, chunk3 }
                    {
                    }
                    simdutf_really_inline simd16x32(const T* ptr)
                        : chunks { simd16<T>::load(ptr),
                            simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
                            simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
                            simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
                        this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
                        this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
                    }

                    simdutf_really_inline simd16<T> reduce_or() const
                    {
                        return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);
                    }

                    simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }

                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
                        this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
                        this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
                        this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
                        const uint8x16_t bit_mask = simdutf_make_uint8x16_t(0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
                            0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80);
            #else
                        const uint8x16_t bit_mask = { 0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80,
                            0x01, 0x02, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80 };
            #endif
                        // Add each of the elements next to each other, successively, to stuff each
                        // 8 byte mask into one.
                        uint8x16_t sum0 = vpaddq_u8(
                            vreinterpretq_u8_u16(this->chunks[0] & vreinterpretq_u16_u8(bit_mask)),
                            vreinterpretq_u8_u16(this->chunks[1] & vreinterpretq_u16_u8(bit_mask)));
                        uint8x16_t sum1 = vpaddq_u8(
                            vreinterpretq_u8_u16(this->chunks[2] & vreinterpretq_u16_u8(bit_mask)),
                            vreinterpretq_u8_u16(this->chunks[3] & vreinterpretq_u16_u8(bit_mask)));
                        sum0 = vpaddq_u8(sum0, sum1);
                        sum0 = vpaddq_u8(sum0, sum0);
                        return vgetq_lane_u64(vreinterpretq_u64_u8(sum0), 0);
                    }

                    simdutf_really_inline void swap_bytes()
                    {
                        this->chunks[0] = this->chunks[0].swap_bytes();
                        this->chunks[1] = this->chunks[1].swap_bytes();
                        this->chunks[2] = this->chunks[2].swap_bytes();
                        this->chunks[3] = this->chunks[3].swap_bytes();
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
                            this->chunks[2] == mask, this->chunks[3] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
                            this->chunks[2] <= mask, this->chunks[3] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(low);
                        const simd16<T> mask_high = simd16<T>::splat(high);

                        return simd16x32<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
                            (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
                            (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(low);
                        const simd16<T> mask_high = simd16<T>::splat(high);
                        return simd16x32<bool>(
                            (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
                            (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
                            (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
                            (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
                            this->chunks[2] < mask, this->chunks[3] < mask)
                            .to_bitmask();
                    }

                }; // struct simd16x32<T>
                template <>
                simdutf_really_inline uint64_t simd16x32<uint16_t>::not_in_range(
                    const uint16_t low, const uint16_t high) const
                {
                    const simd16<uint16_t> mask_low = simd16<uint16_t>::splat(low);
                    const simd16<uint16_t> mask_high = simd16<uint16_t>::splat(high);
                    simd16x32<uint16_t> x(simd16<uint16_t>((this->chunks[0] > mask_high) | (this->chunks[0] < mask_low)),
                        simd16<uint16_t>((this->chunks[1] > mask_high) | (this->chunks[1] < mask_low)),
                        simd16<uint16_t>((this->chunks[2] > mask_high) | (this->chunks[2] < mask_low)),
                        simd16<uint16_t>((this->chunks[3] > mask_high) | (this->chunks[3] < mask_low)));
                    return x.to_bitmask();
                }

                simdutf_really_inline simd16<uint16_t> min(const simd16<uint16_t> a,
                    simd16<uint16_t> b)
                {
                    return vminq_u16(a.value, b.value);
                }
                /* end file src/simdutf/arm64/simd16-inl.h */
                /* begin file src/simdutf/arm64/simd32-inl.h */
                template <typename T>
                struct simd32;

                template <>
                struct simd32<uint32_t>
                {
                    static const size_t SIZE = sizeof(uint32x4_t);
                    static const size_t ELEMENTS = SIZE / sizeof(uint32_t);

                    uint32x4_t value;

                    simdutf_really_inline simd32(const uint32x4_t v)
                        : value(v)
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline simd32(const Pointer* ptr)
                        : value(vld1q_u32(reinterpret_cast<const uint32_t*>(ptr)))
                    {
                    }

                    simdutf_really_inline uint64_t sum() const { return vaddvq_u32(value); }

                    simdutf_really_inline simd32<uint32_t> swap_bytes() const
                    {
                        return vreinterpretq_u32_u8(vrev32q_u8(vreinterpretq_u8_u32(value)));
                    }

                    template <int N>
                    simdutf_really_inline simd32<uint32_t> shr() const
                    {
                        return vshrq_n_u32(value, N);
                    }

                    template <int N>
                    simdutf_really_inline simd32<uint32_t> shl() const
                    {
                        return vshlq_n_u32(value, N);
                    }

                    void dump() const
                    {
                        uint32_t temp[4];
                        vst1q_u32(temp, value);
                        printf("[%08x, %08x, %08x, %08x]\n", temp[0], temp[1], temp[2], temp[3]);
                    }

                    // operators
                    simdutf_really_inline simd32& operator+=(const simd32 other)
                    {
                        value = vaddq_u32(value, other.value);
                        return *this;
                    }

                    // static members
                    simdutf_really_inline static simd32<uint32_t> zero()
                    {
                        return vdupq_n_u32(0);
                    }

                    simdutf_really_inline static simd32<uint32_t> splat(uint32_t v)
                    {
                        return vdupq_n_u32(v);
                    }
                };

                //----------------------------------------------------------------------

                template <>
                struct simd32<bool>
                {
                    uint32x4_t value;

                    simdutf_really_inline simd32(const uint32x4_t v)
                        : value(v)
                    {
                    }

                    simdutf_really_inline bool any() const { return vmaxvq_u32(value) != 0; }
                };

                //----------------------------------------------------------------------

                template <typename T>
                simdutf_really_inline simd32<T> operator|(const simd32<T> a,
                    const simd32<T> b)
                {
                    return vorrq_u32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> min(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return vminq_u32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> max(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return vmaxq_u32(a.value, b.value);
                }

                simdutf_really_inline simd32<bool> operator==(const simd32<uint32_t> a,
                    uint32_t b)
                {
                    return vceqq_u32(a.value, vdupq_n_u32(b));
                }

                simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return vandq_u32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> a,
                    uint32_t b)
                {
                    return vandq_u32(a.value, vdupq_n_u32(b));
                }

                simdutf_really_inline simd32<uint32_t> operator|(const simd32<uint32_t> a,
                    uint32_t b)
                {
                    return vorrq_u32(a.value, vdupq_n_u32(b));
                }

                simdutf_really_inline simd32<uint32_t> operator+(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return vaddq_u32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> operator-(const simd32<uint32_t> a,
                    uint32_t b)
                {
                    return vsubq_u32(a.value, vdupq_n_u32(b));
                }

                simdutf_really_inline simd32<bool> operator>=(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return vcgeq_u32(a.value, b.value);
                }

                simdutf_really_inline simd32<bool> operator!(const simd32<bool> v)
                {
                    return vmvnq_u32(v.value);
                }

                simdutf_really_inline simd32<bool> operator>(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return vcgtq_u32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> select(const simd32<bool> cond,
                    const simd32<uint32_t> v_true,
                    const simd32<uint32_t> v_false)
                {
                    return vbslq_u32(cond.value, v_true.value, v_false.value);
                }
                /* end file src/simdutf/arm64/simd32-inl.h */
                /* begin file src/simdutf/arm64/simd64-inl.h */
                template <typename T>
                struct simd64;

                template <>
                struct simd64<uint64_t>
                {
                    uint64x2_t value;

                    simdutf_really_inline simd64(const uint64x2_t v)
                        : value(v)
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline simd64(const Pointer* ptr)
                        : value(vld1q_u64(reinterpret_cast<const uint64_t*>(ptr)))
                    {
                    }

                    simdutf_really_inline uint64_t sum() const { return vaddvq_u64(value); }

                    // operators
                    simdutf_really_inline simd64& operator+=(const simd64 other)
                    {
                        value = vaddq_u64(value, other.value);
                        return *this;
                    }

                    // static members
                    simdutf_really_inline static simd64<uint64_t> zero()
                    {
                        return vdupq_n_u64(0);
                    }

                    simdutf_really_inline static simd64<uint64_t> splat(uint64_t v)
                    {
                        return vdupq_n_u64(v);
                    }
                };
                /* end file src/simdutf/arm64/simd64-inl.h */

                simdutf_really_inline simd64<uint64_t> sum_8bytes(const simd8<uint8_t> v)
                {
                    // We do it as 3 instructions. There might be a faster way.
                    // We hope that these 3 instructions are cheap.
                    uint16x8_t first_sum = vpaddlq_u8(v);
                    uint32x4_t second_sum = vpaddlq_u16(first_sum);
                    return vpaddlq_u32(second_sum);
                }

            } // namespace simd
        } // unnamed namespace
    } // namespace arm64
} // namespace simdutf

        #endif // SIMDUTF_ARM64_SIMD_H
    /* end file src/simdutf/arm64/simd.h */

    /* begin file src/simdutf/arm64/end.h */
    /* end file src/simdutf/arm64/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_ARM64

#endif // SIMDUTF_ARM64_H
/* end file src/simdutf/arm64.h */
/* begin file src/simdutf/icelake.h */
#ifndef SIMDUTF_ICELAKE_H
    #define SIMDUTF_ICELAKE_H

    #ifdef __has_include
  // How do we detect that a compiler supports vbmi2?
        // For sure if the following header is found, we are ok?
        #if __has_include(<avx512vbmi2intrin.h>)
            #define SIMDUTF_COMPILER_SUPPORTS_VBMI2 1
        #endif
    #endif

    #ifdef _MSC_VER
        #if _MSC_VER >= 1930
  // Visual Studio 2022 and up support VBMI2 under x64 even if the header
            // avx512vbmi2intrin.h is not found.
            // Visual Studio 2019 technically supports VBMI2, but the implementation
            // might be unreliable. Search for visualstudio2019icelakeissue in our
            // tests.
            #define SIMDUTF_COMPILER_SUPPORTS_VBMI2 1
        #endif
    #endif

    // We allow icelake on x64 as long as the compiler is known to support VBMI2.
    #ifndef SIMDUTF_IMPLEMENTATION_ICELAKE
        #define SIMDUTF_IMPLEMENTATION_ICELAKE \
            ((SIMDUTF_IS_X86_64) && (SIMDUTF_COMPILER_SUPPORTS_VBMI2))
    #endif

    // To see why  (__BMI__) && (__LZCNT__) are not part of this next line, see
    // https://github.com/simdutf/simdutf/issues/1247
    #if ((SIMDUTF_IMPLEMENTATION_ICELAKE) && (SIMDUTF_IS_X86_64) && (__AVX2__) && (SIMDUTF_HAS_AVX512F && SIMDUTF_HAS_AVX512DQ && SIMDUTF_HAS_AVX512VL && SIMDUTF_HAS_AVX512VBMI2) && (!SIMDUTF_IS_32BITS))
        #define SIMDUTF_CAN_ALWAYS_RUN_ICELAKE 1
    #else
        #define SIMDUTF_CAN_ALWAYS_RUN_ICELAKE 0
    #endif

    #if SIMDUTF_IMPLEMENTATION_ICELAKE
        #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
            #define SIMDUTF_TARGET_ICELAKE
        #else
            #define SIMDUTF_TARGET_ICELAKE                                       \
                SIMDUTF_TARGET_REGION(                                           \
                    "avx512f,avx512dq,avx512cd,avx512bw,avx512vbmi,avx512vbmi2," \
                    "avx512vl,avx2,bmi,bmi2,pclmul,lzcnt,popcnt,avx512vpopcntdq")
        #endif

namespace simdutf
{
    namespace icelake
    {
    } // namespace icelake
} // namespace simdutf

    //
    // These two need to be included outside SIMDUTF_TARGET_REGION
    //
        /* begin file src/simdutf/icelake/intrinsics.h */
        #ifndef SIMDUTF_ICELAKE_INTRINSICS_H
            #define SIMDUTF_ICELAKE_INTRINSICS_H

            #ifdef SIMDUTF_VISUAL_STUDIO
  // under clang within visual studio, this will include <x86intrin.h>
                #include <immintrin.h>
                #include <intrin.h> // visual studio or clang
            #else

                #if SIMDUTF_GCC11ORMORE
// We should not get warnings while including <x86intrin.h> yet we do
// under some versions of GCC.
// If the x86intrin.h header has uninitialized values that are problematic,
// it is a GCC issue, we want to ignore these warnings.
SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
                #endif

                #include <x86intrin.h> // elsewhere

                #if SIMDUTF_GCC11ORMORE
// cancels the suppression of the -Wuninitialized
SIMDUTF_POP_DISABLE_WARNINGS
                #endif

                #ifndef _tzcnt_u64
                    #define _tzcnt_u64(x) __tzcnt_u64(x)
                #endif // _tzcnt_u64
            #endif // SIMDUTF_VISUAL_STUDIO

            #ifdef SIMDUTF_CLANG_VISUAL_STUDIO
                /**
                 * You are not supposed, normally, to include these
                 * headers directly. Instead you should either include intrin.h
                 * or x86intrin.h. However, when compiling with clang
                 * under Windows (i.e., when _MSC_VER is set), these headers
                 * only get included *if* the corresponding features are detected
                 * from macros:
                 * e.g., if __AVX2__ is set... in turn,  we normally set these
                 * macros by compiling against the corresponding architecture
                 * (e.g., arch:AVX2, -mavx2, etc.) which compiles the whole
                 * software with these advanced instructions. In simdutf, we
                 * want to compile the whole program for a generic target,
                 * and only target our specific kernels. As a workaround,
                 * we directly include the needed headers. These headers would
                 * normally guard against such usage, but we carefully included
                 * <x86intrin.h>  (or <intrin.h>) before, so the headers
                 * are fooled.
                 */
                #include <avx2intrin.h>
                #include <avxintrin.h>
                #include <bmi2intrin.h> // for _pext_u64, _pdep_u64
                #include <bmiintrin.h> // for _blsr_u64
                #include <immintrin.h> // for most things (AVX2, AVX512, _popcnt64)
                #include <lzcntintrin.h> // for  __lzcnt64
                #include <smmintrin.h>
                #include <tmmintrin.h>
  // Important: we need the AVX-512 headers:
                #include <avx512bwintrin.h>
                #include <avx512cdintrin.h>
                #include <avx512dqintrin.h>
                #include <avx512fintrin.h>
                #include <avx512vbmi2intrin.h>
                #include <avx512vbmiintrin.h>
                #include <avx512vlbwintrin.h>
                #include <avx512vlintrin.h>
                #include <avx512vpopcntdqintrin.h>
                #include <avx512vpopcntdqvlintrin.h>
  // unfortunately, we may not get _blsr_u64, but, thankfully, clang
                // has it as a macro.
                #ifndef _blsr_u64
  // we roll our own
                    #define _blsr_u64(n) ((n - 1) & n)
                #endif //  _blsr_u64
            #endif // SIMDUTF_CLANG_VISUAL_STUDIO

            #if defined(__GNUC__) && !defined(__clang__)

                #if __GNUC__ == 8
                    #define SIMDUTF_GCC8 1
                #elif __GNUC__ == 9
                    #define SIMDUTF_GCC9 1
                #endif //  __GNUC__ == 8 || __GNUC__ == 9

            #endif // defined(__GNUC__) && !defined(__clang__)

            #if SIMDUTF_GCC8
                #pragma GCC push_options
                #pragma GCC target("avx512f")
/**
 * GCC 8 fails to provide _mm512_set_epi8. We roll our own.
 */
inline __m512i
_mm512_set_epi8(uint8_t a0, uint8_t a1, uint8_t a2, uint8_t a3, uint8_t a4,
    uint8_t a5, uint8_t a6, uint8_t a7, uint8_t a8, uint8_t a9,
    uint8_t a10, uint8_t a11, uint8_t a12, uint8_t a13, uint8_t a14,
    uint8_t a15, uint8_t a16, uint8_t a17, uint8_t a18, uint8_t a19,
    uint8_t a20, uint8_t a21, uint8_t a22, uint8_t a23, uint8_t a24,
    uint8_t a25, uint8_t a26, uint8_t a27, uint8_t a28, uint8_t a29,
    uint8_t a30, uint8_t a31, uint8_t a32, uint8_t a33, uint8_t a34,
    uint8_t a35, uint8_t a36, uint8_t a37, uint8_t a38, uint8_t a39,
    uint8_t a40, uint8_t a41, uint8_t a42, uint8_t a43, uint8_t a44,
    uint8_t a45, uint8_t a46, uint8_t a47, uint8_t a48, uint8_t a49,
    uint8_t a50, uint8_t a51, uint8_t a52, uint8_t a53, uint8_t a54,
    uint8_t a55, uint8_t a56, uint8_t a57, uint8_t a58, uint8_t a59,
    uint8_t a60, uint8_t a61, uint8_t a62, uint8_t a63)
{
    return _mm512_set_epi64(
        uint64_t(a7) + (uint64_t(a6) << 8) + (uint64_t(a5) << 16) + (uint64_t(a4) << 24) + (uint64_t(a3) << 32) + (uint64_t(a2) << 40) + (uint64_t(a1) << 48) + (uint64_t(a0) << 56),
        uint64_t(a15) + (uint64_t(a14) << 8) + (uint64_t(a13) << 16) + (uint64_t(a12) << 24) + (uint64_t(a11) << 32) + (uint64_t(a10) << 40) + (uint64_t(a9) << 48) + (uint64_t(a8) << 56),
        uint64_t(a23) + (uint64_t(a22) << 8) + (uint64_t(a21) << 16) + (uint64_t(a20) << 24) + (uint64_t(a19) << 32) + (uint64_t(a18) << 40) + (uint64_t(a17) << 48) + (uint64_t(a16) << 56),
        uint64_t(a31) + (uint64_t(a30) << 8) + (uint64_t(a29) << 16) + (uint64_t(a28) << 24) + (uint64_t(a27) << 32) + (uint64_t(a26) << 40) + (uint64_t(a25) << 48) + (uint64_t(a24) << 56),
        uint64_t(a39) + (uint64_t(a38) << 8) + (uint64_t(a37) << 16) + (uint64_t(a36) << 24) + (uint64_t(a35) << 32) + (uint64_t(a34) << 40) + (uint64_t(a33) << 48) + (uint64_t(a32) << 56),
        uint64_t(a47) + (uint64_t(a46) << 8) + (uint64_t(a45) << 16) + (uint64_t(a44) << 24) + (uint64_t(a43) << 32) + (uint64_t(a42) << 40) + (uint64_t(a41) << 48) + (uint64_t(a40) << 56),
        uint64_t(a55) + (uint64_t(a54) << 8) + (uint64_t(a53) << 16) + (uint64_t(a52) << 24) + (uint64_t(a51) << 32) + (uint64_t(a50) << 40) + (uint64_t(a49) << 48) + (uint64_t(a48) << 56),
        uint64_t(a63) + (uint64_t(a62) << 8) + (uint64_t(a61) << 16) + (uint64_t(a60) << 24) + (uint64_t(a59) << 32) + (uint64_t(a58) << 40) + (uint64_t(a57) << 48) + (uint64_t(a56) << 56));
}
                #pragma GCC pop_options
            #endif // SIMDUTF_GCC8

        #endif // SIMDUTF_HASWELL_INTRINSICS_H
        /* end file src/simdutf/icelake/intrinsics.h */
        /* begin file src/simdutf/icelake/implementation.h */
        #ifndef SIMDUTF_ICELAKE_IMPLEMENTATION_H
            #define SIMDUTF_ICELAKE_IMPLEMENTATION_H

namespace simdutf
{
    namespace icelake
    {

        namespace
        {
            using namespace simdutf;
        }

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation(
                      "icelake",
                      "Intel AVX512 (AVX-512BW, AVX-512CD, AVX-512VL, AVX-512VBMI2 "
                      "extensions)",
                      internal::instruction_set::AVX2 | internal::instruction_set::BMI1 | internal::instruction_set::BMI2 | internal::instruction_set::AVX512BW | internal::instruction_set::AVX512CD | internal::instruction_set::AVX512VL | internal::instruction_set::AVX512VBMI2 | internal::instruction_set::AVX512VPOPCNTDQ)
            {
            }

            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;

            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;
        };

    } // namespace icelake
} // namespace simdutf

        #endif // SIMDUTF_ICELAKE_IMPLEMENTATION_H
    /* end file src/simdutf/icelake/implementation.h */

    //
    // The rest need to be inside the region
    //
    /* begin file src/simdutf/icelake/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "icelake"
    // #define SIMDUTF_IMPLEMENTATION icelake

        #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
        // nothing needed.
        #else
SIMDUTF_TARGET_ICELAKE
        #endif

        #if SIMDUTF_GCC11ORMORE // workaround for
                                // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
// clang-format off
SIMDUTF_DISABLE_GCC_WARNING(-Wmaybe-uninitialized)
        // clang-format on
        #endif // end of workaround
    /* end file src/simdutf/icelake/begin.h */
    // Declarations
        /* begin file src/simdutf/icelake/bitmanipulation.h */
        #ifndef SIMDUTF_ICELAKE_BITMANIPULATION_H
            #define SIMDUTF_ICELAKE_BITMANIPULATION_H

namespace simdutf
{
    namespace icelake
    {
        namespace
        {

            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
            simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num)
            {
                // note: we do not support legacy 32-bit Windows
                return __popcnt64(input_num); // Visual Studio wants two underscores
            }
            #else
            simdutf_really_inline long long int count_ones(uint64_t input_num)
            {
                return _popcnt64(input_num);
            }
            #endif

            #if SIMDUTF_NEED_TRAILING_ZEROES
            // simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
            //   #if SIMDUTF_REGULAR_VISUAL_STUDIO
            //   return (int)_tzcnt_u64(input_num);
            //   #else  // SIMDUTF_REGULAR_VISUAL_STUDIO
            //   return __builtin_ctzll(input_num);
            //   #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
            // }
            #endif

        } // unnamed namespace
    } // namespace icelake
} // namespace simdutf

        #endif // SIMDUTF_ICELAKE_BITMANIPULATION_H
        /* end file src/simdutf/icelake/bitmanipulation.h */
        /* begin file src/simdutf/icelake/simd.h */
        #ifndef SIMDUTF_ICELAKE_SIMD_H
            #define SIMDUTF_ICELAKE_SIMD_H

namespace simdutf
{
    namespace icelake
    {
        namespace
        {
            namespace simd
            {

                /* begin file src/simdutf/icelake/simd16-inl.h */
                template <typename T>
                struct simd16;

                template <>
                struct simd16<uint16_t>
                {
                    static const size_t SIZE = sizeof(__m512i);
                    static const size_t ELEMENTS = SIZE / sizeof(uint16_t);

                    template <typename Pointer>
                    static simdutf_really_inline simd16<uint16_t> load(const Pointer* ptr)
                    {
                        return simd16<uint16_t>(ptr);
                    }

                    __m512i value;

                    simdutf_really_inline simd16(const __m512i v)
                        : value(v)
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline simd16(const Pointer* ptr)
                        : value(_mm512_loadu_si512(reinterpret_cast<const __m512i*>(ptr)))
                    {
                    }

                    // operators
                    simdutf_really_inline simd16& operator+=(const simd16 other)
                    {
                        value = _mm512_add_epi32(value, other.value);
                        return *this;
                    }

                    simdutf_really_inline simd16& operator-=(const simd16 other)
                    {
                        value = _mm512_sub_epi32(value, other.value);
                        return *this;
                    }

                    // methods
                    simdutf_really_inline simd16 swap_bytes() const
                    {
                        const __m512i byteflip = _mm512_setr_epi64(
                            0x0607040502030001, 0x0e0f0c0d0a0b0809, 0x0607040502030001,
                            0x0e0f0c0d0a0b0809, 0x0607040502030001, 0x0e0f0c0d0a0b0809,
                            0x0607040502030001, 0x0e0f0c0d0a0b0809);

                        return _mm512_shuffle_epi8(value, byteflip);
                    }

                    simdutf_really_inline uint64_t sum() const
                    {
                        const auto lo = _mm512_and_si512(value, _mm512_set1_epi32(0xffff));
                        const auto hi = _mm512_srli_epi32(value, 16);
                        const auto sum32 = _mm512_add_epi32(lo, hi);

                        return _mm512_reduce_add_epi32(sum32);
                    }

                    // static members
                    simdutf_really_inline static simd16<uint16_t> zero()
                    {
                        return _mm512_setzero_si512();
                    }

                    simdutf_really_inline static simd16<uint16_t> splat(uint16_t v)
                    {
                        return _mm512_set1_epi16(v);
                    }
                };

                template <>
                struct simd16<bool>
                {
                    __mmask32 value;

                    simdutf_really_inline simd16(const __mmask32 v)
                        : value(v)
                    {
                    }
                };

                // ------------------------------------------------------------

                simdutf_really_inline simd16<uint16_t> min(const simd16<uint16_t> b,
                    const simd16<uint16_t> a)
                {
                    return _mm512_min_epu16(a.value, b.value);
                }

                simdutf_really_inline simd16<uint16_t> operator&(const simd16<uint16_t> a,
                    uint16_t b)
                {
                    return _mm512_and_si512(a.value, _mm512_set1_epi16(b));
                }

                simdutf_really_inline simd16<uint16_t> operator^(const simd16<uint16_t> a,
                    uint16_t b)
                {
                    return _mm512_xor_si512(a.value, _mm512_set1_epi16(b));
                }

                simdutf_really_inline simd16<uint16_t> operator^(const simd16<uint16_t> a,
                    const simd16<uint16_t> b)
                {
                    return _mm512_xor_si512(a.value, b.value);
                }

                simdutf_really_inline simd16<bool> operator==(const simd16<uint16_t> a,
                    uint16_t b)
                {
                    return _mm512_cmpeq_epi16_mask(a.value, _mm512_set1_epi16(b));
                }
                /* end file src/simdutf/icelake/simd16-inl.h */
                /* begin file src/simdutf/icelake/simd32-inl.h */
                template <typename T>
                struct simd32;

                template <>
                struct simd32<uint32_t>
                {
                    static const size_t SIZE = sizeof(__m512i);
                    static const size_t ELEMENTS = SIZE / sizeof(uint32_t);

                    __m512i value;

                    simdutf_really_inline simd32(const __m512i v)
                        : value(v)
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline simd32(const Pointer* ptr)
                        : value(_mm512_loadu_si512(reinterpret_cast<const __m512i*>(ptr)))
                    {
                    }

                    uint64_t sum() const
                    {
                        const __m512i mask = _mm512_set1_epi64(0xffffffff);
                        const __m512i t0 = _mm512_and_si512(value, mask);
                        const __m512i t1 = _mm512_srli_epi64(value, 32);
                        const __m512i t2 = _mm512_add_epi64(t0, t1);
                        return _mm512_reduce_add_epi64(t2);
                    }

                    // operators
                    simdutf_really_inline simd32& operator+=(const simd32 other)
                    {
                        value = _mm512_add_epi32(value, other.value);
                        return *this;
                    }

                    // static members
                    simdutf_really_inline static simd32<uint32_t> zero()
                    {
                        return _mm512_setzero_si512();
                    }

                    simdutf_really_inline static simd32<uint32_t> splat(uint32_t v)
                    {
                        return _mm512_set1_epi32(v);
                    }
                };

                simdutf_really_inline simd32<uint32_t> min(const simd32<uint32_t> b,
                    const simd32<uint32_t> a)
                {
                    return _mm512_min_epu32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> b,
                    const simd32<uint32_t> a)
                {
                    return _mm512_and_si512(a.value, b.value);
                }
                /* end file src/simdutf/icelake/simd32-inl.h */

            } // namespace simd
        } // unnamed namespace
    } // namespace icelake
} // namespace simdutf

        #endif // SIMDUTF_ICELAKE_SIMD_H
        /* end file src/simdutf/icelake/simd.h */

        /* begin file src/simdutf/icelake/end.h */
        #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
        // nothing needed.
        #else
SIMDUTF_UNTARGET_REGION
        #endif

        #if SIMDUTF_GCC11ORMORE // workaround for
                                // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
SIMDUTF_POP_DISABLE_WARNINGS
        #endif // end of workaround
    /* end file src/simdutf/icelake/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_ICELAKE
#endif // SIMDUTF_ICELAKE_H
/* end file src/simdutf/icelake.h */
/* begin file src/simdutf/haswell.h */
#ifndef SIMDUTF_HASWELL_H
    #define SIMDUTF_HASWELL_H

    #ifdef SIMDUTF_WESTMERE_H
        #error "haswell.h must be included before westmere.h"
    #endif
    #ifdef SIMDUTF_FALLBACK_H
        #error "haswell.h must be included before fallback.h"
    #endif

    // Default Haswell to on if this is x86-64. Even if we are not compiled for it,
    // it could be selected at runtime.
    #ifndef SIMDUTF_IMPLEMENTATION_HASWELL
        //
        // You do not want to restrict it like so: SIMDUTF_IS_X86_64 && __AVX2__
        // because we want to rely on *runtime dispatch*.
        //
        #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
            #define SIMDUTF_IMPLEMENTATION_HASWELL 0
        #else
            #define SIMDUTF_IMPLEMENTATION_HASWELL (SIMDUTF_IS_X86_64)
        #endif

    #endif
    // To see why  (__BMI__) && (__LZCNT__) are not part of this next line, see
    // https://github.com/simdutf/simdutf/issues/1247
    #if ((SIMDUTF_IMPLEMENTATION_HASWELL) && (SIMDUTF_IS_X86_64) && (__AVX2__))
        #define SIMDUTF_CAN_ALWAYS_RUN_HASWELL 1
    #else
        #define SIMDUTF_CAN_ALWAYS_RUN_HASWELL 0
    #endif

    #if SIMDUTF_IMPLEMENTATION_HASWELL

        #define SIMDUTF_TARGET_HASWELL SIMDUTF_TARGET_REGION("avx2,bmi,lzcnt,popcnt")

namespace simdutf
{
    /**
     * Implementation for Haswell (Intel AVX2).
     */
    namespace haswell
    {
    } // namespace haswell
} // namespace simdutf

    //
    // These two need to be included outside SIMDUTF_TARGET_REGION
    //
        /* begin file src/simdutf/haswell/implementation.h */
        #ifndef SIMDUTF_HASWELL_IMPLEMENTATION_H
            #define SIMDUTF_HASWELL_IMPLEMENTATION_H

// The constructor may be executed on any host, so we take care not to use
// SIMDUTF_TARGET_REGION
namespace simdutf
{
    namespace haswell
    {

        using namespace simdutf;

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation("haswell", "Intel/AMD AVX2",
                      internal::instruction_set::AVX2 | internal::instruction_set::BMI1 | internal::instruction_set::BMI2)
            {
            }

            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;

            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;
        };

    } // namespace haswell
} // namespace simdutf

        #endif // SIMDUTF_HASWELL_IMPLEMENTATION_H
        /* end file src/simdutf/haswell/implementation.h */
        /* begin file src/simdutf/haswell/intrinsics.h */
        #ifndef SIMDUTF_HASWELL_INTRINSICS_H
            #define SIMDUTF_HASWELL_INTRINSICS_H

            #ifdef SIMDUTF_VISUAL_STUDIO
  // under clang within visual studio, this will include <x86intrin.h>
                #include <intrin.h> // visual studio or clang
            #else

                #if SIMDUTF_GCC11ORMORE
// We should not get warnings while including <x86intrin.h> yet we do
// under some versions of GCC.
// If the x86intrin.h header has uninitialized values that are problematic,
// it is a GCC issue, we want to ignore these warnings.
SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
                #endif

                #include <x86intrin.h> // elsewhere

                #if SIMDUTF_GCC11ORMORE
// cancels the suppression of the -Wuninitialized
SIMDUTF_POP_DISABLE_WARNINGS
                #endif

            #endif // SIMDUTF_VISUAL_STUDIO

            #ifdef SIMDUTF_CLANG_VISUAL_STUDIO
                /**
                 * You are not supposed, normally, to include these
                 * headers directly. Instead you should either include intrin.h
                 * or x86intrin.h. However, when compiling with clang
                 * under Windows (i.e., when _MSC_VER is set), these headers
                 * only get included *if* the corresponding features are detected
                 * from macros:
                 * e.g., if __AVX2__ is set... in turn,  we normally set these
                 * macros by compiling against the corresponding architecture
                 * (e.g., arch:AVX2, -mavx2, etc.) which compiles the whole
                 * software with these advanced instructions. In simdutf, we
                 * want to compile the whole program for a generic target,
                 * and only target our specific kernels. As a workaround,
                 * we directly include the needed headers. These headers would
                 * normally guard against such usage, but we carefully included
                 * <x86intrin.h>  (or <intrin.h>) before, so the headers
                 * are fooled.
                 */
                #include <avx2intrin.h>
                #include <avxintrin.h>
                #include <bmiintrin.h> // for _blsr_u64
                #include <immintrin.h> // for most things (AVX2, AVX512, _popcnt64)
                #include <lzcntintrin.h> // for  __lzcnt64
                #include <smmintrin.h>
                #include <tmmintrin.h>
  // unfortunately, we may not get _blsr_u64, but, thankfully, clang
                // has it as a macro.
                #ifndef _blsr_u64
  // we roll our own
                    #define _blsr_u64(n) (((n) - 1) & (n))
                #endif //  _blsr_u64
                // Same issue with _blsmsk_u32:
                #ifndef _blsmsk_u32
  // we roll our own
                    #define _blsmsk_u32(n) (((n) - 1) ^ (n))
                #endif //  _blsmsk_u32
            #endif // SIMDUTF_CLANG_VISUAL_STUDIO

        #endif // SIMDUTF_HASWELL_INTRINSICS_H
    /* end file src/simdutf/haswell/intrinsics.h */

    //
    // The rest need to be inside the region
    //
        /* begin file src/simdutf/haswell/begin.h */
        // redefining SIMDUTF_IMPLEMENTATION to "haswell"
        // #define SIMDUTF_IMPLEMENTATION haswell
        #define SIMDUTF_SIMD_HAS_BYTEMASK 1

        #if SIMDUTF_CAN_ALWAYS_RUN_HASWELL
        // nothing needed.
        #else
SIMDUTF_TARGET_HASWELL
        #endif

        #if SIMDUTF_GCC11ORMORE // workaround for
                                // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
// clang-format off
SIMDUTF_DISABLE_GCC_WARNING(-Wmaybe-uninitialized)
        // clang-format on
        #endif // end of workaround
    /* end file src/simdutf/haswell/begin.h */
    // Declarations
        /* begin file src/simdutf/haswell/bitmanipulation.h */
        #ifndef SIMDUTF_HASWELL_BITMANIPULATION_H
            #define SIMDUTF_HASWELL_BITMANIPULATION_H

namespace simdutf
{
    namespace haswell
    {
        namespace
        {

            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
            simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num)
            {
                // note: we do not support legacy 32-bit Windows
                return __popcnt64(input_num); // Visual Studio wants two underscores
            }
            #else
            simdutf_really_inline long long int count_ones(uint64_t input_num)
            {
                return _popcnt64(input_num);
            }
            #endif

            #if SIMDUTF_NEED_TRAILING_ZEROES
            simdutf_really_inline int trailing_zeroes(uint64_t input_num)
            {
                #if SIMDUTF_REGULAR_VISUAL_STUDIO
                return (int)_tzcnt_u64(input_num);
                #else // SIMDUTF_REGULAR_VISUAL_STUDIO
                return __builtin_ctzll(input_num);
                #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
            }
            #endif

            template <typename T>
            bool is_power_of_two(T x) { return (x & (x - 1)) == 0; }

        } // unnamed namespace
    } // namespace haswell
} // namespace simdutf

        #endif // SIMDUTF_HASWELL_BITMANIPULATION_H
        /* end file src/simdutf/haswell/bitmanipulation.h */
        /* begin file src/simdutf/haswell/simd.h */
        #ifndef SIMDUTF_HASWELL_SIMD_H
            #define SIMDUTF_HASWELL_SIMD_H

namespace simdutf
{
    namespace haswell
    {
        namespace
        {
            namespace simd
            {

                // Forward-declared so they can be used by splat and friends.
                template <typename Child>
                struct base
                {
                    __m256i value;

                    // Zero constructor
                    simdutf_really_inline base()
                        : value { __m256i() }
                    {
                    }

                    // Conversion from SIMD register
                    simdutf_really_inline base(const __m256i _value)
                        : value(_value)
                    {
                    }
                    // Conversion to SIMD register
                    simdutf_really_inline operator const __m256i&() const { return this->value; }
                    simdutf_really_inline operator __m256i&() { return this->value; }
                    template <endianness big_endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        __m256i first = _mm256_cvtepu8_epi16(_mm256_castsi256_si128(*this));
                        __m256i second = _mm256_cvtepu8_epi16(_mm256_extractf128_si256(*this, 1));
                        if (big_endian)
                        {
                            const __m256i swap = _mm256_setr_epi8(
                                1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19, 18,
                                21, 20, 23, 22, 25, 24, 27, 26, 29, 28, 31, 30);
                            first = _mm256_shuffle_epi8(first, swap);
                            second = _mm256_shuffle_epi8(second, swap);
                        }
                        _mm256_storeu_si256(reinterpret_cast<__m256i*>(ptr), first);
                        _mm256_storeu_si256(reinterpret_cast<__m256i*>(ptr + 16), second);
                    }
                    simdutf_really_inline void store_ascii_as_utf32(char32_t* ptr) const
                    {
                        _mm256_storeu_si256(reinterpret_cast<__m256i*>(ptr),
                            _mm256_cvtepu8_epi32(_mm256_castsi256_si128(*this)));
                        _mm256_storeu_si256(reinterpret_cast<__m256i*>(ptr + 8),
                            _mm256_cvtepu8_epi32(_mm256_castsi256_si128(
                                _mm256_srli_si256(*this, 8))));
                        _mm256_storeu_si256(
                            reinterpret_cast<__m256i*>(ptr + 16),
                            _mm256_cvtepu8_epi32(_mm256_extractf128_si256(*this, 1)));
                        _mm256_storeu_si256(reinterpret_cast<__m256i*>(ptr + 24),
                            _mm256_cvtepu8_epi32(_mm_srli_si128(
                                _mm256_extractf128_si256(*this, 1), 8)));
                    }
                    // Bit operations
                    simdutf_really_inline Child operator|(const Child other) const
                    {
                        return _mm256_or_si256(*this, other);
                    }
                    simdutf_really_inline Child operator&(const Child other) const
                    {
                        return _mm256_and_si256(*this, other);
                    }
                    simdutf_really_inline Child operator^(const Child other) const
                    {
                        return _mm256_xor_si256(*this, other);
                    }
                    simdutf_really_inline Child bit_andnot(const Child other) const
                    {
                        return _mm256_andnot_si256(other, *this);
                    }
                    simdutf_really_inline Child& operator|=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast | other;
                        return *this_cast;
                    }
                    simdutf_really_inline Child& operator&=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast & other;
                        return *this_cast;
                    }
                    simdutf_really_inline Child& operator^=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast ^ other;
                        return *this_cast;
                    }
                };

                // Forward-declared so they can be used by splat and friends.
                template <typename T>
                struct simd8;

                template <typename T, typename Mask = simd8<bool>>
                struct base8 : base<simd8<T>>
                {
                    typedef uint32_t bitmask_t;
                    typedef uint64_t bitmask2_t;

                    simdutf_really_inline base8()
                        : base<simd8<T>>()
                    {
                    }
                    simdutf_really_inline base8(const __m256i _value)
                        : base<simd8<T>>(_value)
                    {
                    }
                    simdutf_really_inline T first() const
                    {
                        return _mm256_extract_epi8(*this, 0);
                    }
                    simdutf_really_inline T last() const
                    {
                        return _mm256_extract_epi8(*this, 31);
                    }
                    friend simdutf_always_inline Mask operator==(const simd8<T> lhs,
                        const simd8<T> rhs)
                    {
                        return _mm256_cmpeq_epi8(lhs, rhs);
                    }

                    static const int SIZE = sizeof(base<T>::value);

                    template <int N = 1>
                    simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const
                    {
                        return _mm256_alignr_epi8(
                            *this, _mm256_permute2x128_si256(prev_chunk, *this, 0x21), 16 - N);
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd8<bool> : base8<bool>
                {
                    static simdutf_really_inline simd8<bool> splat(bool _value)
                    {
                        return _mm256_set1_epi8(uint8_t(-(!!_value)));
                    }

                    simdutf_really_inline simd8()
                        : base8()
                    {
                    }
                    simdutf_really_inline simd8(const __m256i _value)
                        : base8<bool>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(bool _value)
                        : base8<bool>(splat(_value))
                    {
                    }

                    simdutf_really_inline uint32_t to_bitmask() const
                    {
                        return uint32_t(_mm256_movemask_epi8(*this));
                    }
                    simdutf_really_inline bool any() const
                    {
                        return !_mm256_testz_si256(*this, *this);
                    }
                    simdutf_really_inline bool none() const
                    {
                        return _mm256_testz_si256(*this, *this);
                    }
                    simdutf_really_inline bool all() const
                    {
                        return static_cast<uint32_t>(_mm256_movemask_epi8(*this)) == 0xFFFFFFFF;
                    }
                    simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
                };

                template <typename T>
                struct base8_numeric : base8<T>
                {
                    static simdutf_really_inline simd8<T> splat(T _value)
                    {
                        return _mm256_set1_epi8(_value);
                    }
                    static simdutf_really_inline simd8<T> zero()
                    {
                        return _mm256_setzero_si256();
                    }
                    static simdutf_really_inline simd8<T> load(const T values[32])
                    {
                        return _mm256_loadu_si256(reinterpret_cast<const __m256i*>(values));
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
                        T v5, T v6, T v7, T v8, T v9,
                        T v10, T v11, T v12, T v13,
                        T v14, T v15)
                    {
                        return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
                            v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                            v12, v13, v14, v15);
                    }

                    simdutf_really_inline base8_numeric()
                        : base8<T>()
                    {
                    }
                    simdutf_really_inline base8_numeric(const __m256i _value)
                        : base8<T>(_value)
                    {
                    }

                    // Store to array
                    simdutf_really_inline void store(T dst[32]) const
                    {
                        return _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst), *this);
                    }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd8<T> operator+(const simd8<T> other) const
                    {
                        return _mm256_add_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<T> operator-(const simd8<T> other) const
                    {
                        return _mm256_sub_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<T>& operator+=(const simd8<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd8<T>*>(this);
                    }
                    simdutf_really_inline simd8<T>& operator-=(const simd8<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd8<T>*>(this);
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }

                    // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
                    // for out of range values)
                    template <typename L>
                    simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const
                    {
                        return _mm256_shuffle_epi8(lookup_table, *this);
                    }

                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
                        L replace5, L replace6, L replace7, L replace8, L replace9,
                        L replace10, L replace11, L replace12, L replace13, L replace14,
                        L replace15) const
                    {
                        return lookup_16(simd8<L>::repeat_16(
                            replace0, replace1, replace2, replace3, replace4, replace5, replace6,
                            replace7, replace8, replace9, replace10, replace11, replace12,
                            replace13, replace14, replace15));
                    }
                };

                // Signed bytes
                template <>
                struct simd8<int8_t> : base8_numeric<int8_t>
                {
                    simdutf_really_inline simd8()
                        : base8_numeric<int8_t>()
                    {
                    }
                    simdutf_really_inline simd8(const __m256i _value)
                        : base8_numeric<int8_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd8(int8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const int8_t values[32])
                        : simd8(load(values))
                    {
                    }
                    simdutf_really_inline operator simd8<uint8_t>() const;
                    // Member-by-member initialization
                    simdutf_really_inline
                    simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
                        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15, int8_t v16, int8_t v17,
                        int8_t v18, int8_t v19, int8_t v20, int8_t v21, int8_t v22, int8_t v23,
                        int8_t v24, int8_t v25, int8_t v26, int8_t v27, int8_t v28, int8_t v29,
                        int8_t v30, int8_t v31)
                        : simd8(_mm256_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                              v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
                              v22, v23, v24, v25, v26, v27, v28, v29, v30,
                              v31))
                    {
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<int8_t>
                    repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
                        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                    {
                        return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
                            v10, v11, v12, v13, v14, v15);
                    }
                    simdutf_really_inline bool is_ascii() const
                    {
                        return _mm256_movemask_epi8(*this) == 0;
                    }
                    // Order-sensitive comparisons
                    simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const
                    {
                        return _mm256_max_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const
                    {
                        return _mm256_min_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const
                    {
                        return _mm256_cmpgt_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const
                    {
                        return _mm256_cmpgt_epi8(other, *this);
                    }
                };

                // Unsigned bytes
                template <>
                struct simd8<uint8_t> : base8_numeric<uint8_t>
                {
                    simdutf_really_inline simd8()
                        : base8_numeric<uint8_t>()
                    {
                    }
                    simdutf_really_inline simd8(const __m256i _value)
                        : base8_numeric<uint8_t>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(uint8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const uint8_t values[32])
                        : simd8(load(values))
                    {
                    }
                    // Member-by-member initialization
                    simdutf_really_inline
                    simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
                        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
                        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15,
                        uint8_t v16, uint8_t v17, uint8_t v18, uint8_t v19, uint8_t v20,
                        uint8_t v21, uint8_t v22, uint8_t v23, uint8_t v24, uint8_t v25,
                        uint8_t v26, uint8_t v27, uint8_t v28, uint8_t v29, uint8_t v30,
                        uint8_t v31)
                        : simd8(_mm256_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                              v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,
                              v22, v23, v24, v25, v26, v27, v28, v29, v30,
                              v31))
                    {
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<uint8_t>
                    repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
                        uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
                        uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
                        uint8_t v15)
                    {
                        return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
                            v10, v11, v12, v13, v14, v15);
                    }

                    // Saturated math
                    simdutf_really_inline simd8<uint8_t>
                    saturating_add(const simd8<uint8_t> other) const
                    {
                        return _mm256_adds_epu8(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    saturating_sub(const simd8<uint8_t> other) const
                    {
                        return _mm256_subs_epu8(*this, other);
                    }

                    // Order-specific operations
                    simdutf_really_inline simd8<uint8_t>
                    max_val(const simd8<uint8_t> other) const
                    {
                        return _mm256_max_epu8(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    min_val(const simd8<uint8_t> other) const
                    {
                        return _mm256_min_epu8(other, *this);
                    }
                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd8<uint8_t>
                    gt_bits(const simd8<uint8_t> other) const
                    {
                        return this->saturating_sub(other);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd8<uint8_t>
                    lt_bits(const simd8<uint8_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }
                    simdutf_really_inline simd8<bool>
                    operator<=(const simd8<uint8_t> other) const
                    {
                        return other.max_val(*this) == other;
                    }
                    simdutf_really_inline simd8<bool>
                    operator>=(const simd8<uint8_t> other) const
                    {
                        return other.min_val(*this) == other;
                    }
                    simdutf_really_inline simd8<bool>
                    operator>(const simd8<uint8_t> other) const
                    {
                        return this->gt_bits(other).any_bits_set();
                    }
                    simdutf_really_inline simd8<bool>
                    operator<(const simd8<uint8_t> other) const
                    {
                        return this->lt_bits(other).any_bits_set();
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd8<bool> bits_not_set() const
                    {
                        return *this == uint8_t(0);
                    }
                    simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const
                    {
                        return (*this & bits).bits_not_set();
                    }
                    simdutf_really_inline simd8<bool> any_bits_set() const
                    {
                        return ~this->bits_not_set();
                    }
                    simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const
                    {
                        return ~this->bits_not_set(bits);
                    }
                    simdutf_really_inline bool is_ascii() const
                    {
                        return _mm256_movemask_epi8(*this) == 0;
                    }
                    simdutf_really_inline bool bits_not_set_anywhere() const
                    {
                        return _mm256_testz_si256(*this, *this);
                    }
                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        return !bits_not_set_anywhere();
                    }
                    simdutf_really_inline bool bits_not_set_anywhere(simd8<uint8_t> bits) const
                    {
                        return _mm256_testz_si256(*this, bits);
                    }
                    simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const
                    {
                        return !bits_not_set_anywhere(bits);
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shr() const
                    {
                        return simd8<uint8_t>(_mm256_srli_epi16(*this, N)) & uint8_t(0xFFu >> N);
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shl() const
                    {
                        return simd8<uint8_t>(_mm256_slli_epi16(*this, N)) & uint8_t(0xFFu << N);
                    }
                    // Get one of the bits and make a bitmask out of it.
                    // e.g. value.get_bit<7>() gets the high bit
                    template <int N>
                    simdutf_really_inline int get_bit() const
                    {
                        return _mm256_movemask_epi8(_mm256_slli_epi16(*this, 7 - N));
                    }

                    simdutf_really_inline uint64_t sum_bytes() const
                    {
                        const auto tmp = _mm256_sad_epu8(value, _mm256_setzero_si256());

                        return _mm256_extract_epi64(tmp, 0) + _mm256_extract_epi64(tmp, 1) + _mm256_extract_epi64(tmp, 2) + _mm256_extract_epi64(tmp, 3);
                    }
                };
                simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const
                {
                    return this->value;
                }

                template <typename T>
                struct simd8x64
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
                    static_assert(NUM_CHUNKS == 2,
                        "Haswell kernel should use two registers per 64-byte block.");
                    simd8<T> chunks[NUM_CHUNKS];

                    simd8x64(const simd8x64<T>& o) = delete; // no copy allowed
                    simd8x64<T>&
                    operator=(const simd8<T> other)
                        = delete; // no assignment allowed
                    simd8x64() = delete; // no default constructor allowed

                    simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1)
                        : chunks { chunk0, chunk1 }
                    {
                    }
                    simdutf_really_inline simd8x64(const T* ptr)
                        : chunks { simd8<T>::load(ptr),
                            simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
                        uint64_t r_hi = this->chunks[1].to_bitmask();
                        return r_lo | (r_hi << 32);
                    }

                    simdutf_really_inline simd8x64<T>& operator|=(const simd8x64<T>& other)
                    {
                        this->chunks[0] |= other.chunks[0];
                        this->chunks[1] |= other.chunks[1];
                        return *this;
                    }

                    simdutf_really_inline simd8<T> reduce_or() const
                    {
                        return this->chunks[0] | this->chunks[1];
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->reduce_or().is_ascii();
                    }

                    template <endianness endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 1);
                    }

                    simdutf_really_inline void store_ascii_as_utf32(char32_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
                    }

                    simdutf_really_inline simd8x64<T> bit_or(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<T>(this->chunks[0] | mask, this->chunks[1] | mask);
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t eq(const simd8x64<uint8_t>& other) const
                    {
                        return simd8x64<bool>(this->chunks[0] == other.chunks[0],
                            this->chunks[1] == other.chunks[1])
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);

                        return simd8x64<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);
                        return simd8x64<bool>(
                            (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
                            (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t gt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const
                    {
                        const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
                        return simd8x64<bool>((simd8<uint8_t>(__m256i(this->chunks[0])) >= mask),
                            (simd8<uint8_t>(__m256i(this->chunks[1])) >= mask))
                            .to_bitmask();
                    }
                }; // struct simd8x64<T>

            /* begin file src/simdutf/haswell/simd16-inl.h */
            #ifdef __GNUC__
                #if __GNUC__ < 8
                    #define _mm256_set_m128i(xmm1, xmm2)                        \
                        _mm256_permute2f128_si256(_mm256_castsi128_si256(xmm1), \
                            _mm256_castsi128_si256(xmm2), 2)
                    #define _mm256_setr_m128i(xmm2, xmm1)                       \
                        _mm256_permute2f128_si256(_mm256_castsi128_si256(xmm1), \
                            _mm256_castsi128_si256(xmm2), 2)
                #endif
            #endif

                template <typename T>
                struct simd16;

                template <typename T, typename Mask = simd16<bool>>
                struct base16 : base<simd16<T>>
                {
                    using bitmask_type = uint32_t;

                    simdutf_really_inline base16()
                        : base<simd16<T>>()
                    {
                    }
                    simdutf_really_inline base16(const __m256i _value)
                        : base<simd16<T>>(_value)
                    {
                    }
                    template <typename Pointer>
                    simdutf_really_inline base16(const Pointer* ptr)
                        : base16(_mm256_loadu_si256(reinterpret_cast<const __m256i*>(ptr)))
                    {
                    }
                    friend simdutf_always_inline Mask operator==(const simd16<T> lhs,
                        const simd16<T> rhs)
                    {
                        return _mm256_cmpeq_epi16(lhs, rhs);
                    }

                    /// the size of vector in bytes
                    static const int SIZE = sizeof(base<simd16<T>>::value);

                    /// the number of elements of type T a vector can hold
                    static const int ELEMENTS = SIZE / sizeof(T);

                    template <int N = 1>
                    simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const
                    {
                        return _mm256_alignr_epi8(*this, prev_chunk, 16 - N);
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd16<bool> : base16<bool>
                {
                    static simdutf_really_inline simd16<bool> splat(bool _value)
                    {
                        return _mm256_set1_epi16(uint16_t(-(!!_value)));
                    }

                    simdutf_really_inline simd16()
                        : base16()
                    {
                    }
                    simdutf_really_inline simd16(const __m256i _value)
                        : base16<bool>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(bool _value)
                        : base16<bool>(splat(_value))
                    {
                    }

                    simdutf_really_inline bitmask_type to_bitmask() const
                    {
                        return _mm256_movemask_epi8(*this);
                    }
                    simdutf_really_inline bool any() const
                    {
                        return !_mm256_testz_si256(*this, *this);
                    }
                    simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
                };

                template <typename T>
                struct base16_numeric : base16<T>
                {
                    static simdutf_really_inline simd16<T> splat(T _value)
                    {
                        return _mm256_set1_epi16(_value);
                    }
                    static simdutf_really_inline simd16<T> zero()
                    {
                        return _mm256_setzero_si256();
                    }
                    static simdutf_really_inline simd16<T> load(const T values[8])
                    {
                        return _mm256_loadu_si256(reinterpret_cast<const __m256i*>(values));
                    }

                    simdutf_really_inline base16_numeric()
                        : base16<T>()
                    {
                    }
                    simdutf_really_inline base16_numeric(const __m256i _value)
                        : base16<T>(_value)
                    {
                    }

                    // Store to array
                    simdutf_really_inline void store(T dst[8]) const
                    {
                        return _mm256_storeu_si256(reinterpret_cast<__m256i*>(dst), *this);
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFFFu; }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd16<T> operator+(const simd16<T> other) const
                    {
                        return _mm256_add_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<T> operator-(const simd16<T> other) const
                    {
                        return _mm256_sub_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<T>& operator+=(const simd16<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd16<T>*>(this);
                    }
                    simdutf_really_inline simd16<T>& operator-=(const simd16<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd16<T>*>(this);
                    }
                };

                // Signed code units
                template <>
                struct simd16<int16_t> : base16_numeric<int16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<int16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const __m256i _value)
                        : base16_numeric<int16_t>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(int16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const int16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const int16_t*>(values)))
                    {
                    }
                    // Order-sensitive comparisons
                    simdutf_really_inline simd16<int16_t>
                    max_val(const simd16<int16_t> other) const
                    {
                        return _mm256_max_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<int16_t>
                    min_val(const simd16<int16_t> other) const
                    {
                        return _mm256_min_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<int16_t> other) const
                    {
                        return _mm256_cmpgt_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<int16_t> other) const
                    {
                        return _mm256_cmpgt_epi16(other, *this);
                    }
                };

                // Unsigned code units
                template <>
                struct simd16<uint16_t> : base16_numeric<uint16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<uint16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const __m256i _value)
                        : base16_numeric<uint16_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(uint16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const uint16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const uint16_t*>(values)))
                    {
                    }
                    simdutf_really_inline simd16(const simd16<bool> bm)
                        : simd16(bm.value)
                    {
                    }

                    // Saturated math
                    simdutf_really_inline simd16<uint16_t>
                    saturating_add(const simd16<uint16_t> other) const
                    {
                        return _mm256_adds_epu16(*this, other);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    saturating_sub(const simd16<uint16_t> other) const
                    {
                        return _mm256_subs_epu16(*this, other);
                    }

                    // Order-specific operations
                    simdutf_really_inline simd16<uint16_t>
                    max_val(const simd16<uint16_t> other) const
                    {
                        return _mm256_max_epu16(*this, other);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    min_val(const simd16<uint16_t> other) const
                    {
                        return _mm256_min_epu16(*this, other);
                    }
                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    gt_bits(const simd16<uint16_t> other) const
                    {
                        return this->saturating_sub(other);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    lt_bits(const simd16<uint16_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<=(const simd16<uint16_t> other) const
                    {
                        return other.max_val(*this) == other;
                    }
                    simdutf_really_inline simd16<bool>
                    operator>=(const simd16<uint16_t> other) const
                    {
                        return other.min_val(*this) == other;
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<uint16_t> other) const
                    {
                        return this->gt_bits(other).any_bits_set();
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<uint16_t> other) const
                    {
                        return this->gt_bits(other).any_bits_set();
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd16<bool> bits_not_set() const
                    {
                        return *this == uint16_t(0);
                    }
                    simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const
                    {
                        return (*this & bits).bits_not_set();
                    }
                    simdutf_really_inline simd16<bool> any_bits_set() const
                    {
                        return ~this->bits_not_set();
                    }
                    simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const
                    {
                        return ~this->bits_not_set(bits);
                    }

                    simdutf_really_inline bool bits_not_set_anywhere() const
                    {
                        return _mm256_testz_si256(*this, *this);
                    }
                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        return !bits_not_set_anywhere();
                    }
                    simdutf_really_inline bool
                    bits_not_set_anywhere(simd16<uint16_t> bits) const
                    {
                        return _mm256_testz_si256(*this, bits);
                    }
                    simdutf_really_inline bool
                    any_bits_set_anywhere(simd16<uint16_t> bits) const
                    {
                        return !bits_not_set_anywhere(bits);
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shr() const
                    {
                        return simd16<uint16_t>(_mm256_srli_epi16(*this, N));
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shl() const
                    {
                        return simd16<uint16_t>(_mm256_slli_epi16(*this, N));
                    }
                    // Get one of the bits and make a bitmask out of it.
                    // e.g. value.get_bit<7>() gets the high bit
                    template <int N>
                    simdutf_really_inline int get_bit() const
                    {
                        return _mm256_movemask_epi8(_mm256_slli_epi16(*this, 15 - N));
                    }

                    // Change the endianness
                    simdutf_really_inline simd16<uint16_t> swap_bytes() const
                    {
                        const __m256i swap = _mm256_setr_epi8(
                            1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19, 18,
                            21, 20, 23, 22, 25, 24, 27, 26, 29, 28, 31, 30);
                        return _mm256_shuffle_epi8(*this, swap);
                    }

                    // Pack with the unsigned saturation of two uint16_t code units into single
                    // uint8_t vector
                    static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t>& v0,
                        const simd16<uint16_t>& v1)
                    {
                        // Note: the AVX2 variant of pack operates on 128-bit lanes, thus
                        //       we have to shuffle lanes in order to produce bytes in the
                        //       correct order.

                        // get the 0th lanes
                        const __m128i lo_0 = _mm256_extracti128_si256(v0, 0);
                        const __m128i lo_1 = _mm256_extracti128_si256(v1, 0);

                        // get the 1st lanes
                        const __m128i hi_0 = _mm256_extracti128_si256(v0, 1);
                        const __m128i hi_1 = _mm256_extracti128_si256(v1, 1);

                        // build new vectors (shuffle lanes)
                        const __m256i t0 = _mm256_set_m128i(lo_1, lo_0);
                        const __m256i t1 = _mm256_set_m128i(hi_1, hi_0);

                        // pack code units in linear order from v0 and v1
                        return _mm256_packus_epi16(t0, t1);
                    }

                    simdutf_really_inline uint64_t sum() const
                    {
                        const auto lo_u16 = _mm256_and_si256(value, _mm256_set1_epi32(0x0000ffff));
                        const auto hi_u16 = _mm256_srli_epi32(value, 16);
                        const auto sum_u32 = _mm256_add_epi32(lo_u16, hi_u16);

                        const auto lo_u32 = _mm256_and_si256(sum_u32, _mm256_set1_epi64x(0xffffffff));
                        const auto hi_u32 = _mm256_srli_epi64(sum_u32, 32);
                        const auto sum_u64 = _mm256_add_epi64(lo_u32, hi_u32);

                        return uint64_t(_mm256_extract_epi64(sum_u64, 0)) + uint64_t(_mm256_extract_epi64(sum_u64, 1)) + uint64_t(_mm256_extract_epi64(sum_u64, 2)) + uint64_t(_mm256_extract_epi64(sum_u64, 3));
                    }
                };

                template <typename T>
                struct simd16x32
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
                    static_assert(NUM_CHUNKS == 2,
                        "Haswell kernel should use two registers per 64-byte block.");
                    simd16<T> chunks[NUM_CHUNKS];

                    simd16x32(const simd16x32<T>& o) = delete; // no copy allowed
                    simd16x32<T>&
                    operator=(const simd16<T> other)
                        = delete; // no assignment allowed
                    simd16x32() = delete; // no default constructor allowed

                    simdutf_really_inline simd16x32(const simd16<T> chunk0,
                        const simd16<T> chunk1)
                        : chunks { chunk0, chunk1 }
                    {
                    }
                    simdutf_really_inline simd16x32(const T* ptr)
                        : chunks { simd16<T>::load(ptr),
                            simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
                        uint64_t r_hi = this->chunks[1].to_bitmask();
                        return r_lo | (r_hi << 32);
                    }

                    simdutf_really_inline simd16<T> reduce_or() const
                    {
                        return this->chunks[0] | this->chunks[1];
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->reduce_or().is_ascii();
                    }

                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
                        this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>));
                    }

                    simdutf_really_inline simd16x32<T> bit_or(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<T>(this->chunks[0] | mask, this->chunks[1] | mask);
                    }

                    simdutf_really_inline void swap_bytes()
                    {
                        this->chunks[0] = this->chunks[0].swap_bytes();
                        this->chunks[1] = this->chunks[1].swap_bytes();
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t eq(const simd16x32<uint16_t>& other) const
                    {
                        return simd16x32<bool>(this->chunks[0] == other.chunks[0],
                            this->chunks[1] == other.chunks[1])
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(low);
                        const simd16<T> mask_high = simd16<T>::splat(high);

                        return simd16x32<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
                        const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
                        return simd16x32<bool>(
                            (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
                            (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
                            .to_bitmask();
                    }
                }; // struct simd16x32<T>

                simd16<uint16_t> min(const simd16<uint16_t> a, simd16<uint16_t> b)
                {
                    return _mm256_min_epu16(a.value, b.value);
                }
                /* end file src/simdutf/haswell/simd16-inl.h */
                /* begin file src/simdutf/haswell/simd32-inl.h */
                template <typename T>
                struct simd32;

                template <>
                struct simd32<uint32_t>
                {
                    static const size_t SIZE = sizeof(__m256i);
                    static const size_t ELEMENTS = SIZE / sizeof(uint32_t);

                    __m256i value;

                    simdutf_really_inline simd32(const __m256i v)
                        : value(v)
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline simd32(const Pointer* ptr)
                        : value(_mm256_loadu_si256(reinterpret_cast<const __m256i*>(ptr)))
                    {
                    }

                    simdutf_really_inline uint64_t sum() const
                    {
                        const __m256i mask = _mm256_set1_epi64x(0xffffffff);
                        const __m256i t0 = _mm256_and_si256(value, mask);
                        const __m256i t1 = _mm256_srli_epi64(value, 32);
                        const __m256i t2 = _mm256_add_epi64(t0, t1);

                        return uint64_t(_mm256_extract_epi64(t2, 0)) + uint64_t(_mm256_extract_epi64(t2, 1)) + uint64_t(_mm256_extract_epi64(t2, 2)) + uint64_t(_mm256_extract_epi64(t2, 3));
                    }

                    simdutf_really_inline simd32<uint32_t> swap_bytes() const
                    {
                        const __m256i shuffle = _mm256_setr_epi8(3, 2, 1, 0, 7, 6, 5, 4, 8, 9, 10, 11, 15, 14, 13, 12,
                            3, 2, 1, 0, 7, 6, 5, 4, 8, 9, 10, 11, 15, 14, 13, 12);

                        return _mm256_shuffle_epi8(value, shuffle);
                    }

                    // operators
                    simdutf_really_inline simd32& operator+=(const simd32 other)
                    {
                        value = _mm256_add_epi32(value, other.value);
                        return *this;
                    }

                    // static members
                    simdutf_really_inline static simd32<uint32_t> zero()
                    {
                        return _mm256_setzero_si256();
                    }

                    simdutf_really_inline static simd32<uint32_t> splat(uint32_t v)
                    {
                        return _mm256_set1_epi32(v);
                    }
                };

                //----------------------------------------------------------------------

                template <>
                struct simd32<bool>
                {
                    // static const size_t SIZE = sizeof(__m128i);
                    // static const size_t ELEMENTS = SIZE / sizeof(uint32_t);

                    __m256i value;

                    simdutf_really_inline simd32(const __m256i v)
                        : value(v)
                    {
                    }

                    simdutf_really_inline bool any() const
                    {
                        return _mm256_movemask_epi8(value) != 0;
                    }
                };

                //----------------------------------------------------------------------

                template <typename T>
                simdutf_really_inline simd32<T> operator|(const simd32<T> a,
                    const simd32<T> b)
                {
                    return _mm256_or_si256(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> min(const simd32<uint32_t> b,
                    const simd32<uint32_t> a)
                {
                    return _mm256_min_epu32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> max(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return _mm256_max_epu32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> b,
                    const simd32<uint32_t> a)
                {
                    return _mm256_and_si256(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> operator+(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return _mm256_add_epi32(a.value, b.value);
                }

                simdutf_really_inline simd32<bool> operator>=(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return _mm256_cmpeq_epi32(_mm256_max_epu32(a.value, b.value), a.value);
                }

                simdutf_really_inline simd32<bool> operator!(const simd32<bool> v)
                {
                    return _mm256_xor_si256(v.value, _mm256_set1_epi8(-1));
                }

                simdutf_really_inline simd32<bool> operator>(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return !(b >= a);
                }
                /* end file src/simdutf/haswell/simd32-inl.h */
                /* begin file src/simdutf/haswell/simd64-inl.h */
                template <typename T>
                struct simd64;

                template <>
                struct simd64<uint64_t>
                {
                    // static const size_t SIZE = sizeof(__m256i);
                    // static const size_t ELEMENTS = SIZE / sizeof(uint64_t);

                    __m256i value;

                    simdutf_really_inline simd64(const __m256i v)
                        : value(v)
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline simd64(const Pointer* ptr)
                        : value(_mm256_loadu_si256(reinterpret_cast<const __m256i*>(ptr)))
                    {
                    }

                    simdutf_really_inline uint64_t sum() const
                    {
                        return _mm256_extract_epi64(value, 0) + _mm256_extract_epi64(value, 1) + _mm256_extract_epi64(value, 2) + _mm256_extract_epi64(value, 3);
                    }

                    // operators
                    simdutf_really_inline simd64& operator+=(const simd64 other)
                    {
                        value = _mm256_add_epi64(value, other.value);
                        return *this;
                    }

                    // static members
                    simdutf_really_inline static simd64<uint64_t> zero()
                    {
                        return _mm256_setzero_si256();
                    }

                    simdutf_really_inline static simd64<uint64_t> splat(uint64_t v)
                    {
                        return _mm256_set1_epi64x(v);
                    }
                };
                /* end file src/simdutf/haswell/simd64-inl.h */

                simdutf_really_inline simd64<uint64_t> sum_8bytes(const simd8<uint8_t> v)
                {
                    return _mm256_sad_epu8(v.value, simd8<uint8_t>::zero());
                }

            } // namespace simd

        } // unnamed namespace
    } // namespace haswell
} // namespace simdutf

        #endif // SIMDUTF_HASWELL_SIMD_H
        /* end file src/simdutf/haswell/simd.h */

        /* begin file src/simdutf/haswell/end.h */
        #if SIMDUTF_CAN_ALWAYS_RUN_HASWELL
        // nothing needed.
        #else
SIMDUTF_UNTARGET_REGION
        #endif

        #undef SIMDUTF_SIMD_HAS_BYTEMASK

        #if SIMDUTF_GCC11ORMORE // workaround for
                                // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
SIMDUTF_POP_DISABLE_WARNINGS
        #endif // end of workaround
    /* end file src/simdutf/haswell/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_HASWELL
#endif // SIMDUTF_HASWELL_COMMON_H
/* end file src/simdutf/haswell.h */
/* begin file src/simdutf/westmere.h */
#ifndef SIMDUTF_WESTMERE_H
    #define SIMDUTF_WESTMERE_H

    #ifdef SIMDUTF_FALLBACK_H
        #error "westmere.h must be included before fallback.h"
    #endif

    // Default Westmere to on if this is x86-64, unless we'll always select Haswell.
    #ifndef SIMDUTF_IMPLEMENTATION_WESTMERE
        //
        // You do not want to set it to (SIMDUTF_IS_X86_64 &&
        // !SIMDUTF_REQUIRES_HASWELL) because you want to rely on runtime dispatch!
        //
        #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE || SIMDUTF_CAN_ALWAYS_RUN_HASWELL
            #define SIMDUTF_IMPLEMENTATION_WESTMERE 0
        #else
            #define SIMDUTF_IMPLEMENTATION_WESTMERE (SIMDUTF_IS_X86_64)
        #endif

    #endif

    #if (SIMDUTF_IMPLEMENTATION_WESTMERE && SIMDUTF_IS_X86_64 && __SSE4_2__)
        #define SIMDUTF_CAN_ALWAYS_RUN_WESTMERE 1
    #else
        #define SIMDUTF_CAN_ALWAYS_RUN_WESTMERE 0
    #endif

    #if SIMDUTF_IMPLEMENTATION_WESTMERE

        #define SIMDUTF_TARGET_WESTMERE SIMDUTF_TARGET_REGION("sse4.2,popcnt")

namespace simdutf
{
    /**
     * Implementation for Westmere (Intel SSE4.2).
     */
    namespace westmere
    {
    } // namespace westmere
} // namespace simdutf

    //
    // These two need to be included outside SIMDUTF_TARGET_REGION
    //
        /* begin file src/simdutf/westmere/implementation.h */
        #ifndef SIMDUTF_WESTMERE_IMPLEMENTATION_H
            #define SIMDUTF_WESTMERE_IMPLEMENTATION_H

// The constructor may be executed on any host, so we take care not to use
// SIMDUTF_TARGET_REGION
namespace simdutf
{
    namespace westmere
    {

        namespace
        {
            using namespace simdutf;
        }

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation("westmere", "Intel/AMD SSE4.2",
                      internal::instruction_set::SSE42)
            {
            }

            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;

            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;
        };

    } // namespace westmere
} // namespace simdutf

        #endif // SIMDUTF_WESTMERE_IMPLEMENTATION_H
        /* end file src/simdutf/westmere/implementation.h */
        /* begin file src/simdutf/westmere/intrinsics.h */
        #ifndef SIMDUTF_WESTMERE_INTRINSICS_H
            #define SIMDUTF_WESTMERE_INTRINSICS_H

            #ifdef SIMDUTF_VISUAL_STUDIO
  // under clang within visual studio, this will include <x86intrin.h>
                #include <intrin.h> // visual studio or clang
            #else

                #if SIMDUTF_GCC11ORMORE
// We should not get warnings while including <x86intrin.h> yet we do
// under some versions of GCC.
// If the x86intrin.h header has uninitialized values that are problematic,
// it is a GCC issue, we want to ignore these warnings.
SIMDUTF_DISABLE_GCC_WARNING(-Wuninitialized)
                #endif

                #include <x86intrin.h> // elsewhere

                #if SIMDUTF_GCC11ORMORE
// cancels the suppression of the -Wuninitialized
SIMDUTF_POP_DISABLE_WARNINGS
                #endif

            #endif // SIMDUTF_VISUAL_STUDIO

            #ifdef SIMDUTF_CLANG_VISUAL_STUDIO
                /**
                 * You are not supposed, normally, to include these
                 * headers directly. Instead you should either include intrin.h
                 * or x86intrin.h. However, when compiling with clang
                 * under Windows (i.e., when _MSC_VER is set), these headers
                 * only get included *if* the corresponding features are detected
                 * from macros:
                 */
                #include <smmintrin.h> // for _mm_alignr_epi8
            #endif

        #endif // SIMDUTF_WESTMERE_INTRINSICS_H
    /* end file src/simdutf/westmere/intrinsics.h */

    //
    // The rest need to be inside the region
    //
        /* begin file src/simdutf/westmere/begin.h */
        // redefining SIMDUTF_IMPLEMENTATION to "westmere"
        // #define SIMDUTF_IMPLEMENTATION westmere
        #define SIMDUTF_SIMD_HAS_BYTEMASK 1

        #if SIMDUTF_CAN_ALWAYS_RUN_WESTMERE
        // nothing needed.
        #else
SIMDUTF_TARGET_WESTMERE
        #endif
    /* end file src/simdutf/westmere/begin.h */

    // Declarations
        /* begin file src/simdutf/westmere/bitmanipulation.h */
        #ifndef SIMDUTF_WESTMERE_BITMANIPULATION_H
            #define SIMDUTF_WESTMERE_BITMANIPULATION_H

namespace simdutf
{
    namespace westmere
    {
        namespace
        {

            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
            simdutf_really_inline unsigned __int64 count_ones(uint64_t input_num)
            {
                // note: we do not support legacy 32-bit Windows
                return __popcnt64(input_num); // Visual Studio wants two underscores
            }
            #else
            simdutf_really_inline long long int count_ones(uint64_t input_num)
            {
                return _popcnt64(input_num);
            }
            #endif

            #if SIMDUTF_NEED_TRAILING_ZEROES
            simdutf_really_inline int trailing_zeroes(uint64_t input_num)
            {
                #if SIMDUTF_REGULAR_VISUAL_STUDIO
                unsigned long ret;
                _BitScanForward64(&ret, input_num);
                return (int)ret;
                #else // SIMDUTF_REGULAR_VISUAL_STUDIO
                return __builtin_ctzll(input_num);
                #endif // SIMDUTF_REGULAR_VISUAL_STUDIO
            }
            #endif

            template <typename T>
            bool is_power_of_two(T x) { return (x & (x - 1)) == 0; }

        } // unnamed namespace
    } // namespace westmere
} // namespace simdutf

        #endif // SIMDUTF_WESTMERE_BITMANIPULATION_H
        /* end file src/simdutf/westmere/bitmanipulation.h */
        /* begin file src/simdutf/westmere/simd.h */
        #ifndef SIMDUTF_WESTMERE_SIMD_H
            #define SIMDUTF_WESTMERE_SIMD_H

namespace simdutf
{
    namespace westmere
    {
        namespace
        {
            namespace simd
            {

                template <typename Child>
                struct base
                {
                    __m128i value;

                    // Zero constructor
                    simdutf_really_inline base()
                        : value { __m128i() }
                    {
                    }

                    // Conversion from SIMD register
                    simdutf_really_inline base(const __m128i _value)
                        : value(_value)
                    {
                    }
                    // Conversion to SIMD register
                    simdutf_really_inline operator const __m128i&() const { return this->value; }
                    simdutf_really_inline operator __m128i&() { return this->value; }
                    template <endianness big_endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* p) const
                    {
                        __m128i first = _mm_cvtepu8_epi16(*this);
                        __m128i second = _mm_cvtepu8_epi16(_mm_srli_si128(*this, 8));
                        if (big_endian)
                        {
                            const __m128i swap = _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
                            first = _mm_shuffle_epi8(first, swap);
                            second = _mm_shuffle_epi8(second, swap);
                        }
                        _mm_storeu_si128(reinterpret_cast<__m128i*>(p), first);
                        _mm_storeu_si128(reinterpret_cast<__m128i*>(p + 8), second);
                    }
                    simdutf_really_inline void store_ascii_as_utf32(char32_t* p) const
                    {
                        _mm_storeu_si128(reinterpret_cast<__m128i*>(p), _mm_cvtepu8_epi32(*this));
                        _mm_storeu_si128(reinterpret_cast<__m128i*>(p + 4),
                            _mm_cvtepu8_epi32(_mm_srli_si128(*this, 4)));
                        _mm_storeu_si128(reinterpret_cast<__m128i*>(p + 8),
                            _mm_cvtepu8_epi32(_mm_srli_si128(*this, 8)));
                        _mm_storeu_si128(reinterpret_cast<__m128i*>(p + 12),
                            _mm_cvtepu8_epi32(_mm_srli_si128(*this, 12)));
                    }
                    // Bit operations
                    simdutf_really_inline Child operator|(const Child other) const
                    {
                        return _mm_or_si128(*this, other);
                    }
                    simdutf_really_inline Child operator&(const Child other) const
                    {
                        return _mm_and_si128(*this, other);
                    }
                    simdutf_really_inline Child operator^(const Child other) const
                    {
                        return _mm_xor_si128(*this, other);
                    }
                    simdutf_really_inline Child bit_andnot(const Child other) const
                    {
                        return _mm_andnot_si128(other, *this);
                    }
                    simdutf_really_inline Child& operator|=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast | other;
                        return *this_cast;
                    }
                    simdutf_really_inline Child& operator&=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast & other;
                        return *this_cast;
                    }
                    simdutf_really_inline Child& operator^=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast ^ other;
                        return *this_cast;
                    }
                };

                // Forward-declared so they can be used by splat and friends.
                template <typename T>
                struct simd8;

                template <typename T, typename Mask = simd8<bool>>
                struct base8 : base<simd8<T>>
                {
                    typedef uint16_t bitmask_t;
                    typedef uint32_t bitmask2_t;

                    simdutf_really_inline T first() const { return _mm_extract_epi8(*this, 0); }
                    simdutf_really_inline T last() const { return _mm_extract_epi8(*this, 15); }
                    simdutf_really_inline base8()
                        : base<simd8<T>>()
                    {
                    }
                    simdutf_really_inline base8(const __m128i _value)
                        : base<simd8<T>>(_value)
                    {
                    }

                    friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
                        const simd8<T> rhs)
                    {
                        return _mm_cmpeq_epi8(lhs, rhs);
                    }

                    static const int SIZE = sizeof(base<simd8<T>>::value);

                    template <int N = 1>
                    simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const
                    {
                        return _mm_alignr_epi8(*this, prev_chunk, 16 - N);
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd8<bool> : base8<bool>
                {
                    static simdutf_really_inline simd8<bool> splat(bool _value)
                    {
                        return _mm_set1_epi8(uint8_t(-(!!_value)));
                    }

                    simdutf_really_inline simd8()
                        : base8()
                    {
                    }
                    simdutf_really_inline simd8(const __m128i _value)
                        : base8<bool>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(bool _value)
                        : base8<bool>(splat(_value))
                    {
                    }

                    simdutf_really_inline int to_bitmask() const
                    {
                        return _mm_movemask_epi8(*this);
                    }
                    simdutf_really_inline bool any() const
                    {
                        return !_mm_testz_si128(*this, *this);
                    }
                    simdutf_really_inline bool none() const
                    {
                        return _mm_testz_si128(*this, *this);
                    }
                    simdutf_really_inline bool all() const
                    {
                        return _mm_movemask_epi8(*this) == 0xFFFF;
                    }
                    simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
                };

                template <typename T>
                struct base8_numeric : base8<T>
                {
                    static simdutf_really_inline simd8<T> splat(T _value)
                    {
                        return _mm_set1_epi8(_value);
                    }
                    static simdutf_really_inline simd8<T> zero() { return _mm_setzero_si128(); }
                    static simdutf_really_inline simd8<T> load(const T values[16])
                    {
                        return _mm_loadu_si128(reinterpret_cast<const __m128i*>(values));
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
                        T v5, T v6, T v7, T v8, T v9,
                        T v10, T v11, T v12, T v13,
                        T v14, T v15)
                    {
                        return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
                            v14, v15);
                    }

                    simdutf_really_inline base8_numeric()
                        : base8<T>()
                    {
                    }
                    simdutf_really_inline base8_numeric(const __m128i _value)
                        : base8<T>(_value)
                    {
                    }

                    // Store to array
                    simdutf_really_inline void store(T dst[16]) const
                    {
                        return _mm_storeu_si128(reinterpret_cast<__m128i*>(dst), *this);
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd8<T> operator+(const simd8<T> other) const
                    {
                        return _mm_add_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<T> operator-(const simd8<T> other) const
                    {
                        return _mm_sub_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<T>& operator+=(const simd8<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd8<T>*>(this);
                    }
                    simdutf_really_inline simd8<T>& operator-=(const simd8<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd8<T>*>(this);
                    }

                    // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
                    // for out of range values)
                    template <typename L>
                    simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const
                    {
                        return _mm_shuffle_epi8(lookup_table, *this);
                    }

                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
                        L replace5, L replace6, L replace7, L replace8, L replace9,
                        L replace10, L replace11, L replace12, L replace13, L replace14,
                        L replace15) const
                    {
                        return lookup_16(simd8<L>::repeat_16(
                            replace0, replace1, replace2, replace3, replace4, replace5, replace6,
                            replace7, replace8, replace9, replace10, replace11, replace12,
                            replace13, replace14, replace15));
                    }
                };

                // Signed bytes
                template <>
                struct simd8<int8_t> : base8_numeric<int8_t>
                {
                    simdutf_really_inline simd8()
                        : base8_numeric<int8_t>()
                    {
                    }
                    simdutf_really_inline simd8(const __m128i _value)
                        : base8_numeric<int8_t>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(int8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const int8_t* values)
                        : simd8(load(values))
                    {
                    }
                    // Member-by-member initialization
                    simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
                        int8_t v4, int8_t v5, int8_t v6, int8_t v7,
                        int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                        : simd8(_mm_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                              v12, v13, v14, v15))
                    {
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<int8_t>
                    repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
                        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                    {
                        return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15);
                    }
                    simdutf_really_inline operator simd8<uint8_t>() const;
                    simdutf_really_inline bool is_ascii() const
                    {
                        return _mm_movemask_epi8(*this) == 0;
                    }

                    // Order-sensitive comparisons
                    simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const
                    {
                        return _mm_max_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const
                    {
                        return _mm_min_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const
                    {
                        return _mm_cmpgt_epi8(*this, other);
                    }
                    simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const
                    {
                        return _mm_cmpgt_epi8(other, *this);
                    }
                };

                // Unsigned bytes
                template <>
                struct simd8<uint8_t> : base8_numeric<uint8_t>
                {
                    simdutf_really_inline simd8()
                        : base8_numeric<uint8_t>()
                    {
                    }
                    simdutf_really_inline simd8(const __m128i _value)
                        : base8_numeric<uint8_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd8(uint8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const uint8_t* values)
                        : simd8(load(values))
                    {
                    }
                    // Member-by-member initialization
                    simdutf_really_inline
                    simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
                        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
                        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
                        : simd8(_mm_setr_epi8(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                              v12, v13, v14, v15))
                    {
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<uint8_t>
                    repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
                        uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
                        uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
                        uint8_t v15)
                    {
                        return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15);
                    }

                    // Saturated math
                    simdutf_really_inline simd8<uint8_t>
                    saturating_add(const simd8<uint8_t> other) const
                    {
                        return _mm_adds_epu8(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    saturating_sub(const simd8<uint8_t> other) const
                    {
                        return _mm_subs_epu8(*this, other);
                    }

                    // Order-specific operations
                    simdutf_really_inline simd8<uint8_t>
                    max_val(const simd8<uint8_t> other) const
                    {
                        return _mm_max_epu8(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    min_val(const simd8<uint8_t> other) const
                    {
                        return _mm_min_epu8(*this, other);
                    }
                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd8<uint8_t>
                    gt_bits(const simd8<uint8_t> other) const
                    {
                        return this->saturating_sub(other);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd8<uint8_t>
                    lt_bits(const simd8<uint8_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }
                    simdutf_really_inline simd8<bool>
                    operator<=(const simd8<uint8_t> other) const
                    {
                        return other.max_val(*this) == other;
                    }
                    simdutf_really_inline simd8<bool>
                    operator>=(const simd8<uint8_t> other) const
                    {
                        return other.min_val(*this) == other;
                    }
                    simdutf_really_inline simd8<bool>
                    operator>(const simd8<uint8_t> other) const
                    {
                        return this->gt_bits(other).any_bits_set();
                    }
                    simdutf_really_inline simd8<bool>
                    operator<(const simd8<uint8_t> other) const
                    {
                        return this->gt_bits(other).any_bits_set();
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd8<bool> bits_not_set() const
                    {
                        return *this == uint8_t(0);
                    }
                    simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const
                    {
                        return (*this & bits).bits_not_set();
                    }
                    simdutf_really_inline simd8<bool> any_bits_set() const
                    {
                        return ~this->bits_not_set();
                    }
                    simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const
                    {
                        return ~this->bits_not_set(bits);
                    }
                    simdutf_really_inline bool is_ascii() const
                    {
                        return _mm_movemask_epi8(*this) == 0;
                    }

                    simdutf_really_inline bool bits_not_set_anywhere() const
                    {
                        return _mm_testz_si128(*this, *this);
                    }
                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        return !bits_not_set_anywhere();
                    }
                    simdutf_really_inline bool bits_not_set_anywhere(simd8<uint8_t> bits) const
                    {
                        return _mm_testz_si128(*this, bits);
                    }
                    simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const
                    {
                        return !bits_not_set_anywhere(bits);
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shr() const
                    {
                        return simd8<uint8_t>(_mm_srli_epi16(*this, N)) & uint8_t(0xFFu >> N);
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shl() const
                    {
                        return simd8<uint8_t>(_mm_slli_epi16(*this, N)) & uint8_t(0xFFu << N);
                    }
                    // Get one of the bits and make a bitmask out of it.
                    // e.g. value.get_bit<7>() gets the high bit
                    template <int N>
                    simdutf_really_inline int get_bit() const
                    {
                        return _mm_movemask_epi8(_mm_slli_epi16(*this, 7 - N));
                    }

                    simdutf_really_inline uint64_t sum_bytes() const
                    {
                        const auto tmp = _mm_sad_epu8(value, _mm_setzero_si128());
                        return _mm_extract_epi64(tmp, 0) + _mm_extract_epi64(tmp, 1);
                    }
                };

                simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const
                {
                    return this->value;
                }

                template <typename T>
                struct simd8x64
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
                    static_assert(NUM_CHUNKS == 4,
                        "Westmere kernel should use four registers per 64-byte block.");
                    simd8<T> chunks[NUM_CHUNKS];

                    simd8x64(const simd8x64<T>& o) = delete; // no copy allowed
                    simd8x64<T>&
                    operator=(const simd8<T> other)
                        = delete; // no assignment allowed
                    simd8x64() = delete; // no default constructor allowed

                    simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
                        const simd8<T> chunk2, const simd8<T> chunk3)
                        : chunks { chunk0, chunk1, chunk2, chunk3 }
                    {
                    }
                    simdutf_really_inline simd8x64(const T* ptr)
                        : chunks { simd8<T>::load(ptr),
                            simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
                            simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
                            simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
                        this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
                        this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
                    }

                    simdutf_really_inline simd8x64<T>& operator|=(const simd8x64<T>& other)
                    {
                        this->chunks[0] |= other.chunks[0];
                        this->chunks[1] |= other.chunks[1];
                        this->chunks[2] |= other.chunks[2];
                        this->chunks[3] |= other.chunks[3];
                        return *this;
                    }

                    simdutf_really_inline simd8<T> reduce_or() const
                    {
                        return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->reduce_or().is_ascii();
                    }

                    template <endianness endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 1);
                        this->chunks[2].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 2);
                        this->chunks[3].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 3);
                    }

                    simdutf_really_inline void store_ascii_as_utf32(char32_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
                        this->chunks[2].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 2);
                        this->chunks[3].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 3);
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
                        uint64_t r1 = this->chunks[1].to_bitmask();
                        uint64_t r2 = this->chunks[2].to_bitmask();
                        uint64_t r3 = this->chunks[3].to_bitmask();
                        return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
                            this->chunks[2] == mask, this->chunks[3] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t eq(const simd8x64<uint8_t>& other) const
                    {
                        return simd8x64<bool>(this->chunks[0] == other.chunks[0],
                            this->chunks[1] == other.chunks[1],
                            this->chunks[2] == other.chunks[2],
                            this->chunks[3] == other.chunks[3])
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
                            this->chunks[2] <= mask, this->chunks[3] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);

                        return simd8x64<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
                            (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
                            (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low - 1);
                        const simd8<T> mask_high = simd8<T>::splat(high + 1);
                        return simd8x64<bool>(
                            (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
                            (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low),
                            (this->chunks[2] >= mask_high) | (this->chunks[2] <= mask_low),
                            (this->chunks[3] >= mask_high) | (this->chunks[3] <= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
                            this->chunks[2] < mask, this->chunks[3] < mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t gt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
                            this->chunks[2] > mask, this->chunks[3] > mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
                            this->chunks[2] >= mask, this->chunks[3] >= mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const
                    {
                        const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
                        return simd8x64<bool>(simd8<uint8_t>(__m128i(this->chunks[0])) >= mask,
                            simd8<uint8_t>(__m128i(this->chunks[1])) >= mask,
                            simd8<uint8_t>(__m128i(this->chunks[2])) >= mask,
                            simd8<uint8_t>(__m128i(this->chunks[3])) >= mask)
                            .to_bitmask();
                    }
                }; // struct simd8x64<T>

                /* begin file src/simdutf/westmere/simd16-inl.h */
                template <typename T>
                struct simd16;

                template <typename T, typename Mask = simd16<bool>>
                struct base16 : base<simd16<T>>
                {
                    typedef uint16_t bitmask_t;
                    typedef uint32_t bitmask2_t;

                    simdutf_really_inline base16()
                        : base<simd16<T>>()
                    {
                    }
                    simdutf_really_inline base16(const __m128i _value)
                        : base<simd16<T>>(_value)
                    {
                    }
                    template <typename Pointer>
                    simdutf_really_inline base16(const Pointer* ptr)
                        : base16(_mm_loadu_si128(reinterpret_cast<const __m128i*>(ptr)))
                    {
                    }

                    friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
                        const simd16<T> rhs)
                    {
                        return _mm_cmpeq_epi16(lhs, rhs);
                    }

                    /// the size of vector in bytes
                    static const int SIZE = sizeof(base<simd16<T>>::value);

                    /// the number of elements of type T a vector can hold
                    static const int ELEMENTS = SIZE / sizeof(T);

                    template <int N = 1>
                    simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const
                    {
                        return _mm_alignr_epi8(*this, prev_chunk, 16 - N);
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd16<bool> : base16<bool>
                {
                    static simdutf_really_inline simd16<bool> splat(bool _value)
                    {
                        return _mm_set1_epi16(uint16_t(-(!!_value)));
                    }

                    simdutf_really_inline simd16()
                        : base16()
                    {
                    }
                    simdutf_really_inline simd16(const __m128i _value)
                        : base16<bool>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(bool _value)
                        : base16<bool>(splat(_value))
                    {
                    }

                    simdutf_really_inline int to_bitmask() const
                    {
                        return _mm_movemask_epi8(*this);
                    }
                    simdutf_really_inline bool any() const
                    {
                        return !_mm_testz_si128(*this, *this);
                    }
                    simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
                };

                template <typename T>
                struct base16_numeric : base16<T>
                {
                    static simdutf_really_inline simd16<T> splat(T _value)
                    {
                        return _mm_set1_epi16(_value);
                    }
                    static simdutf_really_inline simd16<T> zero() { return _mm_setzero_si128(); }
                    static simdutf_really_inline simd16<T> load(const T values[8])
                    {
                        return _mm_loadu_si128(reinterpret_cast<const __m128i*>(values));
                    }

                    simdutf_really_inline base16_numeric()
                        : base16<T>()
                    {
                    }
                    simdutf_really_inline base16_numeric(const __m128i _value)
                        : base16<T>(_value)
                    {
                    }

                    // Store to array
                    simdutf_really_inline void store(T dst[8]) const
                    {
                        return _mm_storeu_si128(reinterpret_cast<__m128i*>(dst), *this);
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd16<T> operator+(const simd16<T> other) const
                    {
                        return _mm_add_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<T> operator-(const simd16<T> other) const
                    {
                        return _mm_sub_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<T>& operator+=(const simd16<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd16<T>*>(this);
                    }
                    simdutf_really_inline simd16<T>& operator-=(const simd16<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd16<T>*>(this);
                    }
                };

                // Signed code units
                template <>
                struct simd16<int16_t> : base16_numeric<int16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<int16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const __m128i _value)
                        : base16_numeric<int16_t>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(int16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const int16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const int16_t*>(values)))
                    {
                    }
                    // Member-by-member initialization
                    simdutf_really_inline simd16(int16_t v0, int16_t v1, int16_t v2, int16_t v3,
                        int16_t v4, int16_t v5, int16_t v6, int16_t v7)
                        : simd16(_mm_setr_epi16(v0, v1, v2, v3, v4, v5, v6, v7))
                    {
                    }
                    simdutf_really_inline operator simd16<uint16_t>() const;

                    // Order-sensitive comparisons
                    simdutf_really_inline simd16<int16_t>
                    max_val(const simd16<int16_t> other) const
                    {
                        return _mm_max_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<int16_t>
                    min_val(const simd16<int16_t> other) const
                    {
                        return _mm_min_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<int16_t> other) const
                    {
                        return _mm_cmpgt_epi16(*this, other);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<int16_t> other) const
                    {
                        return _mm_cmpgt_epi16(other, *this);
                    }
                };

                // Unsigned code units
                template <>
                struct simd16<uint16_t> : base16_numeric<uint16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<uint16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const __m128i _value)
                        : base16_numeric<uint16_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(uint16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const uint16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const uint16_t*>(values)))
                    {
                    }
                    simdutf_really_inline simd16(const simd16<bool> bm)
                        : simd16(bm.value)
                    {
                    }
                    // Member-by-member initialization
                    simdutf_really_inline simd16(uint16_t v0, uint16_t v1, uint16_t v2,
                        uint16_t v3, uint16_t v4, uint16_t v5,
                        uint16_t v6, uint16_t v7)
                        : simd16(_mm_setr_epi16(v0, v1, v2, v3, v4, v5, v6, v7))
                    {
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd16<uint16_t>
                    repeat_16(uint16_t v0, uint16_t v1, uint16_t v2, uint16_t v3, uint16_t v4,
                        uint16_t v5, uint16_t v6, uint16_t v7)
                    {
                        return simd16<uint16_t>(v0, v1, v2, v3, v4, v5, v6, v7);
                    }

                    // Saturated math
                    simdutf_really_inline simd16<uint16_t>
                    saturating_add(const simd16<uint16_t> other) const
                    {
                        return _mm_adds_epu16(*this, other);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    saturating_sub(const simd16<uint16_t> other) const
                    {
                        return _mm_subs_epu16(*this, other);
                    }

                    // Order-specific operations
                    simdutf_really_inline simd16<uint16_t>
                    max_val(const simd16<uint16_t> other) const
                    {
                        return _mm_max_epu16(*this, other);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    min_val(const simd16<uint16_t> other) const
                    {
                        return _mm_min_epu16(*this, other);
                    }
                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    gt_bits(const simd16<uint16_t> other) const
                    {
                        return this->saturating_sub(other);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    lt_bits(const simd16<uint16_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<=(const simd16<uint16_t> other) const
                    {
                        return other.max_val(*this) == other;
                    }
                    simdutf_really_inline simd16<bool>
                    operator>=(const simd16<uint16_t> other) const
                    {
                        return other.min_val(*this) == other;
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<uint16_t> other) const
                    {
                        return this->gt_bits(other).any_bits_set();
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<uint16_t> other) const
                    {
                        return this->gt_bits(other).any_bits_set();
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd16<bool> bits_not_set() const
                    {
                        return *this == uint16_t(0);
                    }
                    simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const
                    {
                        return (*this & bits).bits_not_set();
                    }
                    simdutf_really_inline simd16<bool> any_bits_set() const
                    {
                        return ~this->bits_not_set();
                    }
                    simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const
                    {
                        return ~this->bits_not_set(bits);
                    }

                    simdutf_really_inline bool bits_not_set_anywhere() const
                    {
                        return _mm_testz_si128(*this, *this);
                    }
                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        return !bits_not_set_anywhere();
                    }
                    simdutf_really_inline bool
                    bits_not_set_anywhere(simd16<uint16_t> bits) const
                    {
                        return _mm_testz_si128(*this, bits);
                    }
                    simdutf_really_inline bool
                    any_bits_set_anywhere(simd16<uint16_t> bits) const
                    {
                        return !bits_not_set_anywhere(bits);
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shr() const
                    {
                        return simd16<uint16_t>(_mm_srli_epi16(*this, N));
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shl() const
                    {
                        return simd16<uint16_t>(_mm_slli_epi16(*this, N));
                    }
                    // Get one of the bits and make a bitmask out of it.
                    // e.g. value.get_bit<7>() gets the high bit
                    template <int N>
                    simdutf_really_inline int get_bit() const
                    {
                        return _mm_movemask_epi8(_mm_slli_epi16(*this, 7 - N));
                    }

                    // Change the endianness
                    simdutf_really_inline simd16<uint16_t> swap_bytes() const
                    {
                        const __m128i swap = _mm_setr_epi8(1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14);
                        return _mm_shuffle_epi8(*this, swap);
                    }

                    // Pack with the unsigned saturation of two uint16_t code units into single
                    // uint8_t vector
                    static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t>& v0,
                        const simd16<uint16_t>& v1)
                    {
                        return _mm_packus_epi16(v0, v1);
                    }

                    simdutf_really_inline uint64_t sum() const
                    {
                        const auto lo_u16 = _mm_and_si128(value, _mm_set1_epi32(0x0000ffff));
                        const auto hi_u16 = _mm_srli_epi32(value, 16);
                        const auto sum_u32 = _mm_add_epi32(lo_u16, hi_u16);

                        const auto lo_u32 = _mm_and_si128(sum_u32, _mm_set1_epi64x(0xffffffff));
                        const auto hi_u32 = _mm_srli_epi64(sum_u32, 32);
                        const auto sum_u64 = _mm_add_epi64(lo_u32, hi_u32);

                        return uint64_t(_mm_extract_epi64(sum_u64, 0)) + uint64_t(_mm_extract_epi64(sum_u64, 1));
                    }
                };

                simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const
                {
                    return this->value;
                }

                template <typename T>
                struct simd16x32
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
                    static_assert(NUM_CHUNKS == 4,
                        "Westmere kernel should use four registers per 64-byte block.");
                    simd16<T> chunks[NUM_CHUNKS];

                    simd16x32(const simd16x32<T>& o) = delete; // no copy allowed
                    simd16x32<T>&
                    operator=(const simd16<T> other)
                        = delete; // no assignment allowed
                    simd16x32() = delete; // no default constructor allowed

                    simdutf_really_inline
                    simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
                        const simd16<T> chunk2, const simd16<T> chunk3)
                        : chunks { chunk0, chunk1, chunk2, chunk3 }
                    {
                    }
                    simdutf_really_inline simd16x32(const T* ptr)
                        : chunks { simd16<T>::load(ptr),
                            simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
                            simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
                            simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
                        this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
                        this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
                    }

                    simdutf_really_inline simd16<T> reduce_or() const
                    {
                        return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->reduce_or().is_ascii();
                    }

                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
                        this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
                        this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
                        this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
                        uint64_t r1 = this->chunks[1].to_bitmask();
                        uint64_t r2 = this->chunks[2].to_bitmask();
                        uint64_t r3 = this->chunks[3].to_bitmask();
                        return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
                    }

                    simdutf_really_inline void swap_bytes()
                    {
                        this->chunks[0] = this->chunks[0].swap_bytes();
                        this->chunks[1] = this->chunks[1].swap_bytes();
                        this->chunks[2] = this->chunks[2].swap_bytes();
                        this->chunks[3] = this->chunks[3].swap_bytes();
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
                            this->chunks[2] == mask, this->chunks[3] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t eq(const simd16x32<uint16_t>& other) const
                    {
                        return simd16x32<bool>(this->chunks[0] == other.chunks[0],
                            this->chunks[1] == other.chunks[1],
                            this->chunks[2] == other.chunks[2],
                            this->chunks[3] == other.chunks[3])
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
                            this->chunks[2] <= mask, this->chunks[3] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(low);
                        const simd16<T> mask_high = simd16<T>::splat(high);

                        return simd16x32<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
                            (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
                            (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
                        const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
                        return simd16x32<bool>(
                            (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
                            (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low),
                            (this->chunks[2] >= mask_high) | (this->chunks[2] <= mask_low),
                            (this->chunks[3] >= mask_high) | (this->chunks[3] <= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
                            this->chunks[2] < mask, this->chunks[3] < mask)
                            .to_bitmask();
                    }
                }; // struct simd16x32<T>

                simd16<uint16_t> min(const simd16<uint16_t> a, simd16<uint16_t> b)
                {
                    return _mm_min_epu16(a.value, b.value);
                }
                /* end file src/simdutf/westmere/simd16-inl.h */
                /* begin file src/simdutf/westmere/simd32-inl.h */
                template <typename T>
                struct simd32;

                template <>
                struct simd32<uint32_t>
                {
                    static const size_t SIZE = sizeof(__m128i);
                    static const size_t ELEMENTS = SIZE / sizeof(uint32_t);

                    __m128i value;

                    simdutf_really_inline simd32(const __m128i v)
                        : value(v)
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline simd32(const Pointer* ptr)
                        : value(_mm_loadu_si128(reinterpret_cast<const __m128i*>(ptr)))
                    {
                    }

                    simdutf_really_inline uint64_t sum() const
                    {
                        return uint64_t(_mm_extract_epi32(value, 0)) + uint64_t(_mm_extract_epi32(value, 1)) + uint64_t(_mm_extract_epi32(value, 2)) + uint64_t(_mm_extract_epi32(value, 3));
                    }

                    simdutf_really_inline simd32<uint32_t> swap_bytes() const
                    {
                        const __m128i shuffle = _mm_setr_epi8(3, 2, 1, 0, 7, 6, 5, 4, 8, 9, 10, 11, 15, 14, 13, 12);

                        return _mm_shuffle_epi8(value, shuffle);
                    }

                    template <int N>
                    simdutf_really_inline simd32<uint32_t> shr() const
                    {
                        return _mm_srli_epi32(value, N);
                    }

                    template <int N>
                    simdutf_really_inline simd32<uint32_t> shl() const
                    {
                        return _mm_slli_epi32(value, N);
                    }

                    void dump() const
                    {
                        printf("[%08x, %08x, %08x, %08x]\n", uint32_t(_mm_extract_epi32(value, 0)),
                            uint32_t(_mm_extract_epi32(value, 1)),
                            uint32_t(_mm_extract_epi32(value, 2)),
                            uint32_t(_mm_extract_epi32(value, 3)));
                    }

                    // operators
                    simdutf_really_inline simd32& operator+=(const simd32 other)
                    {
                        value = _mm_add_epi32(value, other.value);
                        return *this;
                    }

                    // static members
                    simdutf_really_inline static simd32<uint32_t> zero()
                    {
                        return _mm_setzero_si128();
                    }

                    simdutf_really_inline static simd32<uint32_t> splat(uint32_t v)
                    {
                        return _mm_set1_epi32(v);
                    }
                };

                //----------------------------------------------------------------------

                template <>
                struct simd32<bool>
                {
                    // static const size_t SIZE = sizeof(__m128i);
                    // static const size_t ELEMENTS = SIZE / sizeof(uint32_t);

                    __m128i value;

                    simdutf_really_inline simd32(const __m128i v)
                        : value(v)
                    {
                    }

                    simdutf_really_inline bool any() const
                    {
                        return _mm_movemask_epi8(value) != 0;
                    }

                    simdutf_really_inline uint8_t to_4bit_bitmask() const
                    {
                        return uint8_t(_mm_movemask_ps(_mm_castsi128_ps(value)));
                    }
                };

                //----------------------------------------------------------------------

                template <typename T>
                simdutf_really_inline simd32<T> operator|(const simd32<T> a,
                    const simd32<T> b)
                {
                    return _mm_or_si128(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> min(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return _mm_min_epu32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> max(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return _mm_max_epu32(a.value, b.value);
                }

                simdutf_really_inline simd32<bool> operator==(const simd32<uint32_t> a,
                    uint32_t b)
                {
                    return _mm_cmpeq_epi32(a.value, _mm_set1_epi32(b));
                }

                simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return _mm_and_si128(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> a,
                    uint32_t b)
                {
                    return _mm_and_si128(a.value, _mm_set1_epi32(b));
                }

                simdutf_really_inline simd32<uint32_t> operator|(const simd32<uint32_t> a,
                    uint32_t b)
                {
                    return _mm_or_si128(a.value, _mm_set1_epi32(b));
                }

                simdutf_really_inline simd32<uint32_t> operator+(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return _mm_add_epi32(a.value, b.value);
                }

                simdutf_really_inline simd32<uint32_t> operator-(const simd32<uint32_t> a,
                    uint32_t b)
                {
                    return _mm_sub_epi32(a.value, _mm_set1_epi32(b));
                }

                simdutf_really_inline simd32<bool> operator>=(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return _mm_cmpeq_epi32(_mm_max_epu32(a.value, b.value), a.value);
                }

                simdutf_really_inline simd32<bool> operator!(const simd32<bool> v)
                {
                    return _mm_xor_si128(v.value, _mm_set1_epi8(-1));
                }

                simdutf_really_inline simd32<bool> operator>(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return !(b >= a);
                }

                simdutf_really_inline simd32<uint32_t> select(const simd32<bool> cond,
                    const simd32<uint32_t> v_true,
                    const simd32<uint32_t> v_false)
                {
                    return _mm_blendv_epi8(v_false.value, v_true.value, cond.value);
                }
                /* end file src/simdutf/westmere/simd32-inl.h */
                /* begin file src/simdutf/westmere/simd64-inl.h */
                template <typename T>
                struct simd64;

                template <>
                struct simd64<uint64_t>
                {
                    // static const size_t SIZE = sizeof(__m128i);
                    // static const size_t ELEMENTS = SIZE / sizeof(uint64_t);

                    __m128i value;

                    simdutf_really_inline simd64(const __m128i v)
                        : value(v)
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline simd64(const Pointer* ptr)
                        : value(_mm_loadu_si128(reinterpret_cast<const __m128i*>(ptr)))
                    {
                    }

                    simdutf_really_inline uint64_t sum() const
                    {
                        return _mm_extract_epi64(value, 0) + _mm_extract_epi64(value, 1);
                    }

                    // operators
                    simdutf_really_inline simd64& operator+=(const simd64 other)
                    {
                        value = _mm_add_epi64(value, other.value);
                        return *this;
                    }

                    // static members
                    simdutf_really_inline static simd64<uint64_t> zero()
                    {
                        return _mm_setzero_si128();
                    }

                    simdutf_really_inline static simd64<uint64_t> splat(uint64_t v)
                    {
                        return _mm_set1_epi64x(v);
                    }
                };
                /* end file src/simdutf/westmere/simd64-inl.h */

                simdutf_really_inline simd64<uint64_t> sum_8bytes(const simd8<uint8_t> v)
                {
                    return _mm_sad_epu8(v.value, simd8<uint8_t>::zero());
                }

                simdutf_really_inline simd8<uint8_t> as_vector_u8(const simd32<uint32_t> v)
                {
                    return simd8<uint8_t>(v.value);
                }

            } // namespace simd
        } // unnamed namespace
    } // namespace westmere
} // namespace simdutf

        #endif // SIMDUTF_WESTMERE_SIMD_INPUT_H
        /* end file src/simdutf/westmere/simd.h */

        /* begin file src/simdutf/westmere/end.h */
        #if SIMDUTF_CAN_ALWAYS_RUN_WESTMERE
        // nothing needed.
        #else
SIMDUTF_UNTARGET_REGION
        #endif

        #undef SIMDUTF_SIMD_HAS_BYTEMASK
    /* end file src/simdutf/westmere/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_WESTMERE
#endif // SIMDUTF_WESTMERE_COMMON_H
/* end file src/simdutf/westmere.h */
/* begin file src/simdutf/ppc64.h */
#ifndef SIMDUTF_PPC64_H
    #define SIMDUTF_PPC64_H

    #ifdef SIMDUTF_FALLBACK_H
        #error "ppc64.h must be included before fallback.h"
    #endif

    #ifndef SIMDUTF_IMPLEMENTATION_PPC64
        #define SIMDUTF_IMPLEMENTATION_PPC64 (SIMDUTF_IS_PPC64)
    #endif
    #define SIMDUTF_CAN_ALWAYS_RUN_PPC64 \
        SIMDUTF_IMPLEMENTATION_PPC64&& SIMDUTF_IS_PPC64

    #if SIMDUTF_IMPLEMENTATION_PPC64

namespace simdutf
{
    /**
     * Implementation for ALTIVEC (PPC64).
     */
    namespace ppc64
    {
    } // namespace ppc64
} // namespace simdutf

        /* begin file src/simdutf/ppc64/implementation.h */
        #ifndef SIMDUTF_PPC64_IMPLEMENTATION_H
            #define SIMDUTF_PPC64_IMPLEMENTATION_H

namespace simdutf
{
    namespace ppc64
    {

        namespace
        {
            using namespace simdutf;

            template <size_t N>
            simdutf_really_inline size_t align_down(size_t size)
            {
                return N * (size / N);
            }
        } // namespace

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation("ppc64", "PPC64 ALTIVEC",
                      internal::instruction_set::ALTIVEC)
            {
            }

            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;

            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;

            #ifdef SIMDUTF_INTERNAL_TESTS
            virtual std::vector<TestProcedure> internal_tests() const override;
            #endif
        };

    } // namespace ppc64
} // namespace simdutf

        #endif // SIMDUTF_PPC64_IMPLEMENTATION_H
    /* end file src/simdutf/ppc64/implementation.h */

    /* begin file src/simdutf/ppc64/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "ppc64"
    // #define SIMDUTF_IMPLEMENTATION ppc64
    /* end file src/simdutf/ppc64/begin.h */

    // Declarations
        /* begin file src/simdutf/ppc64/intrinsics.h */
        #ifndef SIMDUTF_PPC64_INTRINSICS_H
            #define SIMDUTF_PPC64_INTRINSICS_H

            // This should be the correct header whether
            // you use visual studio or other compilers.
            #include <altivec.h>

            // These are defined by altivec.h in GCC toolchain, it is safe to undef them.
            #ifdef bool
                #undef bool
            #endif

            #ifdef vector
                #undef vector
            #endif

        #endif //  SIMDUTF_PPC64_INTRINSICS_H
        /* end file src/simdutf/ppc64/intrinsics.h */
        /* begin file src/simdutf/ppc64/bitmanipulation.h */
        #ifndef SIMDUTF_PPC64_BITMANIPULATION_H
            #define SIMDUTF_PPC64_BITMANIPULATION_H

namespace simdutf
{
    namespace ppc64
    {
        namespace
        {

            #ifdef SIMDUTF_REGULAR_VISUAL_STUDIO
            simdutf_really_inline int count_ones(uint64_t input_num)
            {
                // note: we do not support legacy 32-bit Windows
                return __popcnt64(input_num); // Visual Studio wants two underscores
            }
            #else
            simdutf_really_inline int count_ones(uint64_t input_num)
            {
                return __builtin_popcountll(input_num);
            }
            #endif

            #if SIMDUTF_NEED_TRAILING_ZEROES
            simdutf_really_inline int trailing_zeroes(uint64_t input_num)
            {
                return __builtin_ctzll(input_num);
            }
            #endif

        } // unnamed namespace
    } // namespace ppc64
} // namespace simdutf

        #endif // SIMDUTF_PPC64_BITMANIPULATION_H
        /* end file src/simdutf/ppc64/bitmanipulation.h */
        /* begin file src/simdutf/ppc64/simd.h */
        #ifndef SIMDUTF_PPC64_SIMD_H
            #define SIMDUTF_PPC64_SIMD_H

            #include <type_traits>

namespace simdutf
{
    namespace ppc64
    {
        namespace
        {
            namespace simd
            {

                using vec_bool_t = __vector __bool char;
                using vec_bool16_t = __vector __bool short;
                using vec_bool32_t = __vector __bool int;
                using vec_u8_t = __vector unsigned char;
                using vec_i8_t = __vector signed char;
                using vec_u16_t = __vector unsigned short;
                using vec_i16_t = __vector signed short;
                using vec_u32_t = __vector unsigned int;
                using vec_i32_t = __vector signed int;
                using vec_u64_t = __vector unsigned long long;
                using vec_i64_t = __vector signed long long;

                // clang-format off
template <typename T> struct vector_u8_type_for_element_aux {
  using type = typename std::conditional<std::is_same<T, bool>::value,    vec_bool_t,
               typename std::conditional<std::is_same<T, uint8_t>::value, vec_u8_t,
               typename std::conditional<std::is_same<T, int8_t>::value,  vec_i8_t, void>::type>::type>::type;

  static_assert(not std::is_same<type, void>::value,
                "accepted element types are 8 bit integers or bool");
};

template <typename T> struct vector_u16_type_for_element_aux {
  using type = typename std::conditional<std::is_same<T, bool>::value,     vec_bool16_t,
               typename std::conditional<std::is_same<T, uint16_t>::value, vec_u16_t,
               typename std::conditional<std::is_same<T, int16_t>::value,  vec_i16_t, void>::type>::type>::type;

  static_assert(not std::is_same<type, void>::value,
                "accepted element types are 16 bit integers or bool");
};

template <typename T> struct vector_u32_type_for_element_aux {
  using type = typename std::conditional<std::is_same<T, bool>::value,     vec_bool32_t,
               typename std::conditional<std::is_same<T, uint32_t>::value, vec_u32_t,
               typename std::conditional<std::is_same<T, int32_t>::value,  vec_i32_t, void>::type>::type>::type;

  static_assert(not std::is_same<type, void>::value,
                "accepted element types are 32 bit integers or bool");
};
                // clang-format on

                template <typename T>
                using vector_u8_type_for_element =
                    typename vector_u8_type_for_element_aux<T>::type;

                template <typename T>
                using vector_u16_type_for_element =
                    typename vector_u16_type_for_element_aux<T>::type;

                template <typename T>
                using vector_u32_type_for_element =
                    typename vector_u32_type_for_element_aux<T>::type;

                template <typename T>
                uint16_t move_mask_u8(T vec)
                {
                    const vec_u8_t perm_mask = { 15 * 8, 14 * 8, 13 * 8, 12 * 8, 11 * 8, 10 * 8,
                        9 * 8, 8 * 8, 7 * 8, 6 * 8, 5 * 8, 4 * 8,
                        3 * 8, 2 * 8, 1 * 8, 0 * 8 };

                    const auto result = (vec_u64_t)vec_vbpermq((vec_u8_t)vec, perm_mask);
            #if SIMDUTF_IS_BIG_ENDIAN
                    return static_cast<uint16_t>(result[0]);
            #else
                    return static_cast<uint16_t>(result[1]);
            #endif
                }

                /* begin file src/simdutf/ppc64/simd8-inl.h */
                // file included directly

                template <typename T>
                struct base8
                {
                    using vector_type = vector_u8_type_for_element<T>;
                    vector_type value;
                    static const int SIZE = sizeof(vector_type);
                    static const int ELEMENTS = sizeof(vector_type) / sizeof(T);

                    // Zero constructor
                    simdutf_really_inline base8()
                        : value { vec_splats(T(0)) }
                    {
                    }

                    // Conversion from SIMD register
                    simdutf_really_inline base8(const vector_type _value)
                        : value { _value }
                    {
                    }

                    // Splat scalar
                    simdutf_really_inline base8(T v)
                        : value { vec_splats(v) }
                    {
                    }

                    // Conversion to SIMD register
                    simdutf_really_inline operator const vector_type&() const
                    {
                        return this->value;
                    }

                    template <typename U>
                    simdutf_really_inline void store(U* ptr) const
                    {
                        vec_xst(value, 0, reinterpret_cast<T*>(ptr));
                    }

                    template <typename SIMD8>
                    void operator|=(const SIMD8 other)
                    {
                        this->value = vec_or(this->value, other.value);
                    }

                    template <int N = 1>
                    vector_type prev_aux(vector_type prev_chunk) const
                    {
                        vector_type chunk = this->value;
            #if !SIMDUTF_IS_BIG_ENDIAN
                        chunk = (vector_type)vec_reve(this->value);
                        prev_chunk = (vector_type)vec_reve((vector_type)prev_chunk);
            #endif
                        chunk = (vector_type)vec_sld((vector_type)prev_chunk, (vector_type)chunk,
                            16 - N);
            #if !SIMDUTF_IS_BIG_ENDIAN
                        chunk = (vector_type)vec_reve((vector_type)chunk);
            #endif
                        return chunk;
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return move_mask_u8(this->value) == 0;
                    }

                    simdutf_really_inline uint16_t to_bitmask() const
                    {
                        return move_mask_u8(value);
                    }

                    template <endianness big_endian>
                    simdutf_really_inline void store_bytes_as_utf16(char16_t* p) const
                    {
                        const vector_type zero = vec_splats(T(0));

                        if (big_endian)
                        {
                            const vec_u8_t perm_lo = { 16, 0, 16, 1, 16, 2, 16, 3,
                                16, 4, 16, 5, 16, 6, 16, 7 };
                            const vec_u8_t perm_hi = { 16, 8, 16, 9, 16, 10, 16, 11,
                                16, 12, 16, 13, 16, 14, 16, 15 };

                            const vector_type v0 = vec_perm(value, zero, perm_lo);
                            const vector_type v1 = vec_perm(value, zero, perm_hi);

            #if defined(__clang__)
                            vec_xst(v0, 0, reinterpret_cast<T*>(p));
                            vec_xst(v1, 16, reinterpret_cast<T*>(p));
            #else
                            vec_xst(v0, 0, reinterpret_cast<vector_type*>(p));
                            vec_xst(v1, 16, reinterpret_cast<vector_type*>(p));
            #endif // defined(__clang__)
                        }
                        else
                        {
                            const vec_u8_t perm_lo = { 0, 16, 1, 16, 2, 16, 3, 16,
                                4, 16, 5, 16, 6, 16, 7, 16 };
                            const vec_u8_t perm_hi = { 8, 16, 9, 16, 10, 16, 11, 16,
                                12, 16, 13, 16, 14, 16, 15, 16 };

                            const vector_type v0 = vec_perm(value, zero, perm_lo);
                            const vector_type v1 = vec_perm(value, zero, perm_hi);

            #if defined(__clang__)
                            vec_xst(v0, 0, reinterpret_cast<T*>(p));
                            vec_xst(v1, 16, reinterpret_cast<T*>(p));
            #else
                            vec_xst(v0, 0, reinterpret_cast<vector_type*>(p));
                            vec_xst(v1, 16, reinterpret_cast<vector_type*>(p));
            #endif // defined(__clang__)
                        }
                    }

                    template <endianness big_endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* p) const
                    {
                        store_bytes_as_utf16<big_endian>(p);
                    }

                    simdutf_really_inline void store_bytes_as_utf32(char32_t* p) const
                    {
                        const vector_type zero = vec_splats(T(0));

            #if SIMDUTF_IS_BIG_ENDIAN
                        const vec_u8_t perm0 = { 16, 16, 16, 0, 16, 16, 16, 1,
                            16, 16, 16, 2, 16, 16, 16, 3 };

                        const vec_u8_t perm1 = { 16, 16, 16, 4, 16, 16, 16, 5,
                            16, 16, 16, 6, 16, 16, 16, 7 };

                        const vec_u8_t perm2 = { 16, 16, 16, 8, 16, 16, 16, 9,
                            16, 16, 16, 10, 16, 16, 16, 11 };

                        const vec_u8_t perm3 = { 16, 16, 16, 12, 16, 16, 16, 13,
                            16, 16, 16, 14, 16, 16, 16, 15 };
            #else
                        const vec_u8_t perm0 = { 0, 16, 16, 16, 1, 16, 16, 16,
                            2, 16, 16, 16, 3, 16, 16, 16 };

                        const vec_u8_t perm1 = { 4, 16, 16, 16, 5, 16, 16, 16,
                            6, 16, 16, 16, 7, 16, 16, 16 };

                        const vec_u8_t perm2 = { 8, 16, 16, 16, 9, 16, 16, 16,
                            10, 16, 16, 16, 11, 16, 16, 16 };

                        const vec_u8_t perm3 = { 12, 16, 16, 16, 13, 16, 16, 16,
                            14, 16, 16, 16, 15, 16, 16, 16 };
            #endif // SIMDUTF_IS_BIG_ENDIAN

                        const vector_type v0 = vec_perm(value, zero, perm0);
                        const vector_type v1 = vec_perm(value, zero, perm1);
                        const vector_type v2 = vec_perm(value, zero, perm2);
                        const vector_type v3 = vec_perm(value, zero, perm3);

                        constexpr size_t n = base8<T>::SIZE;

            #if defined(__clang__)
                        vec_xst(v0, 0 * n, reinterpret_cast<T*>(p));
                        vec_xst(v1, 1 * n, reinterpret_cast<T*>(p));
                        vec_xst(v2, 2 * n, reinterpret_cast<T*>(p));
                        vec_xst(v3, 3 * n, reinterpret_cast<T*>(p));
            #else
                        vec_xst(v0, 0 * n, reinterpret_cast<vector_type*>(p));
                        vec_xst(v1, 1 * n, reinterpret_cast<vector_type*>(p));
                        vec_xst(v2, 2 * n, reinterpret_cast<vector_type*>(p));
                        vec_xst(v3, 3 * n, reinterpret_cast<vector_type*>(p));
            #endif // defined(__clang__)
                    }

                    simdutf_really_inline void store_words_as_utf32(char32_t* p) const
                    {
                        const vector_type zero = vec_splats(T(0));

            #if SIMDUTF_IS_BIG_ENDIAN
                        const vec_u8_t perm0 = { 16, 16, 0, 1, 16, 16, 2, 3,
                            16, 16, 4, 5, 16, 16, 6, 7 };
                        const vec_u8_t perm1 = { 16, 16, 8, 9, 16, 16, 10, 11,
                            16, 16, 12, 13, 16, 16, 14, 15 };
            #else
                        const vec_u8_t perm0 = { 0, 1, 16, 16, 2, 3, 16, 16,
                            4, 5, 16, 16, 6, 7, 16, 16 };
                        const vec_u8_t perm1 = { 8, 9, 16, 16, 10, 11, 16, 16,
                            12, 13, 16, 16, 14, 15, 16, 16 };
            #endif // SIMDUTF_IS_BIG_ENDIAN

                        const vector_type v0 = vec_perm(value, zero, perm0);
                        const vector_type v1 = vec_perm(value, zero, perm1);

                        constexpr size_t n = base8<T>::SIZE;

            #if defined(__clang__)
                        vec_xst(v0, 0 * n, reinterpret_cast<T*>(p));
                        vec_xst(v1, 1 * n, reinterpret_cast<T*>(p));
            #else
                        vec_xst(v0, 0 * n, reinterpret_cast<vector_type*>(p));
                        vec_xst(v1, 1 * n, reinterpret_cast<vector_type*>(p));
            #endif // defined(__clang__)
                    }

                    simdutf_really_inline void store_ascii_as_utf32(char32_t* p) const
                    {
                        store_bytes_as_utf32(p);
                    }
                };

                // Forward declaration
                template <typename T>
                struct simd8;

                template <typename T>
                simd8<bool> operator==(const simd8<T> a, const simd8<T> b);

                template <typename T>
                simd8<bool> operator!=(const simd8<T> a, const simd8<T> b);

                template <typename T>
                simd8<T> operator&(const simd8<T> a, const simd8<T> b);

                template <typename T>
                simd8<T> operator|(const simd8<T> a, const simd8<T> b);

                template <typename T>
                simd8<T> operator^(const simd8<T> a, const simd8<T> b);

                template <typename T>
                simd8<T> operator+(const simd8<T> a, const simd8<T> b);

                template <typename T>
                simd8<bool> operator<(const simd8<T> a, const simd8<T> b);

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd8<bool> : base8<bool>
                {
                    using super = base8<bool>;

                    static simdutf_really_inline simd8<bool> splat(bool _value)
                    {
                        return (vector_type)vec_splats((unsigned char)(-(!!_value)));
                    }

                    simdutf_really_inline simd8()
                        : super(vector_type())
                    {
                    }
                    simdutf_really_inline simd8(const vector_type _value)
                        : super(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(bool _value)
                        : base8<bool>(splat(_value))
                    {
                    }

                    template <typename T>
                    simdutf_really_inline simd8(simd8<T> other)
                        : simd8(vector_type(other.value))
                    {
                    }

                    simdutf_really_inline uint16_t to_bitmask() const
                    {
                        return move_mask_u8(value);
                    }

                    simdutf_really_inline bool any() const
                    {
                        return !vec_all_eq(this->value, (vector_type)vec_splats(0));
                    }

                    simdutf_really_inline bool all() const { return to_bitmask() == 0xffff; }

                    simdutf_really_inline simd8<bool> operator~() const
                    {
                        return this->value ^ (vector_type)splat(true);
                    }
                };

                template <typename T>
                struct base8_numeric : base8<T>
                {
                    using super = base8<T>;
                    using vector_type = typename super::vector_type;

                    static simdutf_really_inline simd8<T> splat(T value)
                    {
                        return (vector_type)vec_splats(value);
                    }

                    static simdutf_really_inline simd8<T> zero() { return splat(0); }

                    template <typename U>
                    static simdutf_really_inline simd8<T> load(const U* values)
                    {
                        return vec_xl(0, reinterpret_cast<const T*>(values));
                    }

                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
                        T v5, T v6, T v7, T v8, T v9,
                        T v10, T v11, T v12, T v13,
                        T v14, T v15)
                    {
                        return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
                            v14, v15);
                    }

                    simdutf_really_inline base8_numeric()
                        : base8<T>()
                    {
                    }
                    simdutf_really_inline base8_numeric(const vector_type _value)
                        : base8<T>(_value)
                    {
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }

                    simdutf_really_inline simd8<T>& operator-=(const simd8<T> other)
                    {
                        this->value = vec_sub(this->value, other.value);
                        return *static_cast<simd8<T>*>(this);
                    }

                    // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
                    // for out of range values)
                    template <typename L>
                    simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const
                    {
                        return (vector_type)vec_perm((vector_type)lookup_table,
                            (vector_type)lookup_table, this->value);
                    }

                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_32(const simd8<L> lookup_table_lo,
                        const simd8<L> lookup_table_hi) const
                    {
                        return (vector_type)vec_perm(lookup_table_lo.value, lookup_table_hi.value,
                            this->value);
                    }

                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
                        L replace5, L replace6, L replace7, L replace8, L replace9,
                        L replace10, L replace11, L replace12, L replace13, L replace14,
                        L replace15) const
                    {
                        return lookup_16(simd8<L>::repeat_16(
                            replace0, replace1, replace2, replace3, replace4, replace5, replace6,
                            replace7, replace8, replace9, replace10, replace11, replace12,
                            replace13, replace14, replace15));
                    }
                };

                // Unsigned bytes
                template <>
                struct simd8<uint8_t> : base8_numeric<uint8_t>
                {
                    using Self = simd8<uint8_t>;

                    simdutf_really_inline simd8()
                        : base8_numeric<uint8_t>()
                    {
                    }
                    simdutf_really_inline simd8(const vector_type _value)
                        : base8_numeric<uint8_t>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(uint8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const uint8_t* values)
                        : simd8(load(values))
                    {
                    }
                    // Member-by-member initialization
                    simdutf_really_inline
                    simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
                        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
                        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
                        : simd8((vector_type) { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                              v12, v13, v14, v15 })
                    {
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<uint8_t>
                    repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
                        uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
                        uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
                        uint8_t v15)
                    {
                        return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15);
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return move_mask_u8(this->value) == 0;
                    }

                    template <typename T>
                    simdutf_really_inline simd8(simd8<T> other)
                        : simd8(vector_type(other.value))
                    {
                    }

                    template <int N>
                    simdutf_really_inline Self prev(const Self prev_chunk) const
                    {
                        return prev_aux<N>(prev_chunk.value);
                    }

                    // Saturated math
                    simdutf_really_inline simd8<uint8_t>
                    saturating_sub(const simd8<uint8_t> other) const
                    {
                        return (vector_type)vec_subs(this->value, (vector_type)other);
                    }

                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd8<uint8_t>
                    gt_bits(const simd8<uint8_t> other) const
                    {
                        return this->saturating_sub(other);
                    }

                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd8<uint8_t>
                    lt_bits(const simd8<uint8_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }

                    // Bit-specific operations
                    simdutf_really_inline bool bits_not_set_anywhere() const
                    {
                        return vec_all_eq(this->value, (vector_type)vec_splats(0));
                    }

                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        return !bits_not_set_anywhere();
                    }

                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shr() const
                    {
                        return simd8<uint8_t>(
                            (vector_type)vec_sr(this->value, (vector_type)vec_splat_u8(N)));
                    }

                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shl() const
                    {
                        return simd8<uint8_t>(
                            (vector_type)vec_sl(this->value, (vector_type)vec_splat_u8(N)));
                    }

                    void dump() const
                    {
                        uint8_t tmp[16];
                        store(tmp);
                        for (int i = 0; i < 16; i++)
                        {
                            if (i == 0)
                            {
                                printf("[%02x", tmp[i]);
                            }
                            else if (i == 15)
                            {
                                printf(" %02x]", tmp[i]);
                            }
                            else
                            {
                                printf(" %02x", tmp[i]);
                            }
                        }
                        putchar('\n');
                    }

                    void dump_ascii() const
                    {
                        uint8_t tmp[16];
                        store(tmp);
                        for (int i = 0; i < 16; i++)
                        {
                            if (i == 0)
                            {
                                printf("[%c", tmp[i]);
                            }
                            else if (i == 15)
                            {
                                printf("%c]", tmp[i]);
                            }
                            else
                            {
                                printf("%c", tmp[i]);
                            }
                        }
                        putchar('\n');
                    }
                };

                // Signed bytes
                template <>
                struct simd8<int8_t> : base8_numeric<int8_t>
                {
                    simdutf_really_inline simd8()
                        : base8_numeric<int8_t>()
                    {
                    }
                    simdutf_really_inline simd8(const vector_type _value)
                        : base8_numeric<int8_t>(_value)
                    {
                    }

                    template <typename T>
                    simdutf_really_inline simd8(simd8<T> other)
                        : simd8(vector_type(other.value))
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd8(int8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const int8_t* values)
                        : simd8(load(values))
                    {
                    }

                    simdutf_really_inline operator simd8<uint8_t>() const;

                    // Saturated math
                    simdutf_really_inline simd8<int8_t>
                    saturating_add(const simd8<int8_t> other) const
                    {
                        return (vector_type)vec_adds(this->value, other.value);
                    }

                    void dump() const
                    {
                        int8_t tmp[16];
                        store(tmp);
                        for (int i = 0; i < 16; i++)
                        {
                            if (i == 0)
                            {
                                printf("[%02x", tmp[i]);
                            }
                            else if (i == 15)
                            {
                                printf("%02x]", tmp[i]);
                            }
                            else
                            {
                                printf("%02x", tmp[i]);
                            }
                        }
                        putchar('\n');
                    }
                };

                template <typename T>
                simd8<bool> operator==(const simd8<T> a, const simd8<T> b)
                {
                    return vec_cmpeq(a.value, b.value);
                }

                template <typename T>
                simd8<bool> operator!=(const simd8<T> a, const simd8<T> b)
                {
                    return vec_cmpne(a.value, b.value);
                }

                template <typename T>
                simd8<T> operator&(const simd8<T> a, const simd8<T> b)
                {
                    return vec_and(a.value, b.value);
                }

                template <typename T, typename U>
                simd8<T> operator&(const simd8<T> a, U b)
                {
                    return vec_and(a.value, vec_splats(T(b)));
                }

                template <typename T>
                simd8<T> operator|(const simd8<T> a, const simd8<T> b)
                {
                    return vec_or(a.value, b.value);
                }

                template <typename T>
                simd8<T> operator^(const simd8<T> a, const simd8<T> b)
                {
                    return vec_xor(a.value, b.value);
                }

                template <typename T, typename U>
                simd8<T> operator^(const simd8<T> a, U b)
                {
                    return vec_xor(a.value, vec_splats(T(b)));
                }

                template <typename T>
                simd8<T> operator+(const simd8<T> a, const simd8<T> b)
                {
                    return vec_add(a.value, b.value);
                }

                template <typename T, typename U>
                simd8<T> operator+(const simd8<T> a, U b)
                {
                    return vec_add(a.value, vec_splats(T(b)));
                }

                simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const
                {
                    return (simd8<uint8_t>::vector_type)value;
                }

                template <typename T>
                simd8<bool> operator<(const simd8<T> a, const simd8<T> b)
                {
                    return vec_cmplt(a.value, b.value);
                }

                template <typename T>
                simd8<bool> operator>(const simd8<T> a, const simd8<T> b)
                {
                    return vec_cmpgt(a.value, b.value);
                }

                template <typename T>
                simd8<bool> operator>=(const simd8<T> a, const simd8<T> b)
                {
                    return vec_cmpge(a.value, b.value);
                }

                template <typename T>
                struct simd8x64
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
                    static constexpr size_t ELEMENTS = simd8<T>::ELEMENTS;

                    static_assert(NUM_CHUNKS == 4,
                        "PPC64 kernel should use four registers per 64-byte block.");
                    simd8<T> chunks[NUM_CHUNKS];

                    simd8x64(const simd8x64<T>& o) = delete; // no copy allowed
                    simd8x64<T>&
                    operator=(const simd8<T> other)
                        = delete; // no assignment allowed
                    simd8x64() = delete; // no default constructor allowed
                    simd8x64(simd8x64<T>&&) = default;

                    simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
                        const simd8<T> chunk2, const simd8<T> chunk3)
                        : chunks { chunk0, chunk1, chunk2, chunk3 }
                    {
                    }
                    simdutf_really_inline simd8x64(const T* ptr)
                        : chunks { simd8<T>::load(ptr),
                            simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
                            simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
                            simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + ELEMENTS * 0);
                        this->chunks[1].store(ptr + ELEMENTS * 1);
                        this->chunks[2].store(ptr + ELEMENTS * 2);
                        this->chunks[3].store(ptr + ELEMENTS * 3);
                    }

                    simdutf_really_inline simd8x64<T>& operator|=(const simd8x64<T>& other)
                    {
                        this->chunks[0] |= other.chunks[0];
                        this->chunks[1] |= other.chunks[1];
                        this->chunks[2] |= other.chunks[2];
                        this->chunks[3] |= other.chunks[3];
                        return *this;
                    }

                    simdutf_really_inline simd8<T> reduce_or() const
                    {
                        return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->reduce_or().is_ascii();
                    }

                    template <endianness endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 1);
                        this->chunks[2].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 2);
                        this->chunks[3].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 3);
                    }

                    simdutf_really_inline void store_ascii_as_utf32(char32_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
                        this->chunks[2].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 2);
                        this->chunks[3].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 3);
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
                        uint64_t r1 = this->chunks[1].to_bitmask();
                        uint64_t r2 = this->chunks[2].to_bitmask();
                        uint64_t r3 = this->chunks[3].to_bitmask();
                        return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
                    }

                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
                            this->chunks[2] < mask, this->chunks[3] < mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t gt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
                            this->chunks[2] > mask, this->chunks[3] > mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const
                    {
                        const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
                        return simd8x64<bool>(simd8<uint8_t>(this->chunks[0]) >= mask,
                            simd8<uint8_t>(this->chunks[1]) >= mask,
                            simd8<uint8_t>(this->chunks[2]) >= mask,
                            simd8<uint8_t>(this->chunks[3]) >= mask)
                            .to_bitmask();
                    }

                    void dump() const
                    {
                        puts("");
                        for (int i = 0; i < 4; i++)
                        {
                            printf("chunk[%d] = ", i);
                            this->chunks[i].dump();
                        }
                    }
                }; // struct simd8x64<T>

                simdutf_really_inline simd8<uint8_t> avg(const simd8<uint8_t> a,
                    const simd8<uint8_t> b)
                {
                    return vec_avg(a.value, b.value);
                }
                /* end file src/simdutf/ppc64/simd8-inl.h */
                /* begin file src/simdutf/ppc64/simd16-inl.h */
                // file included directly

                template <typename T>
                struct simd16;

                template <typename T>
                struct base16
                {
                    using vector_type = vector_u16_type_for_element<T>;
                    static const int SIZE = sizeof(vector_type);
                    static const int ELEMENTS = sizeof(vector_type) / sizeof(T);

                    vector_type value;

                    // Zero constructor
                    simdutf_really_inline base16()
                        : value { vector_type() }
                    {
                    }

                    // Conversion from SIMD register
                    simdutf_really_inline base16(const vector_type _value)
                        : value { _value }
                    {
                    }

                    void dump() const
                    {
                        uint16_t tmp[8];
                        vec_xst(value, 0, reinterpret_cast<vector_type*>(tmp));
                        for (int i = 0; i < 8; i++)
                        {
                            if (i == 0)
                            {
                                printf("[%04x", tmp[i]);
                            }
                            else if (i == 8 - 1)
                            {
                                printf(" %04x]", tmp[i]);
                            }
                            else
                            {
                                printf(" %04x", tmp[i]);
                            }
                        }
                        putchar('\n');
                    }
                };

                // Forward declaration
                template <typename>
                struct simd16;

                template <typename T>
                simd16<bool> operator==(const simd16<T> a, const simd16<T> b);

                template <typename T, typename U>
                simd16<bool> operator==(const simd16<T> a, U b);

                template <typename T>
                simd16<T> operator&(const simd16<T> a, const simd16<T> b);

                template <typename T>
                simd16<T> operator|(const simd16<T> a, const simd16<T> b);

                template <typename T, typename U>
                simd16<T> operator|(const simd16<T> a, U b);

                template <typename T, typename U>
                simd16<T> operator^(const simd16<T> a, U b);

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd16<bool> : base16<bool>
                {
                    static simdutf_really_inline simd16<bool> splat(bool _value)
                    {
                        return (vector_type)vec_splats(uint16_t(-(!!_value)));
                    }

                    simdutf_really_inline simd16()
                        : base16()
                    {
                    }

                    simdutf_really_inline simd16(const vector_type _value)
                        : base16<bool>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(bool _value)
                        : base16<bool>(splat(_value))
                    {
                    }

                    simdutf_really_inline uint16_t to_bitmask() const
                    {
                        return move_mask_u8(value);
                    }

                    simdutf_really_inline bool any() const
                    {
                        const auto tmp = vec_u64_t(value);

                        return tmp[0] || tmp[1]; // Note: logical or, not binary one
                    }

                    simdutf_really_inline bool is_zero() const
                    {
                        const auto tmp = vec_u64_t(value);

                        return (tmp[0] | tmp[1]) == 0;
                    }

                    simdutf_really_inline simd16<bool>& operator|=(const simd16<bool> rhs)
                    {
                        value = vec_or(this->value, rhs.value);
                        return *this;
                    }
                };

                template <typename T>
                struct base16_numeric : base16<T>
                {
                    using vector_type = typename base16<T>::vector_type;

                    static simdutf_really_inline simd16<T> splat(T _value)
                    {
                        return vec_splats(_value);
                    }

                    static simdutf_really_inline simd16<T> zero() { return splat(0); }

                    template <typename U>
                    static simdutf_really_inline simd16<T> load(const U* ptr)
                    {
                        return vec_xl(0, reinterpret_cast<const T*>(ptr));
                    }

                    simdutf_really_inline base16_numeric()
                        : base16<T>()
                    {
                    }
                    simdutf_really_inline base16_numeric(const vector_type _value)
                        : base16<T>(_value)
                    {
                    }

                    // Store to array
                    template <typename U>
                    simdutf_really_inline void store(U* dst) const
                    {
            #if defined(__clang__)
                        return vec_xst(this->value, 0, reinterpret_cast<T*>(dst));
            #else
                        return vec_xst(this->value, 0, reinterpret_cast<vector_type*>(dst));
            #endif // defined(__clang__)
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd16<T> operator~() const
                    {
                        return vec_xor(this->value, vec_splats(T(0xffff)));
                    }
                };

                // Signed code units
                template <>
                struct simd16<int16_t> : base16_numeric<int16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<int16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const vector_type _value)
                        : base16_numeric<int16_t>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(int16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline operator simd16<uint16_t>() const;
                };

                // Unsigned code units
                template <>
                struct simd16<uint16_t> : base16_numeric<uint16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<uint16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const vector_type _value)
                        : base16_numeric<uint16_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(uint16_t _value)
                        : simd16(splat(_value))
                    {
                    }

                    // Array constructor
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const uint16_t*>(values)))
                    {
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return vec_all_lt(value, vec_splats(uint16_t(128)));
                    }

                    // Order-specific operations
                    simdutf_really_inline simd16<uint16_t>
                    max_val(const simd16<uint16_t> other) const
                    {
                        return vec_max(this->value, other.value);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    min_val(const simd16<uint16_t> other) const
                    {
                        return vec_min(this->value, other.value);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<bool>
                    operator<=(const simd16<uint16_t> other) const
                    {
                        return other.max_val(*this) == other;
                    }

                    simdutf_really_inline simd16<bool>
                    operator>=(const simd16<uint16_t> other) const
                    {
                        return other.min_val(*this) == other;
                    }

                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<uint16_t> other) const
                    {
                        return vec_cmplt(value, other.value);
                    }

                    // Bit-specific operations
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shr() const
                    {
                        return vec_sr(value, vec_splats(uint16_t(N)));
                    }

                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shl() const
                    {
                        return vec_sl(value, vec_splats(uint16_t(N)));
                    }

                    // Change the endianness
                    simdutf_really_inline simd16<uint16_t> swap_bytes() const
                    {
                        return vec_revb(value);
                    }

                    // Pack with the unsigned saturation of two uint16_t code units into single
                    // uint8_t vector
                    static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t>& v0,
                        const simd16<uint16_t>& v1)
                    {
                        return vec_packs(v0.value, v1.value);
                    }
                };

                template <typename T>
                simd16<bool> operator==(const simd16<T> a, const simd16<T> b)
                {
                    return vec_cmpeq(a.value, b.value);
                }

                template <typename T, typename U>
                simd16<bool> operator==(const simd16<T> a, U b)
                {
                    return vec_cmpeq(a.value, vec_splats(T(b)));
                }

                template <typename T>
                simd16<T> operator&(const simd16<T> a, const simd16<T> b)
                {
                    return vec_and(a.value, b.value);
                }

                template <typename T, typename U>
                simd16<T> operator&(const simd16<T> a, U b)
                {
                    return vec_and(a.value, vec_splats(T(b)));
                }

                template <typename T>
                simd16<T> operator|(const simd16<T> a, const simd16<T> b)
                {
                    return vec_or(a.value, b.value);
                }

                template <typename T, typename U>
                simd16<T> operator|(const simd16<T> a, U b)
                {
                    return vec_or(a.value, vec_splats(T(b)));
                }

                template <typename T>
                simd16<T> operator^(const simd16<T> a, const simd16<T> b)
                {
                    return vec_xor(a.value, b.value);
                }

                template <typename T, typename U>
                simd16<T> operator^(const simd16<T> a, U b)
                {
                    return vec_xor(a.value, vec_splats(T(b)));
                }

                simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const
                {
                    return (vec_u16_t)(value);
                }

                template <typename T>
                struct simd16x32
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
                    static_assert(NUM_CHUNKS == 4,
                        "AltiVec kernel should use four registers per 64-byte block.");
                    simd16<T> chunks[NUM_CHUNKS];

                    simd16x32(const simd16x32<T>& o) = delete; // no copy allowed
                    simd16x32<T>&
                    operator=(const simd16<T> other)
                        = delete; // no assignment allowed
                    simd16x32() = delete; // no default constructor allowed

                    simdutf_really_inline
                    simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
                        const simd16<T> chunk2, const simd16<T> chunk3)
                        : chunks { chunk0, chunk1, chunk2, chunk3 }
                    {
                    }
                    simdutf_really_inline simd16x32(const T* ptr)
                        : chunks { simd16<T>::load(ptr),
                            simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
                            simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
                            simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
                        this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
                        this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
                    }

                    simdutf_really_inline simd16<T> reduce_or() const
                    {
                        return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->reduce_or().is_ascii();
                    }

                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
                        this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
                        this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
                        this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        uint64_t r0 = uint32_t(this->chunks[0].to_bitmask());
                        uint64_t r1 = this->chunks[1].to_bitmask();
                        uint64_t r2 = this->chunks[2].to_bitmask();
                        uint64_t r3 = this->chunks[3].to_bitmask();
                        return r0 | (r1 << 16) | (r2 << 32) | (r3 << 48);
                    }

                    simdutf_really_inline void swap_bytes()
                    {
                        this->chunks[0] = this->chunks[0].swap_bytes();
                        this->chunks[1] = this->chunks[1].swap_bytes();
                        this->chunks[2] = this->chunks[2].swap_bytes();
                        this->chunks[3] = this->chunks[3].swap_bytes();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
                            this->chunks[2] <= mask, this->chunks[3] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
                        const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
                        return simd16x32<bool>(
                            (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
                            (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low),
                            (this->chunks[2] >= mask_high) | (this->chunks[2] <= mask_low),
                            (this->chunks[3] >= mask_high) | (this->chunks[3] <= mask_low))
                            .to_bitmask();
                    }
                }; // struct simd16x32<T>
                /* end file src/simdutf/ppc64/simd16-inl.h */
                /* begin file src/simdutf/ppc64/simd32-inl.h */
                // file included directly

                template <typename T>
                struct simd32;

                template <typename T>
                struct base32
                {
                    using vector_type = vector_u32_type_for_element<T>;
                    static const int SIZE = sizeof(vector_type);
                    static const int ELEMENTS = sizeof(vector_type) / sizeof(T);

                    vector_type value;

                    // Zero constructor
                    simdutf_really_inline base32()
                        : value { vector_type() }
                    {
                    }

                    // Conversion from SIMD register
                    simdutf_really_inline base32(const vector_type _value)
                        : value { _value }
                    {
                    }

                    // Splat for scalar
                    simdutf_really_inline base32(T scalar)
                        : value { vec_splats(scalar) }
                    {
                    }

                    template <typename Pointer>
                    simdutf_really_inline base32(const Pointer* ptr)
                        : base32(vec_xl(0, reinterpret_cast<const T*>(ptr)))
                    {
                    }

                    // Store to array
                    template <typename U>
                    simdutf_really_inline void store(U* dst) const
                    {
            #if defined(__clang__)
                        return vec_xst(this->value, 0, reinterpret_cast<T*>(dst));
            #else
                        return vec_xst(this->value, 0, reinterpret_cast<vector_type*>(dst));
            #endif // defined(__clang__)
                    }

                    void dump(const char* name = nullptr) const
                    {
                        if (name != nullptr)
                        {
                            printf("%-10s = ", name);
                        }

                        uint32_t tmp[4];
                        vec_xst(value, 0, reinterpret_cast<vector_type*>(tmp));
                        for (int i = 0; i < 4; i++)
                        {
                            if (i == 0)
                            {
                                printf("[%08x", tmp[i]);
                            }
                            else if (i == 4 - 1)
                            {
                                printf(" %08x]", tmp[i]);
                            }
                            else
                            {
                                printf(" %08x", tmp[i]);
                            }
                        }
                        putchar('\n');
                    }
                };

                template <typename T>
                struct base32_numeric : base32<T>
                {
                    using super = base32<T>;
                    using vector_type = typename super::vector_type;

                    static simdutf_really_inline simd32<T> splat(T _value)
                    {
                        return vec_splats(_value);
                    }

                    static simdutf_really_inline simd32<T> zero() { return splat(0); }

                    template <typename U>
                    static simdutf_really_inline simd32<T> load(const U* values)
                    {
                        return vec_xl(0, reinterpret_cast<const T*>(values));
                    }

                    simdutf_really_inline base32_numeric()
                        : base32<T>()
                    {
                    }

                    simdutf_really_inline base32_numeric(const vector_type _value)
                        : base32<T>(_value)
                    {
                    }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd32<T> operator+(const simd32<T> other) const
                    {
                        return vec_add(this->value, other.value);
                    }

                    simdutf_really_inline simd32<T> operator-(const simd32<T> other) const
                    {
                        return vec_sub(this->value, other.value);
                    }

                    simdutf_really_inline simd32<T>& operator+=(const simd32<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd32<T>*>(this);
                    }

                    simdutf_really_inline simd32<T>& operator-=(const simd32<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd32<T>*>(this);
                    }
                };

                // Forward declaration
                template <typename>
                struct simd32;

                template <typename T>
                simd32<bool> operator==(const simd32<T> a, const simd32<T> b);

                template <typename T>
                simd32<bool> operator!=(const simd32<T> a, const simd32<T> b);

                template <typename T>
                simd32<bool> operator>(const simd32<T> a, const simd32<T> b);

                template <typename T>
                simd32<bool> operator==(const simd32<T> a, T b);

                template <typename T>
                simd32<bool> operator!=(const simd32<T> a, T b);

                template <typename T>
                simd32<T> operator&(const simd32<T> a, const simd32<T> b);

                template <typename T>
                simd32<T> operator|(const simd32<T> a, const simd32<T> b);

                template <typename T>
                simd32<T> operator^(const simd32<T> a, const simd32<T> b);

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd32<bool> : base32<bool>
                {
                    static simdutf_really_inline simd32<bool> splat(bool _value)
                    {
                        return (vector_type)vec_splats(uint32_t(-(!!_value)));
                    }

                    simdutf_really_inline simd32(const vector_type _value)
                        : base32<bool>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd32(bool _value)
                        : base32<bool>(splat(_value))
                    {
                    }

                    simdutf_really_inline uint16_t to_bitmask() const
                    {
                        return move_mask_u8(value);
                    }

                    simdutf_really_inline bool any() const
                    {
                        const vec_u64_t tmp = (vec_u64_t)value;

                        return tmp[0] || tmp[1]; // Note: logical or, not binary one
                    }

                    simdutf_really_inline bool is_zero() const
                    {
                        const vec_u64_t tmp = (vec_u64_t)value;

                        return (tmp[0] | tmp[1]) == 0;
                    }

                    simdutf_really_inline simd32<bool> operator~() const
                    {
                        return (vec_bool32_t)vec_xor(this->value, vec_splats(uint32_t(0xffffffff)));
                    }
                };

                // Unsigned code units
                template <>
                struct simd32<uint32_t> : base32_numeric<uint32_t>
                {
                    simdutf_really_inline simd32()
                        : base32_numeric<uint32_t>()
                    {
                    }

                    simdutf_really_inline simd32(const vector_type _value)
                        : base32_numeric<uint32_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd32(uint32_t _value)
                        : simd32(splat(_value))
                    {
                    }

                    // Array constructor
                    simdutf_really_inline simd32(const char32_t* values)
                        : simd32(load(reinterpret_cast<const uint32_t*>(values)))
                    {
                    }

                    // Bit-specific operations
                    template <int N>
                    simdutf_really_inline simd32<uint32_t> shr() const
                    {
                        return vec_sr(value, vec_splats(uint32_t(N)));
                    }

                    template <int N>
                    simdutf_really_inline simd32<uint32_t> shl() const
                    {
                        return vec_sl(value, vec_splats(uint32_t(N)));
                    }

                    // Change the endianness
                    simdutf_really_inline simd32<uint32_t> swap_bytes() const
                    {
                        return vec_revb(value);
                    }

                    simdutf_really_inline uint64_t sum() const
                    {
                        return uint64_t(value[0]) + uint64_t(value[1]) + uint64_t(value[2]) + uint64_t(value[3]);
                    }

                    static simdutf_really_inline simd16<uint16_t>
                    pack(const simd32<uint32_t>& v0, const simd32<uint32_t>& v1)
                    {
                        return vec_packs(v0.value, v1.value);
                    }
                };

                template <typename T>
                simd32<bool> operator==(const simd32<T> a, const simd32<T> b)
                {
                    return vec_cmpeq(a.value, b.value);
                }

                template <typename T>
                simd32<bool> operator!=(const simd32<T> a, const simd32<T> b)
                {
                    return vec_cmpne(a.value, b.value);
                }

                template <typename T>
                simd32<bool> operator==(const simd32<T> a, T b)
                {
                    return vec_cmpeq(a.value, vec_splats(b));
                }

                template <typename T>
                simd32<bool> operator!=(const simd32<T> a, T b)
                {
                    return vec_cmpne(a.value, vec_splats(b));
                }

                template <typename T>
                simd32<bool> operator>(const simd32<T> a, const simd32<T> b)
                {
                    return vec_cmpgt(a.value, b.value);
                }

                template <typename T>
                simd32<T> operator&(const simd32<T> a, const simd32<T> b)
                {
                    return vec_and(a.value, b.value);
                }

                template <typename T, typename U>
                simd32<T> operator&(const simd32<T> a, U b)
                {
                    return vec_and(a.value, vec_splats(T(b)));
                }

                template <typename T>
                simd32<T> operator|(const simd32<T> a, const simd32<T> b)
                {
                    return vec_or(a.value, b.value);
                }

                template <typename T>
                simd32<T> operator^(const simd32<T> a, const simd32<T> b)
                {
                    return vec_xor(a.value, b.value);
                }

                template <typename T, typename U>
                simd32<T> operator^(const simd32<T> a, U b)
                {
                    return vec_xor(a.value, vec_splats(T(b)));
                }

                template <typename T>
                simd32<T> max_val(const simd32<T> a, const simd32<T> b)
                {
                    return vec_max(a.value, b.value);
                }

                template <typename T>
                simdutf_really_inline simd32<T> min(const simd32<T> b, const simd32<T> a)
                {
                    return vec_min(a.value, b.value);
                }
                /* end file src/simdutf/ppc64/simd32-inl.h */

                template <typename T>
                simd8<T> select(const simd8<T> cond, const simd8<T> val_true,
                    const simd8<T> val_false)
                {
                    return vec_sel(val_false.value, val_true.value, cond.value);
                }

                template <typename T>
                simd8<T> select(const T cond, const simd8<T> val_true,
                    const simd8<T> val_false)
                {
                    return vec_sel(val_false.value, val_true.value, vec_splats(cond));
                }

                template <typename T>
                simd16<T> select(const simd16<T> cond, const simd16<T> val_true,
                    const simd16<T> val_false)
                {
                    return vec_sel(val_false.value, val_true.value, cond.value);
                }

                template <typename T>
                simd16<T> select(const T cond, const simd16<T> val_true,
                    const simd16<T> val_false)
                {
                    return vec_sel(val_false.value, val_true.value, vec_splats(cond));
                }

                template <typename T>
                simd32<T> select(const simd32<T> cond, const simd32<T> val_true,
                    const simd32<T> val_false)
                {
                    return vec_sel(val_false.value, val_true.value, cond.value);
                }

                template <typename T>
                simd32<T> select(const T cond, const simd32<T> val_true,
                    const simd32<T> val_false)
                {
                    return vec_sel(val_false.value, val_true.value, vec_splats(cond));
                }

                using vector_u8 = simd8<uint8_t>;
                using vector_u16 = simd16<uint16_t>;
                using vector_u32 = simd32<uint32_t>;
                using vector_i8 = simd8<int8_t>;

                simdutf_really_inline vector_u8 as_vector_u8(const vector_u16 v)
                {
                    return vector_u8::vector_type(v.value);
                }

                simdutf_really_inline vector_u8 as_vector_u8(const vector_u32 v)
                {
                    return vector_u8::vector_type(v.value);
                }

                simdutf_really_inline vector_u8 as_vector_u8(const vector_i8 v)
                {
                    return vector_u8::vector_type(v.value);
                }

                simdutf_really_inline vector_u8 as_vector_u8(const simd16<bool> v)
                {
                    return vector_u8::vector_type(v.value);
                }

                simdutf_really_inline vector_i8 as_vector_i8(const vector_u8 v)
                {
                    return vector_i8::vector_type(v.value);
                }

                simdutf_really_inline vector_u16 as_vector_u16(const vector_u8 v)
                {
                    return vector_u16::vector_type(v.value);
                }

                simdutf_really_inline vector_u16 as_vector_u16(const simd16<bool> v)
                {
                    return vector_u16::vector_type(v.value);
                }

                simdutf_really_inline vector_u32 as_vector_u32(const vector_u8 v)
                {
                    return vector_u32::vector_type(v.value);
                }

                simdutf_really_inline vector_u32 as_vector_u32(const vector_u16 v)
                {
                    return vector_u32::vector_type(v.value);
                }

                simdutf_really_inline vector_u32 max(vector_u32 a, vector_u32 b)
                {
                    return vec_max(a.value, b.value);
                }

                simdutf_really_inline vector_u32 max(vector_u32 a, vector_u32 b, vector_u32 c)
                {
                    return max(max(a, b), c);
                }

                simdutf_really_inline vector_u32 sum4bytes(vector_u8 bytes, vector_u32 acc)
                {
                    return vec_sum4s(bytes.value, acc.value);
                }

            } // namespace simd
        } // unnamed namespace
    } // namespace ppc64
} // namespace simdutf

        #endif // SIMDUTF_PPC64_SIMD_INPUT_H
    /* end file src/simdutf/ppc64/simd.h */

    /* begin file src/simdutf/ppc64/end.h */
    /* end file src/simdutf/ppc64/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_PPC64

#endif // SIMDUTF_PPC64_H
/* end file src/simdutf/ppc64.h */
/* begin file src/simdutf/rvv.h */
#ifndef SIMDUTF_RVV_H
    #define SIMDUTF_RVV_H

    #ifdef SIMDUTF_FALLBACK_H
        #error "rvv.h must be included before fallback.h"
    #endif

    #define SIMDUTF_CAN_ALWAYS_RUN_RVV SIMDUTF_IS_RVV

    #ifndef SIMDUTF_IMPLEMENTATION_RVV
        #define SIMDUTF_IMPLEMENTATION_RVV \
            (SIMDUTF_CAN_ALWAYS_RUN_RVV || (SIMDUTF_IS_RISCV64 && SIMDUTF_HAS_RVV_INTRINSICS && SIMDUTF_HAS_RVV_TARGET_REGION))
    #endif

    #if SIMDUTF_IMPLEMENTATION_RVV

        #if SIMDUTF_CAN_ALWAYS_RUN_RVV
            #define SIMDUTF_TARGET_RVV
        #else
            #define SIMDUTF_TARGET_RVV SIMDUTF_TARGET_REGION("arch=+v")
        #endif
        #if !SIMDUTF_IS_ZVBB && SIMDUTF_HAS_ZVBB_INTRINSICS
            #define SIMDUTF_TARGET_ZVBB SIMDUTF_TARGET_REGION("arch=+v,+zvbb")
        #endif

namespace simdutf
{
    namespace rvv
    {
    } // namespace rvv
} // namespace simdutf

        /* begin file src/simdutf/rvv/implementation.h */
        #ifndef SIMDUTF_RVV_IMPLEMENTATION_H
            #define SIMDUTF_RVV_IMPLEMENTATION_H

namespace simdutf
{
    namespace rvv
    {

        namespace
        {
            using namespace simdutf;
        } // namespace

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation("rvv", "RISC-V Vector Extension",
                      internal::instruction_set::RVV)
                , _supports_zvbb(internal::detect_supported_architectures() & internal::instruction_set::ZVBB)
            {
            }
            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;
            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;
            simdutf_warn_unused size_t
            utf32_length_from_utf8(const char* input, size_t length) const noexcept;

        private:
            const bool _supports_zvbb;

            #if SIMDUTF_IS_ZVBB
            bool supports_zvbb() const { return true; }
            #elif SIMDUTF_HAS_ZVBB_INTRINSICS
            bool supports_zvbb() const { return _supports_zvbb; }
            #else
            bool supports_zvbb() const { return false; }
            #endif
        };

    } // namespace rvv
} // namespace simdutf

        #endif // SIMDUTF_RVV_IMPLEMENTATION_H
    /* end file src/simdutf/rvv/implementation.h */
    /* begin file src/simdutf/rvv/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "rvv"
    // #define SIMDUTF_IMPLEMENTATION rvv

        #if SIMDUTF_CAN_ALWAYS_RUN_RVV
        // nothing needed.
        #else
SIMDUTF_TARGET_RVV
        #endif
        /* end file src/simdutf/rvv/begin.h */
        /* begin file src/simdutf/rvv/intrinsics.h */
        #ifndef SIMDUTF_RVV_INTRINSICS_H
            #define SIMDUTF_RVV_INTRINSICS_H

            #include <riscv_vector.h>

            #if __riscv_v_intrinsic >= 1000000 || __GCC__ >= 14
                #define simdutf_vrgather_u8m1x2(tbl, idx)                               \
                    __riscv_vcreate_v_u8m1_u8m2(                                        \
                        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 0), \
                            __riscv_vsetvlmax_e8m1()),                                  \
                        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 1), \
                            __riscv_vsetvlmax_e8m1()));

                #define simdutf_vrgather_u8m1x4(tbl, idx)                               \
                    __riscv_vcreate_v_u8m1_u8m4(                                        \
                        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 0), \
                            __riscv_vsetvlmax_e8m1()),                                  \
                        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 1), \
                            __riscv_vsetvlmax_e8m1()),                                  \
                        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 2), \
                            __riscv_vsetvlmax_e8m1()),                                  \
                        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 3), \
                            __riscv_vsetvlmax_e8m1()));
            #else
  // This has worse codegen on gcc
                #define simdutf_vrgather_u8m1x2(tbl, idx)                                      \
                    __riscv_vset_v_u8m1_u8m2(                                                  \
                        __riscv_vlmul_ext_v_u8m1_u8m2(__riscv_vrgather_vv_u8m1(                \
                            tbl, __riscv_vget_v_u8m2_u8m1(idx, 0), __riscv_vsetvlmax_e8m1())), \
                        1,                                                                     \
                        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m2_u8m1(idx, 1),        \
                            __riscv_vsetvlmax_e8m1()))

                #define simdutf_vrgather_u8m1x4(tbl, idx)                                   \
                    __riscv_vset_v_u8m1_u8m4(                                               \
                        __riscv_vset_v_u8m1_u8m4(                                           \
                            __riscv_vset_v_u8m1_u8m4(                                       \
                                __riscv_vlmul_ext_v_u8m1_u8m4(__riscv_vrgather_vv_u8m1(     \
                                    tbl, __riscv_vget_v_u8m4_u8m1(idx, 0),                  \
                                    __riscv_vsetvlmax_e8m1())),                             \
                                1,                                                          \
                                __riscv_vrgather_vv_u8m1(tbl,                               \
                                    __riscv_vget_v_u8m4_u8m1(idx, 1),                       \
                                    __riscv_vsetvlmax_e8m1())),                             \
                            2,                                                              \
                            __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 2), \
                                __riscv_vsetvlmax_e8m1())),                                 \
                        3,                                                                  \
                        __riscv_vrgather_vv_u8m1(tbl, __riscv_vget_v_u8m4_u8m1(idx, 3),     \
                            __riscv_vsetvlmax_e8m1()))
            #endif

/* Zvbb adds dedicated support for endianness swaps with vrev8, but if we can't
 * use that, we have to emulate it with the standard V extension.
 * Using LMUL=1 vrgathers could be faster than the srl+macc variant, but that
 * would increase register pressure, and vrgather implementations performance
 * varies a lot. */
enum class simdutf_ByteFlip
{
    NONE,
    V,
    ZVBB
};

template <simdutf_ByteFlip method>
simdutf_really_inline static uint16_t simdutf_byteflip(uint16_t v)
{
    if (method != simdutf_ByteFlip::NONE)
        return (uint16_t)((v * 1u) << 8 | (v * 1u) >> 8);
    return v;
}

            #ifdef SIMDUTF_TARGET_ZVBB
SIMDUTF_UNTARGET_REGION
SIMDUTF_TARGET_ZVBB
            #endif

template <simdutf_ByteFlip method>
simdutf_really_inline static vuint16m1_t simdutf_byteflip(vuint16m1_t v,
    size_t vl)
{
            #if SIMDUTF_HAS_ZVBB_INTRINSICS
    if (method == simdutf_ByteFlip::ZVBB)
        return __riscv_vrev8_v_u16m1(v, vl);
            #endif
    if (method == simdutf_ByteFlip::V)
        return __riscv_vmacc_vx_u16m1(__riscv_vsrl_vx_u16m1(v, 8, vl), 0x100, v,
            vl);
    return v;
}

template <simdutf_ByteFlip method>
simdutf_really_inline static vuint16m2_t simdutf_byteflip(vuint16m2_t v,
    size_t vl)
{
            #if SIMDUTF_HAS_ZVBB_INTRINSICS
    if (method == simdutf_ByteFlip::ZVBB)
        return __riscv_vrev8_v_u16m2(v, vl);
            #endif
    if (method == simdutf_ByteFlip::V)
        return __riscv_vmacc_vx_u16m2(__riscv_vsrl_vx_u16m2(v, 8, vl), 0x100, v,
            vl);
    return v;
}

template <simdutf_ByteFlip method>
simdutf_really_inline static vuint16m4_t simdutf_byteflip(vuint16m4_t v,
    size_t vl)
{
            #if SIMDUTF_HAS_ZVBB_INTRINSICS
    if (method == simdutf_ByteFlip::ZVBB)
        return __riscv_vrev8_v_u16m4(v, vl);
            #endif
    if (method == simdutf_ByteFlip::V)
        return __riscv_vmacc_vx_u16m4(__riscv_vsrl_vx_u16m4(v, 8, vl), 0x100, v,
            vl);
    return v;
}

template <simdutf_ByteFlip method>
simdutf_really_inline static vuint16m8_t simdutf_byteflip(vuint16m8_t v,
    size_t vl)
{
            #if SIMDUTF_HAS_ZVBB_INTRINSICS
    if (method == simdutf_ByteFlip::ZVBB)
        return __riscv_vrev8_v_u16m8(v, vl);
            #endif
    if (method == simdutf_ByteFlip::V)
        return __riscv_vmacc_vx_u16m8(__riscv_vsrl_vx_u16m8(v, 8, vl), 0x100, v,
            vl);
    return v;
}

            #ifdef SIMDUTF_TARGET_ZVBB
SIMDUTF_UNTARGET_REGION
SIMDUTF_TARGET_RVV
            #endif

        #endif //  SIMDUTF_RVV_INTRINSICS_H
        /* end file src/simdutf/rvv/intrinsics.h */
        /* begin file src/simdutf/rvv/end.h */
        #if SIMDUTF_CAN_ALWAYS_RUN_RVV
        // nothing needed.
        #else
SIMDUTF_UNTARGET_REGION
        #endif

    /* end file src/simdutf/rvv/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_RVV

#endif // SIMDUTF_RVV_H
/* end file src/simdutf/rvv.h */
/* begin file src/simdutf/lsx.h */
#ifndef SIMDUTF_LSX_H
    #define SIMDUTF_LSX_H

    #ifdef SIMDUTF_FALLBACK_H
        #error "lsx.h must be included before fallback.h"
    #endif

    #ifndef SIMDUTF_IMPLEMENTATION_LSX
        #define SIMDUTF_IMPLEMENTATION_LSX (SIMDUTF_IS_LSX)
    #endif
    #if SIMDUTF_IMPLEMENTATION_LSX && SIMDUTF_IS_LSX
        #define SIMDUTF_CAN_ALWAYS_RUN_LSX 1
    #else
        #define SIMDUTF_CAN_ALWAYS_RUN_LSX 0
    #endif

    #define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)

    #if SIMDUTF_IMPLEMENTATION_LSX

namespace simdutf
{
    /**
     * Implementation for LoongArch SX.
     */
    namespace lsx
    {
    } // namespace lsx
} // namespace simdutf

        /* begin file src/simdutf/lsx/implementation.h */
        #ifndef SIMDUTF_LSX_IMPLEMENTATION_H
            #define SIMDUTF_LSX_IMPLEMENTATION_H

namespace simdutf
{
    namespace lsx
    {

        namespace
        {
            using namespace simdutf;
        }

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation("lsx", "LOONGARCH SX",
                      internal::instruction_set::LSX)
            {
            }
            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;
            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;
        };

    } // namespace lsx
} // namespace simdutf

        #endif // SIMDUTF_LSX_IMPLEMENTATION_H
        /* end file src/simdutf/lsx/implementation.h */

        /* begin file src/simdutf/lsx/begin.h */
        // redefining SIMDUTF_IMPLEMENTATION to "lsx"
        // #define SIMDUTF_IMPLEMENTATION lsx
        #define SIMDUTF_SIMD_HAS_UNSIGNED_CMP 1
    /* end file src/simdutf/lsx/begin.h */

    // Declarations
        /* begin file src/simdutf/lsx/intrinsics.h */
        #ifndef SIMDUTF_LSX_INTRINSICS_H
            #define SIMDUTF_LSX_INTRINSICS_H

            // This should be the correct header whether
            // you use visual studio or other compilers.
            #include <lsxintrin.h>

/*
Encoding of argument for LoongArch64 xvldi instruction.  See:
https://jia.je/unofficial-loongarch-intrinsics-guide/lasx/misc/#__m256i-__lasx_xvldi-imm_n1024_1023-imm

1: imm[12:8]=0b10000: broadcast imm[7:0] as 32-bit elements to all lanes

2: imm[12:8]=0b10001: broadcast imm[7:0] << 8 as 32-bit elements to all lanes

3: imm[12:8]=0b10010: broadcast imm[7:0] << 16 as 32-bit elements to all lanes

4: imm[12:8]=0b10011: broadcast imm[7:0] << 24 as 32-bit elements to all lanes

5: imm[12:8]=0b10100: broadcast imm[7:0] as 16-bit elements to all lanes

6: imm[12:8]=0b10101: broadcast imm[7:0] << 8 as 16-bit elements to all lanes

7: imm[12:8]=0b10110: broadcast (imm[7:0] << 8) | 0xFF as 32-bit elements to all
lanes

8: imm[12:8]=0b10111: broadcast (imm[7:0] << 16) | 0xFFFF as 32-bit elements to
all lanes

9: imm[12:8]=0b11000: broadcast imm[7:0] as 8-bit elements to all lanes

10: imm[12:8]=0b11001: repeat each bit of imm[7:0] eight times, and broadcast
the result as 64-bit elements to all lanes
*/

namespace vldi
{

    template <uint16_t v>
    class const_u16
    {
        constexpr static const uint8_t b0 = ((v >> 0 * 8) & 0xff);
        constexpr static const uint8_t b1 = ((v >> 1 * 8) & 0xff);

        constexpr static bool is_case5 = uint16_t(b0) == v;
        constexpr static bool is_case6 = (uint16_t(b1) << 8) == v;
        constexpr static bool is_case9 = (b0 == b1);
        constexpr static bool is_case10 = ((b0 == 0xff) || (b0 == 0x00)) && ((b1 == 0xff) || (b1 == 0x00));

    public:
        constexpr static uint16_t operation = is_case5 ? 0b10100
            : is_case6                                 ? 0b10101
            : is_case9                                 ? 0b11000
            : is_case10                                ? 0x11001
                                                       : 0xffff;

        constexpr static uint16_t byte = is_case5 ? b0
            : is_case6                            ? b1
            : is_case9                            ? b0
            : is_case10                           ? ((b0 ? 0x55 : 0x00) | (b1 ? 0xaa : 0x00))
                                                  : 0xffff;

        constexpr static int value = int((operation << 8) | byte) - 8192;
        constexpr static bool valid = operation != 0xffff;
    };

    template <uint32_t v>
    class const_u32
    {
        constexpr static const uint8_t b0 = (v & 0xff);
        constexpr static const uint8_t b1 = ((v >> 8) & 0xff);
        constexpr static const uint8_t b2 = ((v >> 16) & 0xff);
        constexpr static const uint8_t b3 = ((v >> 24) & 0xff);

        constexpr static bool is_case1 = (uint32_t(b0) == v);
        constexpr static bool is_case2 = ((uint32_t(b1) << 8) == v);
        constexpr static bool is_case3 = ((uint32_t(b2) << 16) == v);
        constexpr static bool is_case4 = ((uint32_t(b3) << 24) == v);
        constexpr static bool is_case5 = (b0 == b2) && (b1 == 0) && (b3 == 0);
        constexpr static bool is_case6 = (b1 == b3) && (b0 == 0) && (b2 == 0);
        constexpr static bool is_case7 = (b3 == 0) && (b2 == 0) && (b0 == 0xff);
        constexpr static bool is_case8 = (b3 == 0) && (b1 == 0xff) && (b0 == 0xff);
        constexpr static bool is_case9 = (b0 == b1) && (b0 == b2) && (b0 == b3);
        constexpr static bool is_case10 = ((b0 == 0xff) || (b0 == 0x00)) && ((b1 == 0xff) || (b1 == 0x00)) && ((b2 == 0xff) || (b2 == 0x00)) && ((b3 == 0xff) || (b3 == 0x00));

    public:
        constexpr static uint16_t operation = is_case1 ? 0b10000
            : is_case2                                 ? 0b10001
            : is_case3                                 ? 0b10010
            : is_case4                                 ? 0b10011
            : is_case5                                 ? 0b10100
            : is_case6                                 ? 0b10101
            : is_case7                                 ? 0b10110
            : is_case8                                 ? 0b10111
            : is_case9                                 ? 0b11000
            : is_case10                                ? 0b11001
                                                       : 0xffff;

        constexpr static uint16_t byte = is_case1 ? b0
            : is_case2                            ? b1
            : is_case3                            ? b2
            : is_case4                            ? b3
            : is_case5                            ? b0
            : is_case6                            ? b1
            : is_case7                            ? b1
            : is_case8                            ? b2
            : is_case9                            ? b0
            : is_case10                           ? ((b0 ? 0x11 : 0x00) | (b1 ? 0x22 : 0x00) | (b2 ? 0x44 : 0x00) | (b3 ? 0x88 : 0x00))
                                                  : 0xffff;

        constexpr static int value = int((operation << 8) | byte) - 8192;
        constexpr static bool valid = operation != 0xffff;
    };

    template <uint64_t v>
    class const_u64
    {
        constexpr static const uint8_t b0 = ((v >> 0 * 8) & 0xff);
        constexpr static const uint8_t b1 = ((v >> 1 * 8) & 0xff);
        constexpr static const uint8_t b2 = ((v >> 2 * 8) & 0xff);
        constexpr static const uint8_t b3 = ((v >> 3 * 8) & 0xff);
        constexpr static const uint8_t b4 = ((v >> 4 * 8) & 0xff);
        constexpr static const uint8_t b5 = ((v >> 5 * 8) & 0xff);
        constexpr static const uint8_t b6 = ((v >> 6 * 8) & 0xff);
        constexpr static const uint8_t b7 = ((v >> 7 * 8) & 0xff);

        constexpr static bool is_case10 = ((b0 == 0xff) || (b0 == 0x00)) && ((b1 == 0xff) || (b1 == 0x00)) && ((b2 == 0xff) || (b2 == 0x00)) && ((b3 == 0xff) || (b3 == 0x00)) && ((b4 == 0xff) || (b4 == 0x00)) && ((b5 == 0xff) || (b5 == 0x00)) && ((b6 == 0xff) || (b6 == 0x00)) && ((b7 == 0xff) || (b7 == 0x00));

    public:
        constexpr static bool is_32bit = ((v & 0xffffffff) == (v >> 32)) && const_u32<(v >> 32)>::value;
        constexpr static uint8_t op_32bit = const_u32<(v >> 32)>::operation;
        constexpr static uint8_t byte_32bit = const_u32<(v >> 32)>::byte;

        constexpr static uint16_t operation = is_32bit ? op_32bit
            : is_case10                                ? 0x11001
                                                       : 0xffff;

        constexpr static uint16_t byte = is_32bit ? byte_32bit
            : is_case10
            ? ((b0 ? 0x01 : 0x00) | (b1 ? 0x02 : 0x00) | (b2 ? 0x04 : 0x00) | (b3 ? 0x08 : 0x00) | (b4 ? 0x10 : 0x00) | (b5 ? 0x20 : 0x00) | (b6 ? 0x40 : 0x00) | (b7 ? 0x80 : 0x00))
            : 0xffff;

        constexpr static int value = int((operation << 8) | byte) - 8192;
        constexpr static bool valid = operation != 0xffff;
    };
} // namespace vldi

            // Uncomment when running under QEMU affected
            // by bug https://gitlab.com/qemu-project/qemu/-/issues/2865
            // Versions <= 9.2.2 are affected, likely anything newer is correct.
            #ifndef QEMU_VLDI_BUG
            // #define QEMU_VLDI_BUG 1
            #endif

            #ifdef QEMU_VLDI_BUG
                #define lsx_splat_u16(v) __lsx_vreplgr2vr_h(v)
                #define lsx_splat_u32(v) __lsx_vreplgr2vr_w(v)
            #else
template <uint16_t x>
constexpr __m128i lsx_splat_u16_aux()
{
    constexpr bool is_imm10 = (int16_t(x) < 512) && (int16_t(x) > -512);
    constexpr uint16_t imm10 = is_imm10 ? x : 0;
    constexpr bool is_vldi = vldi::const_u16<x>::valid;
    constexpr int vldi_imm = is_vldi ? vldi::const_u16<x>::value : 0;

    return is_imm10 ? __lsx_vrepli_h(int16_t(imm10))
        : is_vldi   ? __lsx_vldi(vldi_imm)
                    : __lsx_vreplgr2vr_h(x);
}

template <uint32_t x>
constexpr __m128i lsx_splat_u32_aux()
{
    constexpr bool is_imm10 = (int32_t(x) < 512) && (int32_t(x) > -512);
    constexpr uint32_t imm10 = is_imm10 ? x : 0;
    constexpr bool is_vldi = vldi::const_u32<x>::valid;
    constexpr int vldi_imm = is_vldi ? vldi::const_u32<x>::value : 0;

    return is_imm10 ? __lsx_vrepli_w(int32_t(imm10))
        : is_vldi   ? __lsx_vldi(vldi_imm)
                    : __lsx_vreplgr2vr_w(x);
}

                #define lsx_splat_u16(v) lsx_splat_u16_aux<(v)>()
                #define lsx_splat_u32(v) lsx_splat_u32_aux<(v)>()
            #endif // QEMU_VLDI_BUG

        #endif //  SIMDUTF_LSX_INTRINSICS_H
        /* end file src/simdutf/lsx/intrinsics.h */
        /* begin file src/simdutf/lsx/bitmanipulation.h */
        #ifndef SIMDUTF_LSX_BITMANIPULATION_H
            #define SIMDUTF_LSX_BITMANIPULATION_H

            #include <limits>

namespace simdutf
{
    namespace lsx
    {
        namespace
        {

            simdutf_really_inline int count_ones(uint64_t input_num)
            {
                return __lsx_vpickve2gr_w(__lsx_vpcnt_d(__lsx_vreplgr2vr_d(input_num)), 0);
            }

            #if SIMDUTF_NEED_TRAILING_ZEROES
            // simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
            //   return __builtin_ctzll(input_num);
            // }
            #endif

        } // unnamed namespace
    } // namespace lsx
} // namespace simdutf

        #endif // SIMDUTF_LSX_BITMANIPULATION_H
        /* end file src/simdutf/lsx/bitmanipulation.h */
        /* begin file src/simdutf/lsx/simd.h */
        #ifndef SIMDUTF_LSX_SIMD_H
            #define SIMDUTF_LSX_SIMD_H

            #include <type_traits>

namespace simdutf
{
    namespace lsx
    {
        namespace
        {
            namespace simd
            {

                template <typename T>
                struct simd8;

                //
                // Base class of simd8<uint8_t> and simd8<bool>, both of which use __m128i
                // internally.
                //
                template <typename T, typename Mask = simd8<bool>>
                struct base_u8
                {
                    __m128i value;
                    static const int SIZE = sizeof(value);

                    // Conversion from/to SIMD register
                    simdutf_really_inline base_u8(const __m128i _value)
                        : value(_value)
                    {
                    }
                    simdutf_really_inline operator const __m128i&() const { return this->value; }
                    simdutf_really_inline operator __m128i&() { return this->value; }
                    simdutf_really_inline T first() const
                    {
                        return __lsx_vpickve2gr_bu(this->value, 0);
                    }
                    simdutf_really_inline T last() const
                    {
                        return __lsx_vpickve2gr_bu(this->value, 15);
                    }

                    // Bit operations
                    simdutf_really_inline simd8<T> operator|(const simd8<T> other) const
                    {
                        return __lsx_vor_v(this->value, other);
                    }
                    simdutf_really_inline simd8<T> operator&(const simd8<T> other) const
                    {
                        return __lsx_vand_v(this->value, other);
                    }
                    simdutf_really_inline simd8<T> operator^(const simd8<T> other) const
                    {
                        return __lsx_vxor_v(this->value, other);
                    }
                    simdutf_really_inline simd8<T> bit_andnot(const simd8<T> other) const
                    {
                        return __lsx_vandn_v(this->value, other);
                    }
                    simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }
                    simdutf_really_inline simd8<T>& operator|=(const simd8<T> other)
                    {
                        auto this_cast = static_cast<simd8<T>*>(this);
                        *this_cast = *this_cast | other;
                        return *this_cast;
                    }
                    simdutf_really_inline simd8<T>& operator&=(const simd8<T> other)
                    {
                        auto this_cast = static_cast<simd8<T>*>(this);
                        *this_cast = *this_cast & other;
                        return *this_cast;
                    }
                    simdutf_really_inline simd8<T>& operator^=(const simd8<T> other)
                    {
                        auto this_cast = static_cast<simd8<T>*>(this);
                        *this_cast = *this_cast ^ other;
                        return *this_cast;
                    }

                    friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
                        const simd8<T> rhs)
                    {
                        return __lsx_vseq_b(lhs, rhs);
                    }

                    template <int N = 1>
                    simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const
                    {
                        return __lsx_vor_v(__lsx_vbsll_v(this->value, N),
                            __lsx_vbsrl_v(prev_chunk.value, 16 - N));
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd8<bool> : base_u8<bool>
                {
                    typedef uint16_t bitmask_t;
                    typedef uint32_t bitmask2_t;

                    static simdutf_really_inline simd8<bool> splat(bool _value)
                    {
                        return __lsx_vreplgr2vr_b(uint8_t(-(!!_value)));
                    }

                    simdutf_really_inline simd8(const __m128i _value)
                        : base_u8<bool>(_value)
                    {
                    }
                    // False constructor
                    simdutf_really_inline simd8()
                        : simd8(__lsx_vldi(0))
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(bool _value)
                        : simd8(splat(_value))
                    {
                    }
                    simdutf_really_inline void store(uint8_t dst[16]) const
                    {
                        return __lsx_vst(this->value, dst, 0);
                    }

                    simdutf_really_inline uint32_t to_bitmask() const
                    {
                        return __lsx_vpickve2gr_wu(__lsx_vmsknz_b(*this), 0);
                    }

                    simdutf_really_inline bool any() const
                    {
                        return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) != 0;
                    }
                    simdutf_really_inline bool none() const
                    {
                        return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) == 0;
                    }
                    simdutf_really_inline bool all() const
                    {
                        return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(*this), 0) == 0xFFFF;
                    }
                };

                // Unsigned bytes
                template <>
                struct simd8<uint8_t> : base_u8<uint8_t>
                {
                    static simdutf_really_inline simd8<uint8_t> splat(uint8_t _value)
                    {
                        return __lsx_vreplgr2vr_b(_value);
                    }
                    static simdutf_really_inline simd8<uint8_t> zero() { return __lsx_vldi(0); }
                    static simdutf_really_inline simd8<uint8_t> load(const uint8_t* values)
                    {
                        return __lsx_vld(values, 0);
                    }
                    simdutf_really_inline simd8(const __m128i _value)
                        : base_u8<uint8_t>(_value)
                    {
                    }
                    // Zero constructor
                    simdutf_really_inline simd8()
                        : simd8(zero())
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const uint8_t values[16])
                        : simd8(load(values))
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(uint8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Member-by-member initialization

                    simdutf_really_inline
                    simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
                        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
                        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15)
                        : simd8((__m128i)v16u8 { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                              v12, v13, v14, v15 })
                    {
                    }

                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<uint8_t>
                    repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
                        uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
                        uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
                        uint8_t v15)
                    {
                        return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15);
                    }

                    // Store to array
                    simdutf_really_inline void store(uint8_t dst[16]) const
                    {
                        return __lsx_vst(this->value, dst, 0);
                    }

                    // Saturated math
                    simdutf_really_inline simd8<uint8_t>
                    saturating_add(const simd8<uint8_t> other) const
                    {
                        return __lsx_vsadd_bu(this->value, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    saturating_sub(const simd8<uint8_t> other) const
                    {
                        return __lsx_vssub_bu(this->value, other);
                    }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd8<uint8_t>
                    operator+(const simd8<uint8_t> other) const
                    {
                        return __lsx_vadd_b(this->value, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    operator-(const simd8<uint8_t> other) const
                    {
                        return __lsx_vsub_b(this->value, other);
                    }
                    simdutf_really_inline simd8<uint8_t>& operator+=(const simd8<uint8_t> other)
                    {
                        *this = *this + other;
                        return *this;
                    }
                    simdutf_really_inline simd8<uint8_t>& operator-=(const simd8<uint8_t> other)
                    {
                        *this = *this - other;
                        return *this;
                    }

                    // Order-specific operations
                    simdutf_really_inline simd8<uint8_t>
                    max_val(const simd8<uint8_t> other) const
                    {
                        return __lsx_vmax_bu(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    min_val(const simd8<uint8_t> other) const
                    {
                        return __lsx_vmin_bu(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator<=(const simd8<uint8_t> other) const
                    {
                        return __lsx_vsle_bu(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator>=(const simd8<uint8_t> other) const
                    {
                        return __lsx_vsle_bu(other, *this);
                    }
                    simdutf_really_inline simd8<bool>
                    operator<(const simd8<uint8_t> other) const
                    {
                        return __lsx_vslt_bu(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator>(const simd8<uint8_t> other) const
                    {
                        return __lsx_vslt_bu(other, *this);
                    }
                    // Same as >, but instead of guaranteeing all 1's == true, false = 0 and true
                    // = nonzero. For ARM, returns all 1's.
                    simdutf_really_inline simd8<uint8_t>
                    gt_bits(const simd8<uint8_t> other) const
                    {
                        return simd8<uint8_t>(*this > other);
                    }
                    // Same as <, but instead of guaranteeing all 1's == true, false = 0 and true
                    // = nonzero. For ARM, returns all 1's.
                    simdutf_really_inline simd8<uint8_t>
                    lt_bits(const simd8<uint8_t> other) const
                    {
                        return simd8<uint8_t>(*this < other);
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const
                    {
                        return __lsx_vslt_bu(__lsx_vldi(0), __lsx_vand_v(this->value, bits));
                    }
                    simdutf_really_inline bool is_ascii() const
                    {
                        return __lsx_vpickve2gr_hu(__lsx_vmskgez_b(this->value), 0) == 0xFFFF;
                    }

                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        return __lsx_vpickve2gr_hu(__lsx_vmsknz_b(this->value), 0) > 0;
                    }
                    simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const
                    {
                        return (*this & bits).any_bits_set_anywhere();
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shr() const
                    {
                        return __lsx_vsrli_b(this->value, N);
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shl() const
                    {
                        return __lsx_vslli_b(this->value, N);
                    }

                    // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
                    // for out of range values)
                    template <typename L>
                    simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const
                    {
                        return lookup_table.apply_lookup_16_to(*this);
                    }

                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
                        L replace5, L replace6, L replace7, L replace8, L replace9,
                        L replace10, L replace11, L replace12, L replace13, L replace14,
                        L replace15) const
                    {
                        return lookup_16(simd8<L>::repeat_16(
                            replace0, replace1, replace2, replace3, replace4, replace5, replace6,
                            replace7, replace8, replace9, replace10, replace11, replace12,
                            replace13, replace14, replace15));
                    }

                    template <typename T>
                    simdutf_really_inline simd8<uint8_t>
                    apply_lookup_16_to(const simd8<T> original) const
                    {
                        __m128i original_tmp = __lsx_vand_v(original, __lsx_vldi(0x1f));
                        return __lsx_vshuf_b(__lsx_vldi(0), *this, simd8<uint8_t>(original_tmp));
                    }
                };

                // Signed bytes
                template <>
                struct simd8<int8_t>
                {
                    __m128i value;

                    static simdutf_really_inline simd8<int8_t> splat(int8_t _value)
                    {
                        return __lsx_vreplgr2vr_b(_value);
                    }
                    static simdutf_really_inline simd8<int8_t> zero() { return __lsx_vldi(0); }
                    static simdutf_really_inline simd8<int8_t> load(const int8_t values[16])
                    {
                        return __lsx_vld(values, 0);
                    }

                    template <endianness big_endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* p) const
                    {
                        __m128i zero = __lsx_vldi(0);
                        if (match_system(big_endian))
                        {
                            __lsx_vst(__lsx_vilvl_b(zero, (__m128i)this->value),
                                reinterpret_cast<uint16_t*>(p), 0);
                            __lsx_vst(__lsx_vilvh_b(zero, (__m128i)this->value),
                                reinterpret_cast<uint16_t*>(p + 8), 0);
                        }
                        else
                        {
                            __lsx_vst(__lsx_vilvl_b((__m128i)this->value, zero),
                                reinterpret_cast<uint16_t*>(p), 0);
                            __lsx_vst(__lsx_vilvh_b((__m128i)this->value, zero),
                                reinterpret_cast<uint16_t*>(p + 8), 0);
                        }
                    }

                    simdutf_really_inline void store_ascii_as_utf32(char32_t* p) const
                    {
                        __m128i zero = __lsx_vldi(0);
                        __m128i in16low = __lsx_vilvl_b(zero, (__m128i)this->value);
                        __m128i in16high = __lsx_vilvh_b(zero, (__m128i)this->value);
                        __m128i in32_0 = __lsx_vilvl_h(zero, in16low);
                        __m128i in32_1 = __lsx_vilvh_h(zero, in16low);
                        __m128i in32_2 = __lsx_vilvl_h(zero, in16high);
                        __m128i in32_3 = __lsx_vilvh_h(zero, in16high);
                        __lsx_vst(in32_0, reinterpret_cast<uint32_t*>(p), 0);
                        __lsx_vst(in32_1, reinterpret_cast<uint32_t*>(p + 4), 0);
                        __lsx_vst(in32_2, reinterpret_cast<uint32_t*>(p + 8), 0);
                        __lsx_vst(in32_3, reinterpret_cast<uint32_t*>(p + 12), 0);
                    }

                    // In places where the table can be reused, which is most uses in simdutf, it
                    // is worth it to do 4 table lookups, as there is no direct zero extension
                    // from u8 to u32.
                    simdutf_really_inline void store_ascii_as_utf32_tbl(char32_t* p) const
                    {
                        const simd8<uint8_t> tb1 { 0, 255, 255, 255, 1, 255, 255, 255,
                            2, 255, 255, 255, 3, 255, 255, 255 };
                        const simd8<uint8_t> tb2 { 4, 255, 255, 255, 5, 255, 255, 255,
                            6, 255, 255, 255, 7, 255, 255, 255 };
                        const simd8<uint8_t> tb3 { 8, 255, 255, 255, 9, 255, 255, 255,
                            10, 255, 255, 255, 11, 255, 255, 255 };
                        const simd8<uint8_t> tb4 { 12, 255, 255, 255, 13, 255, 255, 255,
                            14, 255, 255, 255, 15, 255, 255, 255 };

                        // encourage store pairing and interleaving
                        const auto shuf1 = this->apply_lookup_16_to(tb1);
                        const auto shuf2 = this->apply_lookup_16_to(tb2);
                        shuf1.store(reinterpret_cast<int8_t*>(p));
                        shuf2.store(reinterpret_cast<int8_t*>(p + 4));

                        const auto shuf3 = this->apply_lookup_16_to(tb3);
                        const auto shuf4 = this->apply_lookup_16_to(tb4);
                        shuf3.store(reinterpret_cast<int8_t*>(p + 8));
                        shuf4.store(reinterpret_cast<int8_t*>(p + 12));
                    }
                    // Conversion from/to SIMD register
                    simdutf_really_inline simd8(const __m128i _value)
                        : value(_value)
                    {
                    }
                    simdutf_really_inline operator const __m128i&() const { return this->value; }

                    simdutf_really_inline operator const __m128i() const { return this->value; }

                    simdutf_really_inline operator __m128i&() { return this->value; }

                    // Zero constructor
                    simdutf_really_inline simd8()
                        : simd8(zero())
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(int8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const int8_t* values)
                        : simd8(load(values))
                    {
                    }
                    // Member-by-member initialization

                    simdutf_really_inline simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3,
                        int8_t v4, int8_t v5, int8_t v6, int8_t v7,
                        int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                        : simd8((__m128i)v16i8 { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                              v12, v13, v14, v15 })
                    {
                    }

                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<int8_t>
                    repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
                        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                    {
                        return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15);
                    }

                    // Store to array
                    simdutf_really_inline void store(int8_t dst[16]) const
                    {
                        return __lsx_vst(value, dst, 0);
                    }

                    simdutf_really_inline operator simd8<uint8_t>() const
                    {
                        return ((__m128i)this->value);
                    }

                    simdutf_really_inline simd8<int8_t>
                    operator|(const simd8<int8_t> other) const
                    {
                        return __lsx_vor_v((__m128i)value, (__m128i)other.value);
                    }
                    simdutf_really_inline simd8<int8_t>
                    operator&(const simd8<int8_t> other) const
                    {
                        return __lsx_vand_v((__m128i)value, (__m128i)other.value);
                    }
                    simdutf_really_inline simd8<int8_t>
                    operator^(const simd8<int8_t> other) const
                    {
                        return __lsx_vxor_v((__m128i)value, (__m128i)other.value);
                    }
                    simdutf_really_inline simd8<int8_t>
                    bit_andnot(const simd8<int8_t> other) const
                    {
                        return __lsx_vandn_v((__m128i)other.value, (__m128i)value);
                    }

                    // Math
                    simdutf_really_inline simd8<int8_t>
                    operator+(const simd8<int8_t> other) const
                    {
                        return __lsx_vadd_b((__m128i)value, (__m128i)other.value);
                    }
                    simdutf_really_inline simd8<int8_t>
                    operator-(const simd8<int8_t> other) const
                    {
                        return __lsx_vsub_b((__m128i)value, (__m128i)other.value);
                    }
                    simdutf_really_inline simd8<int8_t>& operator+=(const simd8<int8_t> other)
                    {
                        *this = *this + other;
                        return *this;
                    }
                    simdutf_really_inline simd8<int8_t>& operator-=(const simd8<int8_t> other)
                    {
                        *this = *this - other;
                        return *this;
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return (__lsx_vpickve2gr_hu(__lsx_vmskgez_b((__m128i)this->value), 0) == 0xffff);
                    }

                    // Order-sensitive comparisons
                    simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const
                    {
                        return __lsx_vmax_b((__m128i)value, (__m128i)other.value);
                    }
                    simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const
                    {
                        return __lsx_vmin_b((__m128i)value, (__m128i)other.value);
                    }
                    simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const
                    {
                        return __lsx_vslt_b((__m128i)other.value, (__m128i)value);
                    }
                    simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const
                    {
                        return __lsx_vslt_b((__m128i)value, (__m128i)other.value);
                    }
                    simdutf_really_inline simd8<bool>
                    operator==(const simd8<int8_t> other) const
                    {
                        return __lsx_vseq_b((__m128i)value, (__m128i)other.value);
                    }

                    template <int N = 1>
                    simdutf_really_inline simd8<int8_t>
                    prev(const simd8<int8_t> prev_chunk) const
                    {
                        return __lsx_vor_v(__lsx_vbsll_v(this->value, N),
                            __lsx_vbsrl_v(prev_chunk.value, 16 - N));
                    }

                    // Perform a lookup assuming no value is larger than 16
                    template <typename L>
                    simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const
                    {
                        return lookup_table.apply_lookup_16_to(*this);
                    }
                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
                        L replace5, L replace6, L replace7, L replace8, L replace9,
                        L replace10, L replace11, L replace12, L replace13, L replace14,
                        L replace15) const
                    {
                        return lookup_16(simd8<L>::repeat_16(
                            replace0, replace1, replace2, replace3, replace4, replace5, replace6,
                            replace7, replace8, replace9, replace10, replace11, replace12,
                            replace13, replace14, replace15));
                    }

                    template <typename T>
                    simdutf_really_inline simd8<int8_t>
                    apply_lookup_16_to(const simd8<T> original) const
                    {
                        __m128i original_tmp = __lsx_vand_v(original, __lsx_vldi(0x1f));
                        return __lsx_vshuf_b(__lsx_vldi(0), (__m128i)this->value,
                            simd8<uint8_t>(original_tmp));
                    }
                };

                template <typename T>
                struct simd8x64
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
                    static_assert(
                        NUM_CHUNKS == 4,
                        "LoongArch kernel should use four registers per 64-byte block.");
                    simd8<T> chunks[NUM_CHUNKS];

                    simd8x64(const simd8x64<T>& o) = delete; // no copy allowed
                    simd8x64<T>&
                    operator=(const simd8<T> other)
                        = delete; // no assignment allowed
                    simd8x64() = delete; // no default constructor allowed

                    simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1,
                        const simd8<T> chunk2, const simd8<T> chunk3)
                        : chunks { chunk0, chunk1, chunk2, chunk3 }
                    {
                    }
                    simdutf_really_inline simd8x64(const T* ptr)
                        : chunks { simd8<T>::load(ptr),
                            simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)),
                            simd8<T>::load(ptr + 2 * sizeof(simd8<T>) / sizeof(T)),
                            simd8<T>::load(ptr + 3 * sizeof(simd8<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
                        this->chunks[2].store(ptr + sizeof(simd8<T>) * 2 / sizeof(T));
                        this->chunks[3].store(ptr + sizeof(simd8<T>) * 3 / sizeof(T));
                    }

                    simdutf_really_inline simd8x64<T>& operator|=(const simd8x64<T>& other)
                    {
                        this->chunks[0] |= other.chunks[0];
                        this->chunks[1] |= other.chunks[1];
                        this->chunks[2] |= other.chunks[2];
                        this->chunks[3] |= other.chunks[3];
                        return *this;
                    }

                    simdutf_really_inline simd8<T> reduce_or() const
                    {
                        return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);
                    }

                    simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }

                    template <endianness endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 1);
                        this->chunks[2].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 2);
                        this->chunks[3].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 3);
                    }

                    simdutf_really_inline void store_ascii_as_utf32(char32_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 1);
                        this->chunks[2].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 2);
                        this->chunks[3].store_ascii_as_utf32_tbl(ptr + sizeof(simd8<T>) * 3);
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        __m128i mask = __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[3]), 6);
                        mask = __lsx_vor_v(mask, __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[2]), 4));
                        mask = __lsx_vor_v(mask, __lsx_vbsll_v(__lsx_vmsknz_b(this->chunks[1]), 2));
                        mask = __lsx_vor_v(mask, __lsx_vmsknz_b(this->chunks[0]));
                        return __lsx_vpickve2gr_du(mask, 0);
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
                            this->chunks[2] == mask, this->chunks[3] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
                            this->chunks[2] <= mask, this->chunks[3] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);

                        return simd8x64<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
                            (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
                            (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);
                        return simd8x64<bool>(
                            (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
                            (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
                            (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
                            (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
                            this->chunks[2] < mask, this->chunks[3] < mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask,
                            this->chunks[2] > mask, this->chunks[3] > mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask,
                            this->chunks[2] >= mask, this->chunks[3] >= mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const
                    {
                        const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
                        return simd8x64<bool>(simd8<uint8_t>(this->chunks[0].value) >= mask,
                            simd8<uint8_t>(this->chunks[1].value) >= mask,
                            simd8<uint8_t>(this->chunks[2].value) >= mask,
                            simd8<uint8_t>(this->chunks[3].value) >= mask)
                            .to_bitmask();
                    }
                }; // struct simd8x64<T>

                /* begin file src/simdutf/lsx/simd16-inl.h */
                template <typename T>
                struct simd16;

                template <typename T, typename Mask = simd16<bool>>
                struct base_u16
                {
                    __m128i value;
                    static const int SIZE = sizeof(value);

                    // Conversion from/to SIMD register
                    simdutf_really_inline base_u16() = default;
                    simdutf_really_inline base_u16(const __m128i _value)
                        : value(_value)
                    {
                    }
                    // Bit operations
                    simdutf_really_inline simd16<T> operator|(const simd16<T> other) const
                    {
                        return __lsx_vor_v(this->value, other.value);
                    }
                    simdutf_really_inline simd16<T> operator&(const simd16<T> other) const
                    {
                        return __lsx_vand_v(this->value, other.value);
                    }
                    simdutf_really_inline simd16<T> operator^(const simd16<T> other) const
                    {
                        return __lsx_vxor_v(this->value, other.value);
                    }
                    simdutf_really_inline simd16<T> bit_andnot(const simd16<T> other) const
                    {
                        return __lsx_vandn_v(this->value, other.value);
                    }
                    simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }
                    simdutf_really_inline simd16<T>& operator|=(const simd16<T> other)
                    {
                        auto this_cast = static_cast<simd16<T>*>(this);
                        *this_cast = *this_cast | other;
                        return *this_cast;
                    }
                    simdutf_really_inline simd16<T>& operator&=(const simd16<T> other)
                    {
                        auto this_cast = static_cast<simd16<T>*>(this);
                        *this_cast = *this_cast & other;
                        return *this_cast;
                    }
                    simdutf_really_inline simd16<T>& operator^=(const simd16<T> other)
                    {
                        auto this_cast = static_cast<simd16<T>*>(this);
                        *this_cast = *this_cast ^ other;
                        return *this_cast;
                    }

                    friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
                        const simd16<T> rhs)
                    {
                        return __lsx_vseq_h(lhs.value, rhs.value);
                    }

                    template <int N = 1>
                    simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const
                    {
                        return __lsx_vor_v(__lsx_vbsll_v(*this, N * 2),
                            __lsx_vbsrl_v(prev_chunk, 16 - N * 2));
                    }
                };

                template <typename T, typename Mask = simd16<bool>>
                struct base16 : base_u16<T>
                {
                    typedef uint16_t bitmask_t;
                    typedef uint32_t bitmask2_t;

                    simdutf_really_inline base16()
                        : base_u16<T>()
                    {
                    }
                    simdutf_really_inline base16(const __m128i _value)
                        : base_u16<T>(_value)
                    {
                    }
                    template <typename Pointer>
                    simdutf_really_inline base16(const Pointer* ptr)
                        : base16(__lsx_vld(ptr, 0))
                    {
                    }

                    static const int SIZE = sizeof(base_u16<T>::value);

                    template <int N = 1>
                    simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const
                    {
                        return __lsx_vor_v(__lsx_vbsll_v(*this, N * 2),
                            __lsx_vbsrl_v(prev_chunk, 16 - N * 2));
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd16<bool> : base16<bool>
                {
                    static simdutf_really_inline simd16<bool> splat(bool _value)
                    {
                        return __lsx_vreplgr2vr_h(uint16_t(-(!!_value)));
                    }

                    simdutf_really_inline simd16()
                        : base16()
                    {
                    }
                    simdutf_really_inline simd16(const __m128i _value)
                        : base16<bool>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(bool _value)
                        : base16<bool>(splat(_value))
                    {
                    }
                };

                template <typename T>
                struct base16_numeric : base16<T>
                {
                    static simdutf_really_inline simd16<T> splat(T _value)
                    {
                        return __lsx_vreplgr2vr_h(_value);
                    }
                    static simdutf_really_inline simd16<T> zero() { return __lsx_vldi(0); }
                    static simdutf_really_inline simd16<T> load(const T values[8])
                    {
                        return __lsx_vld(reinterpret_cast<const uint16_t*>(values), 0);
                    }

                    simdutf_really_inline base16_numeric()
                        : base16<T>()
                    {
                    }
                    simdutf_really_inline base16_numeric(const __m128i _value)
                        : base16<T>(_value)
                    {
                    }

                    // Store to array
                    simdutf_really_inline void store(T dst[8]) const
                    {
                        return __lsx_vst(this->value, dst, 0);
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFu; }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd16<T> operator+(const simd16<T> other) const
                    {
                        return __lsx_vadd_b(*this, other);
                    }
                    simdutf_really_inline simd16<T> operator-(const simd16<T> other) const
                    {
                        return __lsx_vsub_b(*this, other);
                    }
                    simdutf_really_inline simd16<T>& operator+=(const simd16<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd16<T>*>(this);
                    }
                    simdutf_really_inline simd16<T>& operator-=(const simd16<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd16<T>*>(this);
                    }
                };

                // Signed code unitstemplate<>
                template <>
                struct simd16<int16_t> : base16_numeric<int16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<int16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const __m128i _value)
                        : base16_numeric<int16_t>(_value)
                    {
                    }
                    simdutf_really_inline simd16(simd16<bool> other)
                        : base16_numeric<int16_t>(other.value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(int16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const int16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const int16_t*>(values)))
                    {
                    }
                    simdutf_really_inline operator simd16<uint16_t>() const;

                    // Order-sensitive comparisons
                    simdutf_really_inline simd16<int16_t>
                    max_val(const simd16<int16_t> other) const
                    {
                        return __lsx_vmax_h(this->value, other.value);
                    }
                    simdutf_really_inline simd16<int16_t>
                    min_val(const simd16<int16_t> other) const
                    {
                        return __lsx_vmin_h(this->value, other.value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<int16_t> other) const
                    {
                        return __lsx_vsle_h(other.value, this->value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<int16_t> other) const
                    {
                        return __lsx_vslt_h(this->value, other.value);
                    }
                };

                // Unsigned code unitstemplate<>
                template <>
                struct simd16<uint16_t> : base16_numeric<uint16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<uint16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const __m128i _value)
                        : base16_numeric<uint16_t>((__m128i)_value)
                    {
                    }
                    simdutf_really_inline simd16(simd16<bool> other)
                        : base16_numeric<uint16_t>(other.value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(uint16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const uint16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const uint16_t*>(values)))
                    {
                    }

                    // Saturated math
                    simdutf_really_inline simd16<uint16_t>
                    saturating_add(const simd16<uint16_t> other) const
                    {
                        return __lsx_vsadd_hu(this->value, other.value);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    saturating_sub(const simd16<uint16_t> other) const
                    {
                        return __lsx_vssub_hu(this->value, other.value);
                    }

                    // Order-specific operations
                    simdutf_really_inline simd16<uint16_t>
                    max_val(const simd16<uint16_t> other) const
                    {
                        return __lsx_vmax_hu(this->value, other.value);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    min_val(const simd16<uint16_t> other) const
                    {
                        return __lsx_vmin_hu(this->value, other.value);
                    }
                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    gt_bits(const simd16<uint16_t> other) const
                    {
                        return this->saturating_sub(other);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    lt_bits(const simd16<uint16_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<=(const simd16<uint16_t> other) const
                    {
                        return __lsx_vsle_hu(this->value, other.value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>=(const simd16<uint16_t> other) const
                    {
                        return __lsx_vsle_hu(other.value, this->value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<uint16_t> other) const
                    {
                        return __lsx_vslt_hu(other.value, this->value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<uint16_t> other) const
                    {
                        return __lsx_vslt_hu(this->value, other.value);
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd16<bool> bits_not_set() const
                    {
                        return *this == uint16_t(0);
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shr() const
                    {
                        return simd16<uint16_t>(__lsx_vsrli_h(this->value, N));
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shl() const
                    {
                        return simd16<uint16_t>(__lsx_vslli_h(this->value, N));
                    }

                    // logical operations
                    simdutf_really_inline simd16<uint16_t>
                    operator|(const simd16<uint16_t> other) const
                    {
                        return __lsx_vor_v(this->value, other.value);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    operator&(const simd16<uint16_t> other) const
                    {
                        return __lsx_vand_v(this->value, other.value);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    operator^(const simd16<uint16_t> other) const
                    {
                        return __lsx_vxor_v(this->value, other.value);
                    }

                    // Pack with the unsigned saturation of two uint16_t code units into single
                    // uint8_t vector
                    static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t>& v0,
                        const simd16<uint16_t>& v1)
                    {
                        return __lsx_vssrlni_bu_h(v1.value, v0.value, 0);
                    }

                    // Change the endianness
                    simdutf_really_inline simd16<uint16_t> swap_bytes() const
                    {
                        return __lsx_vshuf4i_b(this->value, 0b10110001);
                    }
                };

                simdutf_really_inline simd16<int16_t>::operator simd16<uint16_t>() const
                {
                    return this->value;
                }

                template <typename T>
                struct simd16x32
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
                    static_assert(
                        NUM_CHUNKS == 4,
                        "LOONGARCH kernel should use four registers per 64-byte block.");
                    simd16<T> chunks[NUM_CHUNKS];

                    simd16x32(const simd16x32<T>& o) = delete; // no copy allowed
                    simd16x32<T>&
                    operator=(const simd16<T> other)
                        = delete; // no assignment allowed
                    simd16x32() = delete; // no default constructor allowed

                    simdutf_really_inline
                    simd16x32(const simd16<T> chunk0, const simd16<T> chunk1,
                        const simd16<T> chunk2, const simd16<T> chunk3)
                        : chunks { chunk0, chunk1, chunk2, chunk3 }
                    {
                    }
                    simdutf_really_inline simd16x32(const T* ptr)
                        : chunks { simd16<T>::load(ptr),
                            simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)),
                            simd16<T>::load(ptr + 2 * sizeof(simd16<T>) / sizeof(T)),
                            simd16<T>::load(ptr + 3 * sizeof(simd16<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
                        this->chunks[2].store(ptr + sizeof(simd16<T>) * 2 / sizeof(T));
                        this->chunks[3].store(ptr + sizeof(simd16<T>) * 3 / sizeof(T));
                    }

                    simdutf_really_inline simd16<T> reduce_or() const
                    {
                        return (this->chunks[0] | this->chunks[1]) | (this->chunks[2] | this->chunks[3]);
                    }

                    simdutf_really_inline bool is_ascii() const { return reduce_or().is_ascii(); }

                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
                        this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 1);
                        this->chunks[2].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 2);
                        this->chunks[3].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 3);
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        __m128i mask = __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[3]).value), 6);
                        mask = __lsx_vor_v(
                            mask, __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[2]).value), 4));
                        mask = __lsx_vor_v(
                            mask, __lsx_vbsll_v(__lsx_vmsknz_b((this->chunks[1]).value), 2));
                        mask = __lsx_vor_v(mask, __lsx_vmsknz_b((this->chunks[0]).value));
                        return __lsx_vpickve2gr_du(mask, 0);
                    }

                    simdutf_really_inline void swap_bytes()
                    {
                        this->chunks[0] = this->chunks[0].swap_bytes();
                        this->chunks[1] = this->chunks[1].swap_bytes();
                        this->chunks[2] = this->chunks[2].swap_bytes();
                        this->chunks[3] = this->chunks[3].swap_bytes();
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask,
                            this->chunks[2] == mask, this->chunks[3] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask,
                            this->chunks[2] <= mask, this->chunks[3] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(low);
                        const simd16<T> mask_high = simd16<T>::splat(high);

                        return simd16x32<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low),
                            (this->chunks[2] <= mask_high) & (this->chunks[2] >= mask_low),
                            (this->chunks[3] <= mask_high) & (this->chunks[3] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(low);
                        const simd16<T> mask_high = simd16<T>::splat(high);
                        return simd16x32<bool>(
                            (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
                            (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low),
                            (this->chunks[2] > mask_high) | (this->chunks[2] < mask_low),
                            (this->chunks[3] > mask_high) | (this->chunks[3] < mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask,
                            this->chunks[2] < mask, this->chunks[3] < mask)
                            .to_bitmask();
                    }

                }; // struct simd16x32<T>

                template <>
                simdutf_really_inline uint64_t simd16x32<uint16_t>::not_in_range(
                    const uint16_t low, const uint16_t high) const
                {
                    const simd16<uint16_t> mask_low = simd16<uint16_t>::splat(low);
                    const simd16<uint16_t> mask_high = simd16<uint16_t>::splat(high);
                    simd16x32<uint16_t> x(simd16<uint16_t>((this->chunks[0] > mask_high) | (this->chunks[0] < mask_low)),
                        simd16<uint16_t>((this->chunks[1] > mask_high) | (this->chunks[1] < mask_low)),
                        simd16<uint16_t>((this->chunks[2] > mask_high) | (this->chunks[2] < mask_low)),
                        simd16<uint16_t>((this->chunks[3] > mask_high) | (this->chunks[3] < mask_low)));
                    return x.to_bitmask();
                }
                /* end file src/simdutf/lsx/simd16-inl.h */
                /* begin file src/simdutf/lsx/simd32-inl.h */
                template <typename T>
                struct simd32;

                template <>
                struct simd32<uint32_t>
                {
                    __m128i value;
                    static const int SIZE = sizeof(value);
                    static const int ELEMENTS = SIZE / sizeof(uint32_t);

                    // constructors
                    simdutf_really_inline simd32(__m128i v)
                        : value(v)
                    {
                    }

                    template <typename Ptr>
                    simdutf_really_inline simd32(Ptr* ptr)
                        : value(__lsx_vld(ptr, 0))
                    {
                    }

                    // in-place operators
                    simdutf_really_inline simd32& operator-=(const simd32 other)
                    {
                        value = __lsx_vsub_w(value, other.value);
                        return *this;
                    }

                    // members
                    simdutf_really_inline uint64_t sum() const
                    {
                        return uint64_t(__lsx_vpickve2gr_wu(value, 0)) + uint64_t(__lsx_vpickve2gr_wu(value, 1)) + uint64_t(__lsx_vpickve2gr_wu(value, 2)) + uint64_t(__lsx_vpickve2gr_wu(value, 3));
                    }

                    // static members
                    static simdutf_really_inline simd32<uint32_t> splat(uint32_t x)
                    {
                        return __lsx_vreplgr2vr_w(x);
                    }

                    static simdutf_really_inline simd32<uint32_t> zero()
                    {
                        return __lsx_vrepli_w(0);
                    }
                };

                // ------------------------------------------------------------

                template <>
                struct simd32<bool>
                {
                    __m128i value;
                    static const int SIZE = sizeof(value);

                    // constructors
                    simdutf_really_inline simd32(__m128i v)
                        : value(v)
                    {
                    }
                };

                // ------------------------------------------------------------

                simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return __lsx_vor_v(a.value, b.value);
                }

                simdutf_really_inline simd32<bool> operator<(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return __lsx_vslt_wu(a.value, b.value);
                }

                simdutf_really_inline simd32<bool> operator>(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return __lsx_vslt_wu(b.value, a.value);
                }

                // ------------------------------------------------------------

                simdutf_really_inline simd32<uint32_t> as_vector_u32(const simd32<bool> v)
                {
                    return v.value;
                }
                /* end file src/simdutf/lsx/simd32-inl.h */

            } // namespace simd
        } // unnamed namespace
    } // namespace lsx
} // namespace simdutf

        #endif // SIMDUTF_LSX_SIMD_H
        /* end file src/simdutf/lsx/simd.h */

        /* begin file src/simdutf/lsx/end.h */
        #undef SIMDUTF_SIMD_HAS_UNSIGNED_CMP
    /* end file src/simdutf/lsx/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_LSX

#endif // SIMDUTF_LSX_H
/* end file src/simdutf/lsx.h */
/* begin file src/simdutf/lasx.h */
#ifndef SIMDUTF_LASX_H
    #define SIMDUTF_LASX_H

    #ifdef SIMDUTF_FALLBACK_H
        #error "lasx.h must be included before fallback.h"
    #endif

    #ifndef SIMDUTF_IMPLEMENTATION_LASX
        #define SIMDUTF_IMPLEMENTATION_LASX (SIMDUTF_IS_LASX)
    #endif
    #if SIMDUTF_IMPLEMENTATION_LASX && SIMDUTF_IS_LASX
        #define SIMDUTF_CAN_ALWAYS_RUN_LASX 1
    #else
        #define SIMDUTF_CAN_ALWAYS_RUN_LASX 0
    #endif

    #define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)

    #if SIMDUTF_IMPLEMENTATION_LASX

namespace simdutf
{
    /**
     * Implementation for LoongArch ASX.
     */
    namespace lasx
    {
    } // namespace lasx
} // namespace simdutf

        /* begin file src/simdutf/lasx/implementation.h */
        #ifndef SIMDUTF_LASX_IMPLEMENTATION_H
            #define SIMDUTF_LASX_IMPLEMENTATION_H

namespace simdutf
{
    namespace lasx
    {

        namespace
        {
            using namespace simdutf;
        }

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation("lasx", "LOONGARCH ASX",
                      internal::instruction_set::LSX | internal::instruction_set::LASX)
            {
            }
            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;
            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;
        };

    } // namespace lasx
} // namespace simdutf

        #endif // SIMDUTF_LASX_IMPLEMENTATION_H
        /* end file src/simdutf/lasx/implementation.h */

        /* begin file src/simdutf/lasx/begin.h */
        // redefining SIMDUTF_IMPLEMENTATION to "lasx"
        // #define SIMDUTF_IMPLEMENTATION lasx
        #define SIMDUTF_SIMD_HAS_UNSIGNED_CMP 1
    /* end file src/simdutf/lasx/begin.h */

    // Declarations
        /* begin file src/simdutf/lasx/intrinsics.h */
        #ifndef SIMDUTF_LASX_INTRINSICS_H
            #define SIMDUTF_LASX_INTRINSICS_H

            // This should be the correct header whether
            // you use visual studio or other compilers.
            #include <lasxintrin.h>
            #include <lsxintrin.h>

            #if defined(__loongarch_asx)
                #ifdef __clang__
                    #define VREGS_PREFIX "$vr"
                    #define XREGS_PREFIX "$xr"
                #else // GCC
                    #define VREGS_PREFIX "$f"
                    #define XREGS_PREFIX "$f"
                #endif
                #define __ALL_REGS                                                            \
                    "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26," \
                    "27,28,29,30,31"
// Convert __m128i to __m256i
static inline __m256i ____m256i(__m128i in)
{
    __m256i out = __lasx_xvldi(0);
    __asm__ volatile(".irp i," __ALL_REGS "\n\t"
                     " .ifc %[out], " XREGS_PREFIX "\\i    \n\t"
                     "  .irp j," __ALL_REGS "\n\t"
                     "   .ifc %[in], " VREGS_PREFIX "\\j  \n\t"
                     "    xvpermi.q $xr\\i, $xr\\j, 0x0  \n\t"
                     "   .endif                           \n\t"
                     "  .endr                             \n\t"
                     " .endif                             \n\t"
                     ".endr                               \n\t"
        : [out] "+f"(out)
        : [in] "f"(in));
    return out;
}
// Convert two __m128i to __m256i
static inline __m256i lasx_set_q(__m128i inhi, __m128i inlo)
{
    __m256i out;
    __asm__ volatile(".irp i," __ALL_REGS "\n\t"
                     " .ifc %[hi], " VREGS_PREFIX "\\i    \n\t"
                     "  .irp j," __ALL_REGS "\n\t"
                     "   .ifc %[lo], " VREGS_PREFIX "\\j  \n\t"
                     "    xvpermi.q $xr\\i, $xr\\j, 0x20  \n\t"
                     "   .endif                           \n\t"
                     "  .endr                             \n\t"
                     " .endif                             \n\t"
                     ".endr                               \n\t"
                     ".ifnc %[out], %[hi]                 \n\t"
                     ".irp i," __ALL_REGS "\n\t"
                     " .ifc %[out], " XREGS_PREFIX "\\i   \n\t"
                     "  .irp j," __ALL_REGS "\n\t"
                     "   .ifc %[hi], " VREGS_PREFIX "\\j  \n\t"
                     "    xvori.b $xr\\i, $xr\\j, 0       \n\t"
                     "   .endif                           \n\t"
                     "  .endr                             \n\t"
                     " .endif                             \n\t"
                     ".endr                               \n\t"
                     ".endif                              \n\t"
        : [out] "=f"(out), [hi] "+f"(inhi)
        : [lo] "f"(inlo));
    return out;
}
// Convert __m256i low part to __m128i
static inline __m128i lasx_extracti128_lo(__m256i in)
{
    __m128i out;
    __asm__ volatile(".ifnc %[out], %[in]                 \n\t"
                     ".irp i," __ALL_REGS "\n\t"
                     " .ifc %[out], " VREGS_PREFIX "\\i   \n\t"
                     "  .irp j," __ALL_REGS "\n\t"
                     "   .ifc %[in], " XREGS_PREFIX "\\j  \n\t"
                     "    vori.b $vr\\i, $vr\\j, 0        \n\t"
                     "   .endif                           \n\t"
                     "  .endr                             \n\t"
                     " .endif                             \n\t"
                     ".endr                               \n\t"
                     ".endif                              \n\t"
        : [out] "=f"(out)
        : [in] "f"(in));
    return out;
}
// Convert __m256i high part to __m128i
static inline __m128i lasx_extracti128_hi(__m256i in)
{
    __m128i out;
    __asm__ volatile(".irp i," __ALL_REGS "\n\t"
                     " .ifc %[out], " VREGS_PREFIX "\\i   \n\t"
                     "  .irp j," __ALL_REGS "\n\t"
                     "   .ifc %[in], " XREGS_PREFIX "\\j  \n\t"
                     "    xvpermi.q $xr\\i, $xr\\j, 0x11  \n\t"
                     "   .endif                           \n\t"
                     "  .endr                             \n\t"
                     " .endif                             \n\t"
                     ".endr                               \n\t"
        : [out] "=f"(out)
        : [in] "f"(in));
    return out;
}
            #endif

/*
Encoding of argument for LoongArch64 xvldi instruction.  See:
https://jia.je/unofficial-loongarch-intrinsics-guide/lasx/misc/#__m256i-__lasx_xvldi-imm_n1024_1023-imm

1: imm[12:8]=0b10000: broadcast imm[7:0] as 32-bit elements to all lanes

2: imm[12:8]=0b10001: broadcast imm[7:0] << 8 as 32-bit elements to all lanes

3: imm[12:8]=0b10010: broadcast imm[7:0] << 16 as 32-bit elements to all lanes

4: imm[12:8]=0b10011: broadcast imm[7:0] << 24 as 32-bit elements to all lanes

5: imm[12:8]=0b10100: broadcast imm[7:0] as 16-bit elements to all lanes

6: imm[12:8]=0b10101: broadcast imm[7:0] << 8 as 16-bit elements to all lanes

7: imm[12:8]=0b10110: broadcast (imm[7:0] << 8) | 0xFF as 32-bit elements to all
lanes

8: imm[12:8]=0b10111: broadcast (imm[7:0] << 16) | 0xFFFF as 32-bit elements to
all lanes

9: imm[12:8]=0b11000: broadcast imm[7:0] as 8-bit elements to all lanes

10: imm[12:8]=0b11001: repeat each bit of imm[7:0] eight times, and broadcast
the result as 64-bit elements to all lanes
*/

namespace lasx_vldi
{

    template <uint16_t v>
    class const_u16
    {
        constexpr static const uint8_t b0 = ((v >> 0 * 8) & 0xff);
        constexpr static const uint8_t b1 = ((v >> 1 * 8) & 0xff);

        constexpr static bool is_case5 = uint16_t(b0) == v;
        constexpr static bool is_case6 = (uint16_t(b1) << 8) == v;
        constexpr static bool is_case9 = (b0 == b1);
        constexpr static bool is_case10 = ((b0 == 0xff) || (b0 == 0x00)) && ((b1 == 0xff) || (b1 == 0x00));

    public:
        constexpr static uint16_t operation = is_case5 ? 0b10100
            : is_case6                                 ? 0b10101
            : is_case9                                 ? 0b11000
            : is_case10                                ? 0x11001
                                                       : 0xffff;

        constexpr static uint16_t byte = is_case5 ? b0
            : is_case6                            ? b1
            : is_case9                            ? b0
            : is_case10                           ? ((b0 ? 0x55 : 0x00) | (b1 ? 0xaa : 0x00))
                                                  : 0xffff;

        constexpr static int value = int((operation << 8) | byte) - 8192;
        constexpr static bool valid = operation != 0xffff;
    };

    template <uint32_t v>
    class const_u32
    {
        constexpr static const uint8_t b0 = (v & 0xff);
        constexpr static const uint8_t b1 = ((v >> 8) & 0xff);
        constexpr static const uint8_t b2 = ((v >> 16) & 0xff);
        constexpr static const uint8_t b3 = ((v >> 24) & 0xff);

        constexpr static bool is_case1 = (uint32_t(b0) == v);
        constexpr static bool is_case2 = ((uint32_t(b1) << 8) == v);
        constexpr static bool is_case3 = ((uint32_t(b2) << 16) == v);
        constexpr static bool is_case4 = ((uint32_t(b3) << 24) == v);
        constexpr static bool is_case5 = (b0 == b2) && (b1 == 0) && (b3 == 0);
        constexpr static bool is_case6 = (b1 == b3) && (b0 == 0) && (b2 == 0);
        constexpr static bool is_case7 = (b3 == 0) && (b2 == 0) && (b0 == 0xff);
        constexpr static bool is_case8 = (b3 == 0) && (b1 == 0xff) && (b0 == 0xff);
        constexpr static bool is_case9 = (b0 == b1) && (b0 == b2) && (b0 == b3);
        constexpr static bool is_case10 = ((b0 == 0xff) || (b0 == 0x00)) && ((b1 == 0xff) || (b1 == 0x00)) && ((b2 == 0xff) || (b2 == 0x00)) && ((b3 == 0xff) || (b3 == 0x00));

    public:
        constexpr static uint16_t operation = is_case1 ? 0b10000
            : is_case2                                 ? 0b10001
            : is_case3                                 ? 0b10010
            : is_case4                                 ? 0b10011
            : is_case5                                 ? 0b10100
            : is_case6                                 ? 0b10101
            : is_case7                                 ? 0b10110
            : is_case8                                 ? 0b10111
            : is_case9                                 ? 0b11000
            : is_case10                                ? 0b11001
                                                       : 0xffff;

        constexpr static uint16_t byte = is_case1 ? b0
            : is_case2                            ? b1
            : is_case3                            ? b2
            : is_case4                            ? b3
            : is_case5                            ? b0
            : is_case6                            ? b1
            : is_case7                            ? b1
            : is_case8                            ? b2
            : is_case9                            ? b0
            : is_case10                           ? ((b0 ? 0x11 : 0x00) | (b1 ? 0x22 : 0x00) | (b2 ? 0x44 : 0x00) | (b3 ? 0x88 : 0x00))
                                                  : 0xffff;

        constexpr static int value = int((operation << 8) | byte) - 8192;
        constexpr static bool valid = operation != 0xffff;
    };

    template <uint64_t v>
    class const_u64
    {
        constexpr static const uint8_t b0 = ((v >> 0 * 8) & 0xff);
        constexpr static const uint8_t b1 = ((v >> 1 * 8) & 0xff);
        constexpr static const uint8_t b2 = ((v >> 2 * 8) & 0xff);
        constexpr static const uint8_t b3 = ((v >> 3 * 8) & 0xff);
        constexpr static const uint8_t b4 = ((v >> 4 * 8) & 0xff);
        constexpr static const uint8_t b5 = ((v >> 5 * 8) & 0xff);
        constexpr static const uint8_t b6 = ((v >> 6 * 8) & 0xff);
        constexpr static const uint8_t b7 = ((v >> 7 * 8) & 0xff);

        constexpr static bool is_case10 = ((b0 == 0xff) || (b0 == 0x00)) && ((b1 == 0xff) || (b1 == 0x00)) && ((b2 == 0xff) || (b2 == 0x00)) && ((b3 == 0xff) || (b3 == 0x00)) && ((b4 == 0xff) || (b4 == 0x00)) && ((b5 == 0xff) || (b5 == 0x00)) && ((b6 == 0xff) || (b6 == 0x00)) && ((b7 == 0xff) || (b7 == 0x00));

    public:
        constexpr static bool is_32bit = ((v & 0xffffffff) == (v >> 32)) && const_u32<(v >> 32)>::value;
        constexpr static uint8_t op_32bit = const_u32<(v >> 32)>::operation;
        constexpr static uint8_t byte_32bit = const_u32<(v >> 32)>::byte;

        constexpr static uint16_t operation = is_32bit ? op_32bit
            : is_case10                                ? 0x11001
                                                       : 0xffff;

        constexpr static uint16_t byte = is_32bit ? byte_32bit
            : is_case10
            ? ((b0 ? 0x01 : 0x00) | (b1 ? 0x02 : 0x00) | (b2 ? 0x04 : 0x00) | (b3 ? 0x08 : 0x00) | (b4 ? 0x10 : 0x00) | (b5 ? 0x20 : 0x00) | (b6 ? 0x40 : 0x00) | (b7 ? 0x80 : 0x00))
            : 0xffff;

        constexpr static int value = int((operation << 8) | byte) - 8192;
        constexpr static bool valid = operation != 0xffff;
    };

} // namespace lasx_vldi

            // Uncomment when running under QEMU affected
            // by bug https://gitlab.com/qemu-project/qemu/-/issues/2865
            // Versions <= 9.2.2 are affected, likely anything newer is correct.
            #ifndef QEMU_VLDI_BUG
            // #define QEMU_VLDI_BUG 1
            #endif

            #ifdef QEMU_VLDI_BUG
                #define lasx_splat_u16(v) __lasx_xvreplgr2vr_h(v)
                #define lasx_splat_u32(v) __lasx_xvreplgr2vr_w(v)
            #else
template <uint16_t x>
constexpr __m256i lasx_splat_u16_aux()
{
    constexpr bool is_imm10 = (int16_t(x) < 512) && (int16_t(x) > -512);
    constexpr uint16_t imm10 = is_imm10 ? x : 0;
    constexpr bool is_vldi = lasx_vldi::const_u16<x>::valid;
    constexpr int vldi_imm = is_vldi ? lasx_vldi::const_u16<x>::value : 0;

    return is_imm10 ? __lasx_xvrepli_h(int16_t(imm10))
        : is_vldi   ? __lasx_xvldi(vldi_imm)
                    : __lasx_xvreplgr2vr_h(x);
}

template <uint32_t x>
constexpr __m256i lasx_splat_u32_aux()
{
    constexpr bool is_imm10 = (int32_t(x) < 512) && (int32_t(x) > -512);
    constexpr uint32_t imm10 = is_imm10 ? x : 0;
    constexpr bool is_vldi = lasx_vldi::const_u32<x>::valid;
    constexpr int vldi_imm = is_vldi ? lasx_vldi::const_u32<x>::value : 0;

    return is_imm10 ? __lasx_xvrepli_w(int32_t(imm10))
        : is_vldi   ? __lasx_xvldi(vldi_imm)
                    : __lasx_xvreplgr2vr_w(x);
}

                #define lasx_splat_u16(v) lasx_splat_u16_aux<(v)>()
                #define lasx_splat_u32(v) lasx_splat_u32_aux<(v)>()
            #endif // QEMU_VLDI_BUG

        #endif //  SIMDUTF_LASX_INTRINSICS_H
        /* end file src/simdutf/lasx/intrinsics.h */
        /* begin file src/simdutf/lasx/bitmanipulation.h */
        #ifndef SIMDUTF_LASX_BITMANIPULATION_H
            #define SIMDUTF_LASX_BITMANIPULATION_H

            #include <limits>

namespace simdutf
{
    namespace lasx
    {
        namespace
        {

            simdutf_really_inline int count_ones(uint64_t input_num)
            {
                return __lsx_vpickve2gr_w(__lsx_vpcnt_d(__lsx_vreplgr2vr_d(input_num)), 0);
            }

            #if SIMDUTF_NEED_TRAILING_ZEROES
            // simdutf_really_inline int trailing_zeroes(uint64_t input_num) {
            //   return __builtin_ctzll(input_num);
            // }
            #endif

        } // unnamed namespace
    } // namespace lasx
} // namespace simdutf

        #endif // SIMDUTF_LASX_BITMANIPULATION_H
        /* end file src/simdutf/lasx/bitmanipulation.h */
        /* begin file src/simdutf/lasx/simd.h */
        #ifndef SIMDUTF_LASX_SIMD_H
            #define SIMDUTF_LASX_SIMD_H

            #include <type_traits>

namespace simdutf
{
    namespace lasx
    {
        namespace
        {
            namespace simd
            {

                __attribute__((aligned(32))) static const uint8_t prev_shuf_table[32][32] = {
                    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
                    { 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
                        31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14 },
                    { 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,
                        30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 },
                    { 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
                        29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 },
                    { 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
                        28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 },
                    { 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
                        27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },
                    { 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
                        26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8,
                        25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
                        24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6,
                        23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5,
                        22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4, 5 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4,
                        21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3, 4 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3,
                        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2, 3 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
                        19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1, 2 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                        18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0, 1 },
                    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0 },
                    { 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
                        15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
                        14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,
                        13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
                        12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
                        11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
                        10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
                        9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
                        8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0 },
                    { 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
                        7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0 },
                    { 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
                        6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0 },
                    { 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                        5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0 },
                    { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                        4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0 },
                    { 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
                        3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0 },
                    { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
                        2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0 },
                    { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
                        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0 },
                    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
                };

                __attribute__((aligned(32))) static const uint8_t bitsel_mask_table[32][32] = {
                    { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0, 0x0 },
                    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0 }
                };

                // Forward-declared so they can be used by splat and friends.
                template <typename Child>
                struct base
                {
                    __m256i value;

                    // Zero constructor
                    simdutf_really_inline base()
                        : value { __m256i() }
                    {
                    }

                    // Conversion from SIMD register
                    simdutf_really_inline base(const __m256i _value)
                        : value(_value)
                    {
                    }
                    // Conversion to SIMD register
                    simdutf_really_inline operator const __m256i&() const { return this->value; }
                    simdutf_really_inline operator __m256i&() { return this->value; }
                    template <endianness big_endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        if (big_endian)
                        {
                            __m256i zero = __lasx_xvldi(0);
                            __m256i in8 = __lasx_xvpermi_d(this->value, 0b11011000);
                            __m256i inlow = __lasx_xvilvl_b(in8, zero);
                            __m256i inhigh = __lasx_xvilvh_b(in8, zero);
                            __lasx_xvst(inlow, reinterpret_cast<uint16_t*>(ptr), 0);
                            __lasx_xvst(inhigh, reinterpret_cast<uint16_t*>(ptr), 32);
                        }
                        else
                        {
                            __m256i inlow = __lasx_vext2xv_hu_bu(this->value);
                            __m256i inhigh = __lasx_vext2xv_hu_bu(
                                __lasx_xvpermi_q(this->value, this->value, 0b00000001));
                            __lasx_xvst(inlow, reinterpret_cast<__m256i*>(ptr), 0);
                            __lasx_xvst(inhigh, reinterpret_cast<__m256i*>(ptr), 32);
                        }
                    }
                    simdutf_really_inline void store_ascii_as_utf32(char32_t* ptr) const
                    {
                        __m256i in32_0 = __lasx_vext2xv_wu_bu(this->value);
                        __lasx_xvst(in32_0, reinterpret_cast<uint32_t*>(ptr), 0);

                        __m256i in8_1 = __lasx_xvpermi_d(this->value, 0b00000001);
                        __m256i in32_1 = __lasx_vext2xv_wu_bu(in8_1);
                        __lasx_xvst(in32_1, reinterpret_cast<uint32_t*>(ptr), 32);

                        __m256i in8_2 = __lasx_xvpermi_d(this->value, 0b00000010);
                        __m256i in32_2 = __lasx_vext2xv_wu_bu(in8_2);
                        __lasx_xvst(in32_2, reinterpret_cast<uint32_t*>(ptr), 64);

                        __m256i in8_3 = __lasx_xvpermi_d(this->value, 0b00000011);
                        __m256i in32_3 = __lasx_vext2xv_wu_bu(in8_3);
                        __lasx_xvst(in32_3, reinterpret_cast<uint32_t*>(ptr), 96);
                    }
                    // Bit operations
                    simdutf_really_inline Child operator|(const Child other) const
                    {
                        return __lasx_xvor_v(this->value, other);
                    }
                    simdutf_really_inline Child operator&(const Child other) const
                    {
                        return __lasx_xvand_v(this->value, other);
                    }
                    simdutf_really_inline Child operator^(const Child other) const
                    {
                        return __lasx_xvxor_v(this->value, other);
                    }
                    simdutf_really_inline Child bit_andnot(const Child other) const
                    {
                        return __lasx_xvandn_v(this->value, other);
                    }
                    simdutf_really_inline Child& operator|=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast | other;
                        return *this_cast;
                    }
                    simdutf_really_inline Child& operator&=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast & other;
                        return *this_cast;
                    }
                    simdutf_really_inline Child& operator^=(const Child other)
                    {
                        auto this_cast = static_cast<Child*>(this);
                        *this_cast = *this_cast ^ other;
                        return *this_cast;
                    }
                };

                template <typename T>
                struct simd8;

                template <typename T, typename Mask = simd8<bool>>
                struct base8 : base<simd8<T>>
                {
                    typedef uint32_t bitmask_t;
                    typedef uint64_t bitmask2_t;

                    simdutf_really_inline base8()
                        : base<simd8<T>>()
                    {
                    }
                    simdutf_really_inline base8(const __m256i _value)
                        : base<simd8<T>>(_value)
                    {
                    }
                    simdutf_really_inline T first() const
                    {
                        return __lasx_xvpickve2gr_wu(this->value, 0);
                    }
                    simdutf_really_inline T last() const
                    {
                        return __lasx_xvpickve2gr_wu(this->value, 7);
                    }
                    friend simdutf_really_inline Mask operator==(const simd8<T> lhs,
                        const simd8<T> rhs)
                    {
                        return __lasx_xvseq_b(lhs, rhs);
                    }

                    static const int SIZE = sizeof(base<T>::value);

                    template <int N = 1>
                    simdutf_really_inline simd8<T> prev(const simd8<T> prev_chunk) const
                    {
                        if (!N)
                            return this->value;

                        __m256i zero = __lasx_xvldi(0);
                        __m256i result, shuf;
                        if (N < 16)
                        {
                            shuf = __lasx_xvld(prev_shuf_table[N], 0);

                            result = __lasx_xvshuf_b(
                                __lasx_xvpermi_q(this->value, this->value, 0b00000001), this->value,
                                shuf);
                            __m256i srl_prev = __lasx_xvbsrl_v(
                                __lasx_xvpermi_q(zero, prev_chunk.value, 0b00110001), (16 - N));
                            __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
                            result = __lasx_xvbitsel_v(result, srl_prev, mask);

                            return result;
                        }
                        else if (N == 16)
                        {
                            return __lasx_xvpermi_q(this->value, prev_chunk.value, 0b00100001);
                        } /*else {
                          __m256i sll_value = __lasx_xvbsll_v(
                              __lasx_xvpermi_q(zero, this->value, 0b00000011), (N - 16) % 32);
                          __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
                          shuf = __lasx_xvld(prev_shuf_table[N], 0);
                          result = __lasx_xvshuf_b(
                              __lasx_xvpermi_q(prev_chunk.value, prev_chunk.value, 0b00000001),
                              prev_chunk.value, shuf);
                          result = __lasx_xvbitsel_v(sll_value, result, mask);
                          return result;
                        }*/
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd8<bool> : base8<bool>
                {
                    static simdutf_really_inline simd8<bool> splat(bool _value)
                    {
                        return __lasx_xvreplgr2vr_b(uint8_t(-(!!_value)));
                    }

                    simdutf_really_inline simd8()
                        : base8()
                    {
                    }
                    simdutf_really_inline simd8(const __m256i _value)
                        : base8<bool>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(bool _value)
                        : base8<bool>(splat(_value))
                    {
                    }

                    simdutf_really_inline uint32_t to_bitmask() const
                    {
                        __m256i mask = __lasx_xvmsknz_b(this->value);
                        uint32_t mask0 = __lasx_xvpickve2gr_wu(mask, 0);
                        uint32_t mask1 = __lasx_xvpickve2gr_wu(mask, 4);
                        return (mask0 | (mask1 << 16));
                    }
                    simdutf_really_inline bool any() const
                    {
                        if (__lasx_xbz_b(this->value))
                            return false;
                        return true;
                    }
                    simdutf_really_inline bool none() const
                    {
                        if (__lasx_xbz_b(this->value))
                            return true;
                        return false;
                    }
                    simdutf_really_inline bool all() const
                    {
                        if (__lasx_xbnz_b(this->value))
                            return true;
                        return false;
                    }
                    simdutf_really_inline simd8<bool> operator~() const { return *this ^ true; }
                };

                template <typename T>
                struct base8_numeric : base8<T>
                {
                    static simdutf_really_inline simd8<T> splat(T _value)
                    {
                        return __lasx_xvreplgr2vr_b(_value);
                    }
                    static simdutf_really_inline simd8<T> zero() { return __lasx_xvldi(0); }
                    static simdutf_really_inline simd8<T> load(const T values[32])
                    {
                        return __lasx_xvld(reinterpret_cast<const __m256i*>(values), 0);
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    static simdutf_really_inline simd8<T> repeat_16(T v0, T v1, T v2, T v3, T v4,
                        T v5, T v6, T v7, T v8, T v9,
                        T v10, T v11, T v12, T v13,
                        T v14, T v15)
                    {
                        return simd8<T>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,
                            v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,
                            v12, v13, v14, v15);
                    }

                    simdutf_really_inline base8_numeric()
                        : base8<T>()
                    {
                    }
                    simdutf_really_inline base8_numeric(const __m256i _value)
                        : base8<T>(_value)
                    {
                    }

                    // Store to array
                    simdutf_really_inline void store(T dst[32]) const
                    {
                        return __lasx_xvst(this->value, reinterpret_cast<__m256i*>(dst), 0);
                    }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd8<T> operator+(const simd8<T> other) const
                    {
                        return __lasx_xvadd_b(this->value, other);
                    }
                    simdutf_really_inline simd8<T> operator-(const simd8<T> other) const
                    {
                        return __lasx_xvsub_b(this->value, other);
                    }
                    simdutf_really_inline simd8<T>& operator+=(const simd8<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd8<T>*>(this);
                    }
                    simdutf_really_inline simd8<T>& operator-=(const simd8<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd8<T>*>(this);
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd8<T> operator~() const { return *this ^ 0xFFu; }

                    // Perform a lookup assuming the value is between 0 and 16 (undefined behavior
                    // for out of range values)
                    template <typename L>
                    simdutf_really_inline simd8<L> lookup_16(simd8<L> lookup_table) const
                    {
                        __m256i origin = __lasx_xvand_v(this->value, __lasx_xvldi(0x1f));
                        return __lasx_xvshuf_b(__lasx_xvldi(0), lookup_table, origin);
                    }

                    template <typename L>
                    simdutf_really_inline simd8<L>
                    lookup_16(L replace0, L replace1, L replace2, L replace3, L replace4,
                        L replace5, L replace6, L replace7, L replace8, L replace9,
                        L replace10, L replace11, L replace12, L replace13, L replace14,
                        L replace15) const
                    {
                        return lookup_16(simd8<L>::repeat_16(
                            replace0, replace1, replace2, replace3, replace4, replace5, replace6,
                            replace7, replace8, replace9, replace10, replace11, replace12,
                            replace13, replace14, replace15));
                    }
                };

                // Signed bytes
                template <>
                struct simd8<int8_t> : base8_numeric<int8_t>
                {
                    simdutf_really_inline simd8()
                        : base8_numeric<int8_t>()
                    {
                    }
                    simdutf_really_inline simd8(const __m256i _value)
                        : base8_numeric<int8_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd8(int8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const int8_t values[32])
                        : simd8(load(values))
                    {
                    }
                    simdutf_really_inline operator simd8<uint8_t>() const;
                    // Member-by-member initialization
                    simdutf_really_inline
                    simd8(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
                        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15, int8_t v16, int8_t v17,
                        int8_t v18, int8_t v19, int8_t v20, int8_t v21, int8_t v22, int8_t v23,
                        int8_t v24, int8_t v25, int8_t v26, int8_t v27, int8_t v28, int8_t v29,
                        int8_t v30, int8_t v31)
                        : simd8((__m256i)v32i8 { v0, v1, v2, v3, v4, v5, v6, v7,
                              v8, v9, v10, v11, v12, v13, v14, v15,
                              v16, v17, v18, v19, v20, v21, v22, v23,
                              v24, v25, v26, v27, v28, v29, v30, v31 })
                    {
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<int8_t>
                    repeat_16(int8_t v0, int8_t v1, int8_t v2, int8_t v3, int8_t v4, int8_t v5,
                        int8_t v6, int8_t v7, int8_t v8, int8_t v9, int8_t v10, int8_t v11,
                        int8_t v12, int8_t v13, int8_t v14, int8_t v15)
                    {
                        return simd8<int8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
                            v10, v11, v12, v13, v14, v15);
                    }
                    simdutf_really_inline bool is_ascii() const
                    {
                        __m256i ascii_mask = __lasx_xvslti_b(this->value, 0);
                        if (__lasx_xbnz_v(ascii_mask))
                            return false;
                        return true;
                    }
                    // Order-sensitive comparisons
                    simdutf_really_inline simd8<int8_t> max_val(const simd8<int8_t> other) const
                    {
                        return __lasx_xvmax_b(this->value, other);
                    }
                    simdutf_really_inline simd8<int8_t> min_val(const simd8<int8_t> other) const
                    {
                        return __lasx_xvmin_b(this->value, other);
                    }
                    simdutf_really_inline simd8<bool> operator>(const simd8<int8_t> other) const
                    {
                        return __lasx_xvslt_b(other, this->value);
                    }
                    simdutf_really_inline simd8<bool> operator<(const simd8<int8_t> other) const
                    {
                        return __lasx_xvslt_b(this->value, other);
                    }
                };

                // Unsigned bytes
                template <>
                struct simd8<uint8_t> : base8_numeric<uint8_t>
                {
                    simdutf_really_inline simd8()
                        : base8_numeric<uint8_t>()
                    {
                    }
                    simdutf_really_inline simd8(const __m256i _value)
                        : base8_numeric<uint8_t>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd8(uint8_t _value)
                        : simd8(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd8(const uint8_t values[32])
                        : simd8(load(values))
                    {
                    }
                    // Member-by-member initialization
                    simdutf_really_inline
                    simd8(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4, uint8_t v5,
                        uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9, uint8_t v10,
                        uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14, uint8_t v15,
                        uint8_t v16, uint8_t v17, uint8_t v18, uint8_t v19, uint8_t v20,
                        uint8_t v21, uint8_t v22, uint8_t v23, uint8_t v24, uint8_t v25,
                        uint8_t v26, uint8_t v27, uint8_t v28, uint8_t v29, uint8_t v30,
                        uint8_t v31)
                        : simd8((__m256i)v32u8 { v0, v1, v2, v3, v4, v5, v6, v7,
                              v8, v9, v10, v11, v12, v13, v14, v15,
                              v16, v17, v18, v19, v20, v21, v22, v23,
                              v24, v25, v26, v27, v28, v29, v30, v31 })
                    {
                    }
                    // Repeat 16 values as many times as necessary (usually for lookup tables)
                    simdutf_really_inline static simd8<uint8_t>
                    repeat_16(uint8_t v0, uint8_t v1, uint8_t v2, uint8_t v3, uint8_t v4,
                        uint8_t v5, uint8_t v6, uint8_t v7, uint8_t v8, uint8_t v9,
                        uint8_t v10, uint8_t v11, uint8_t v12, uint8_t v13, uint8_t v14,
                        uint8_t v15)
                    {
                        return simd8<uint8_t>(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,
                            v13, v14, v15, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9,
                            v10, v11, v12, v13, v14, v15);
                    }

                    // Saturated math
                    simdutf_really_inline simd8<uint8_t>
                    saturating_add(const simd8<uint8_t> other) const
                    {
                        return __lasx_xvsadd_bu(this->value, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    saturating_sub(const simd8<uint8_t> other) const
                    {
                        return __lasx_xvssub_bu(this->value, other);
                    }

                    // Order-specific operations
                    simdutf_really_inline simd8<uint8_t>
                    max_val(const simd8<uint8_t> other) const
                    {
                        return __lasx_xvmax_bu(*this, other);
                    }
                    simdutf_really_inline simd8<uint8_t>
                    min_val(const simd8<uint8_t> other) const
                    {
                        return __lasx_xvmin_bu(*this, other);
                    }
                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd8<uint8_t>
                    gt_bits(const simd8<uint8_t> other) const
                    {
                        return this->saturating_sub(other);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd8<uint8_t>
                    lt_bits(const simd8<uint8_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }
                    simdutf_really_inline simd8<bool>
                    operator<=(const simd8<uint8_t> other) const
                    {
                        return __lasx_xvsle_bu(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator>=(const simd8<uint8_t> other) const
                    {
                        return __lasx_xvsle_bu(other, *this);
                    }
                    simdutf_really_inline simd8<bool>
                    operator>(const simd8<uint8_t> other) const
                    {
                        return __lasx_xvslt_bu(*this, other);
                    }
                    simdutf_really_inline simd8<bool>
                    operator<(const simd8<uint8_t> other) const
                    {
                        return __lasx_xvslt_bu(other, *this);
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd8<bool> bits_not_set() const
                    {
                        return *this == uint8_t(0);
                    }
                    simdutf_really_inline simd8<bool> bits_not_set(simd8<uint8_t> bits) const
                    {
                        return (*this & bits).bits_not_set();
                    }
                    simdutf_really_inline simd8<bool> any_bits_set() const
                    {
                        return ~this->bits_not_set();
                    }
                    simdutf_really_inline simd8<bool> any_bits_set(simd8<uint8_t> bits) const
                    {
                        return ~this->bits_not_set(bits);
                    }
                    simdutf_really_inline bool is_ascii() const
                    {
                        __m256i ascii_mask = __lasx_xvslti_b(this->value, 0);
                        if (__lasx_xbnz_v(ascii_mask))
                            return false;
                        return true;
                    }
                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        if (__lasx_xbnz_v(this->value))
                            return true;
                        return false;
                    }
                    simdutf_really_inline bool any_bits_set_anywhere(simd8<uint8_t> bits) const
                    {
                        return (*this & bits).any_bits_set_anywhere();
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shr() const
                    {
                        return __lasx_xvsrli_b(this->value, N);
                    }
                    template <int N>
                    simdutf_really_inline simd8<uint8_t> shl() const
                    {
                        return __lasx_xvslli_b(this->value, N);
                    }
                };
                simdutf_really_inline simd8<int8_t>::operator simd8<uint8_t>() const
                {
                    return this->value;
                }

                template <typename T>
                struct simd8x64
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd8<T>);
                    static_assert(NUM_CHUNKS == 2,
                        "LASX kernel should use two registers per 64-byte block.");
                    simd8<T> chunks[NUM_CHUNKS];

                    simd8x64(const simd8x64<T>& o) = delete; // no copy allowed
                    simd8x64<T>&
                    operator=(const simd8<T> other)
                        = delete; // no assignment allowed
                    simd8x64() = delete; // no default constructor allowed

                    simdutf_really_inline simd8x64(const simd8<T> chunk0, const simd8<T> chunk1)
                        : chunks { chunk0, chunk1 }
                    {
                    }
                    simdutf_really_inline simd8x64(const T* ptr)
                        : chunks { simd8<T>::load(ptr),
                            simd8<T>::load(ptr + sizeof(simd8<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd8<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd8<T>) * 1 / sizeof(T));
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
                        uint64_t r_hi = this->chunks[1].to_bitmask();
                        return r_lo | (r_hi << 32);
                    }

                    simdutf_really_inline simd8x64<T>& operator|=(const simd8x64<T>& other)
                    {
                        this->chunks[0] |= other.chunks[0];
                        this->chunks[1] |= other.chunks[1];
                        return *this;
                    }

                    simdutf_really_inline simd8<T> reduce_or() const
                    {
                        return this->chunks[0] | this->chunks[1];
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->reduce_or().is_ascii();
                    }

                    template <endianness endian>
                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].template store_ascii_as_utf16<endian>(ptr + sizeof(simd8<T>) * 1);
                    }

                    simdutf_really_inline void store_ascii_as_utf32(char32_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 0);
                        this->chunks[1].store_ascii_as_utf32(ptr + sizeof(simd8<T>) * 1);
                    }

                    simdutf_really_inline simd8x64<T> bit_or(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<T>(this->chunks[0] | mask, this->chunks[1] | mask);
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t eq(const simd8x64<uint8_t>& other) const
                    {
                        return simd8x64<bool>(this->chunks[0] == other.chunks[0],
                            this->chunks[1] == other.chunks[1])
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);

                        return simd8x64<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd8<T> mask_low = simd8<T>::splat(low);
                        const simd8<T> mask_high = simd8<T>::splat(high);
                        return simd8x64<bool>(
                            (this->chunks[0] > mask_high) | (this->chunks[0] < mask_low),
                            (this->chunks[1] > mask_high) | (this->chunks[1] < mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t gt(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] > mask, this->chunks[1] > mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq(const T m) const
                    {
                        const simd8<T> mask = simd8<T>::splat(m);
                        return simd8x64<bool>(this->chunks[0] >= mask, this->chunks[1] >= mask)
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t gteq_unsigned(const uint8_t m) const
                    {
                        const simd8<uint8_t> mask = simd8<uint8_t>::splat(m);
                        return simd8x64<bool>((simd8<uint8_t>(__m256i(this->chunks[0])) >= mask),
                            (simd8<uint8_t>(__m256i(this->chunks[1])) >= mask))
                            .to_bitmask();
                    }
                }; // struct simd8x64<T>

                /* begin file src/simdutf/lasx/simd16-inl.h */
                template <typename T>
                struct simd16;

                template <typename T, typename Mask = simd16<bool>>
                struct base16 : base<simd16<T>>
                {
                    using bitmask_type = uint32_t;

                    simdutf_really_inline base16()
                        : base<simd16<T>>()
                    {
                    }
                    simdutf_really_inline base16(const __m256i _value)
                        : base<simd16<T>>(_value)
                    {
                    }
                    template <typename Pointer>
                    simdutf_really_inline base16(const Pointer* ptr)
                        : base16(__lasx_xvld(reinterpret_cast<const __m256i*>(ptr), 0))
                    {
                    }
                    friend simdutf_really_inline Mask operator==(const simd16<T> lhs,
                        const simd16<T> rhs)
                    {
                        return __lasx_xvseq_h(lhs.value, rhs.value);
                    }

                    /// the size of vector in bytes
                    static const int SIZE = sizeof(base<simd16<T>>::value);

                    /// the number of elements of type T a vector can hold
                    static const int ELEMENTS = SIZE / sizeof(T);

                    template <int N = 1>
                    simdutf_really_inline simd16<T> prev(const simd16<T> prev_chunk) const
                    {
                        if (!N)
                            return this->value;

                        __m256i zero = __lasx_xvldi(0);
                        __m256i result, shuf;
                        if (N < 8)
                        {
                            shuf = __lasx_xvld(prev_shuf_table[N * 2], 0);

                            result = __lasx_xvshuf_b(
                                __lasx_xvpermi_q(this->value, this->value, 0b00000001), this->value,
                                shuf);
                            __m256i srl_prev = __lasx_xvbsrl_v(
                                __lasx_xvpermi_q(zero, prev_chunk, 0b00110001), (16 - N * 2));
                            __m256i mask = __lasx_xvld(bitsel_mask_table[N], 0);
                            result = __lasx_xvbitsel_v(result, srl_prev, mask);

                            return result;
                        }
                        else if (N == 8)
                        {
                            return __lasx_xvpermi_q(this->value, prev_chunk, 0b00100001);
                        }
                        else
                        {
                            __m256i sll_value = __lasx_xvbsll_v(
                                __lasx_xvpermi_q(zero, this->value, 0b00000011), (N * 2 - 16));
                            __m256i mask = __lasx_xvld(bitsel_mask_table[N * 2], 0);
                            shuf = __lasx_xvld(prev_shuf_table[N * 2], 0);
                            result = __lasx_xvshuf_b(__lasx_xvpermi_q(prev_chunk, prev_chunk, 0b00000001),
                                prev_chunk, shuf);
                            result = __lasx_xvbitsel_v(sll_value, result, mask);
                            return result;
                        }
                    }
                };

                // SIMD byte mask type (returned by things like eq and gt)
                template <>
                struct simd16<bool> : base16<bool>
                {
                    static simdutf_really_inline simd16<bool> splat(bool _value)
                    {
                        return __lasx_xvreplgr2vr_h(uint8_t(-(!!_value)));
                    }

                    simdutf_really_inline simd16()
                        : base16()
                    {
                    }
                    simdutf_really_inline simd16(const __m256i _value)
                        : base16<bool>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(bool _value)
                        : base16<bool>(splat(_value))
                    {
                    }

                    simdutf_really_inline bitmask_type to_bitmask() const
                    {
                        __m256i mask = __lasx_xvmsknz_b(this->value);
                        bitmask_type mask0 = __lasx_xvpickve2gr_wu(mask, 0);
                        bitmask_type mask1 = __lasx_xvpickve2gr_wu(mask, 4);
                        return (mask0 | (mask1 << 16));
                    }
                    simdutf_really_inline bool any() const
                    {
                        if (__lasx_xbz_v(this->value))
                            return false;
                        return true;
                    }
                    simdutf_really_inline simd16<bool> operator~() const { return *this ^ true; }
                };

                template <typename T>
                struct base16_numeric : base16<T>
                {
                    static simdutf_really_inline simd16<T> splat(T _value)
                    {
                        return __lasx_xvreplgr2vr_h((uint16_t)_value);
                    }
                    static simdutf_really_inline simd16<T> zero() { return __lasx_xvldi(0); }
                    static simdutf_really_inline simd16<T> load(const T values[8])
                    {
                        return __lasx_xvld(reinterpret_cast<const __m256i*>(values), 0);
                    }

                    simdutf_really_inline base16_numeric()
                        : base16<T>()
                    {
                    }
                    simdutf_really_inline base16_numeric(const __m256i _value)
                        : base16<T>(_value)
                    {
                    }

                    // Store to array
                    simdutf_really_inline void store(T dst[8]) const
                    {
                        return __lasx_xvst(this->value, reinterpret_cast<__m256i*>(dst), 0);
                    }

                    // Override to distinguish from bool version
                    simdutf_really_inline simd16<T> operator~() const { return *this ^ 0xFFFFu; }

                    // Addition/subtraction are the same for signed and unsigned
                    simdutf_really_inline simd16<T> operator+(const simd16<T> other) const
                    {
                        return __lasx_xvadd_h(*this, other);
                    }
                    simdutf_really_inline simd16<T> operator-(const simd16<T> other) const
                    {
                        return __lasx_xvsub_h(*this, other);
                    }
                    simdutf_really_inline simd16<T>& operator+=(const simd16<T> other)
                    {
                        *this = *this + other;
                        return *static_cast<simd16<T>*>(this);
                    }
                    simdutf_really_inline simd16<T>& operator-=(const simd16<T> other)
                    {
                        *this = *this - other;
                        return *static_cast<simd16<T>*>(this);
                    }
                };

                // Signed code units
                template <>
                struct simd16<int16_t> : base16_numeric<int16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<int16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const __m256i _value)
                        : base16_numeric<int16_t>(_value)
                    {
                    }
                    // Splat constructor
                    simdutf_really_inline simd16(int16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const int16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const int16_t*>(values)))
                    {
                    }
                    // Order-sensitive comparisons
                    simdutf_really_inline simd16<int16_t>
                    max_val(const simd16<int16_t> other) const
                    {
                        return __lasx_xvmax_h(*this, other);
                    }
                    simdutf_really_inline simd16<int16_t>
                    min_val(const simd16<int16_t> other) const
                    {
                        return __lasx_xvmin_h(*this, other);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<int16_t> other) const
                    {
                        return __lasx_xvsle_h(other.value, this->value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<int16_t> other) const
                    {
                        return __lasx_xvslt_h(this->value, other.value);
                    }
                };

                // Unsigned code units
                template <>
                struct simd16<uint16_t> : base16_numeric<uint16_t>
                {
                    simdutf_really_inline simd16()
                        : base16_numeric<uint16_t>()
                    {
                    }
                    simdutf_really_inline simd16(const __m256i _value)
                        : base16_numeric<uint16_t>(_value)
                    {
                    }

                    // Splat constructor
                    simdutf_really_inline simd16(uint16_t _value)
                        : simd16(splat(_value))
                    {
                    }
                    // Array constructor
                    simdutf_really_inline simd16(const uint16_t* values)
                        : simd16(load(values))
                    {
                    }
                    simdutf_really_inline simd16(const char16_t* values)
                        : simd16(load(reinterpret_cast<const uint16_t*>(values)))
                    {
                    }

                    // Saturated math
                    simdutf_really_inline simd16<uint16_t>
                    saturating_add(const simd16<uint16_t> other) const
                    {
                        return __lasx_xvsadd_hu(this->value, other.value);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    saturating_sub(const simd16<uint16_t> other) const
                    {
                        return __lasx_xvssub_hu(this->value, other.value);
                    }

                    // Order-specific operations
                    simdutf_really_inline simd16<uint16_t>
                    max_val(const simd16<uint16_t> other) const
                    {
                        return __lasx_xvmax_hu(this->value, other.value);
                    }
                    simdutf_really_inline simd16<uint16_t>
                    min_val(const simd16<uint16_t> other) const
                    {
                        return __lasx_xvmin_hu(this->value, other.value);
                    }
                    // Same as >, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    gt_bits(const simd16<uint16_t> other) const
                    {
                        return this->saturating_sub(other);
                    }
                    // Same as <, but only guarantees true is nonzero (< guarantees true = -1)
                    simdutf_really_inline simd16<uint16_t>
                    lt_bits(const simd16<uint16_t> other) const
                    {
                        return other.saturating_sub(*this);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<=(const simd16<uint16_t> other) const
                    {
                        return __lasx_xvsle_hu(this->value, other.value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>=(const simd16<uint16_t> other) const
                    {
                        return __lasx_xvsle_hu(other.value, this->value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator>(const simd16<uint16_t> other) const
                    {
                        return __lasx_xvslt_hu(other.value, this->value);
                    }
                    simdutf_really_inline simd16<bool>
                    operator<(const simd16<uint16_t> other) const
                    {
                        return __lasx_xvslt_hu(this->value, other.value);
                    }

                    // Bit-specific operations
                    simdutf_really_inline simd16<bool> bits_not_set() const
                    {
                        return *this == uint16_t(0);
                    }
                    simdutf_really_inline simd16<bool> bits_not_set(simd16<uint16_t> bits) const
                    {
                        return (*this & bits).bits_not_set();
                    }
                    simdutf_really_inline simd16<bool> any_bits_set() const
                    {
                        return ~this->bits_not_set();
                    }
                    simdutf_really_inline simd16<bool> any_bits_set(simd16<uint16_t> bits) const
                    {
                        return ~this->bits_not_set(bits);
                    }

                    simdutf_really_inline bool any_bits_set_anywhere() const
                    {
                        if (__lasx_xbnz_v(this->value))
                            return true;
                        return false;
                    }
                    simdutf_really_inline bool
                    any_bits_set_anywhere(simd16<uint16_t> bits) const
                    {
                        return (*this & bits).any_bits_set_anywhere();
                    }

                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shr() const
                    {
                        return simd16<uint16_t>(__lasx_xvsrli_h(this->value, N));
                    }
                    template <int N>
                    simdutf_really_inline simd16<uint16_t> shl() const
                    {
                        return simd16<uint16_t>(__lasx_xvslli_h(this->value, N));
                    }

                    // Change the endianness
                    simdutf_really_inline simd16<uint16_t> swap_bytes() const
                    {
                        return __lasx_xvshuf4i_b(this->value, 0b10110001);
                    }

                    template <unsigned N>
                    static simdutf_really_inline simd8<uint8_t>
                    pack_shifted_right(const simd16<uint16_t>& v0, const simd16<uint16_t>& v1)
                    {
                        return __lasx_xvpermi_d(__lasx_xvssrlni_bu_h(v1.value, v0.value, N),
                            0b11011000);
                    }

                    // Pack with the unsigned saturation of two uint16_t code units into single
                    // uint8_t vector
                    static simdutf_really_inline simd8<uint8_t> pack(const simd16<uint16_t>& v0,
                        const simd16<uint16_t>& v1)
                    {

                        return pack_shifted_right<0>(v0, v1);
                    }
                };

                template <typename T>
                struct simd16x32
                {
                    static constexpr int NUM_CHUNKS = 64 / sizeof(simd16<T>);
                    static_assert(NUM_CHUNKS == 2,
                        "LASX kernel should use two registers per 64-byte block.");
                    simd16<T> chunks[NUM_CHUNKS];

                    simd16x32(const simd16x32<T>& o) = delete; // no copy allowed
                    simd16x32<T>&
                    operator=(const simd16<T> other)
                        = delete; // no assignment allowed
                    simd16x32() = delete; // no default constructor allowed

                    simdutf_really_inline simd16x32(const simd16<T> chunk0,
                        const simd16<T> chunk1)
                        : chunks { chunk0, chunk1 }
                    {
                    }
                    simdutf_really_inline simd16x32(const T* ptr)
                        : chunks { simd16<T>::load(ptr),
                            simd16<T>::load(ptr + sizeof(simd16<T>) / sizeof(T)) }
                    {
                    }

                    simdutf_really_inline void store(T* ptr) const
                    {
                        this->chunks[0].store(ptr + sizeof(simd16<T>) * 0 / sizeof(T));
                        this->chunks[1].store(ptr + sizeof(simd16<T>) * 1 / sizeof(T));
                    }

                    simdutf_really_inline uint64_t to_bitmask() const
                    {
                        uint64_t r_lo = uint32_t(this->chunks[0].to_bitmask());
                        uint64_t r_hi = this->chunks[1].to_bitmask();
                        return r_lo | (r_hi << 32);
                    }

                    simdutf_really_inline simd16<T> reduce_or() const
                    {
                        return this->chunks[0] | this->chunks[1];
                    }

                    simdutf_really_inline bool is_ascii() const
                    {
                        return this->reduce_or().is_ascii();
                    }

                    simdutf_really_inline void store_ascii_as_utf16(char16_t* ptr) const
                    {
                        this->chunks[0].store_ascii_as_utf16(ptr + sizeof(simd16<T>) * 0);
                        this->chunks[1].store_ascii_as_utf16(ptr + sizeof(simd16<T>));
                    }

                    simdutf_really_inline simd16x32<T> bit_or(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<T>(this->chunks[0] | mask, this->chunks[1] | mask);
                    }

                    simdutf_really_inline void swap_bytes()
                    {
                        this->chunks[0] = this->chunks[0].swap_bytes();
                        this->chunks[1] = this->chunks[1].swap_bytes();
                    }

                    simdutf_really_inline uint64_t eq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] == mask, this->chunks[1] == mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t eq(const simd16x32<uint16_t>& other) const
                    {
                        return simd16x32<bool>(this->chunks[0] == other.chunks[0],
                            this->chunks[1] == other.chunks[1])
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t lteq(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] <= mask, this->chunks[1] <= mask)
                            .to_bitmask();
                    }

                    simdutf_really_inline uint64_t in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(low);
                        const simd16<T> mask_high = simd16<T>::splat(high);

                        return simd16x32<bool>(
                            (this->chunks[0] <= mask_high) & (this->chunks[0] >= mask_low),
                            (this->chunks[1] <= mask_high) & (this->chunks[1] >= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t not_in_range(const T low, const T high) const
                    {
                        const simd16<T> mask_low = simd16<T>::splat(static_cast<T>(low - 1));
                        const simd16<T> mask_high = simd16<T>::splat(static_cast<T>(high + 1));
                        return simd16x32<bool>(
                            (this->chunks[0] >= mask_high) | (this->chunks[0] <= mask_low),
                            (this->chunks[1] >= mask_high) | (this->chunks[1] <= mask_low))
                            .to_bitmask();
                    }
                    simdutf_really_inline uint64_t lt(const T m) const
                    {
                        const simd16<T> mask = simd16<T>::splat(m);
                        return simd16x32<bool>(this->chunks[0] < mask, this->chunks[1] < mask)
                            .to_bitmask();
                    }
                }; // struct simd16x32<T>
                /* end file src/simdutf/lasx/simd16-inl.h */
                /* begin file src/simdutf/lasx/simd32-inl.h */
                template <typename T>
                struct simd32;

                template <>
                struct simd32<uint32_t>
                {
                    __m256i value;
                    static const int SIZE = sizeof(value);
                    static const int ELEMENTS = SIZE / sizeof(uint32_t);

                    // constructors
                    simdutf_really_inline simd32(__m256i v)
                        : value(v)
                    {
                    }

                    template <typename Ptr>
                    simdutf_really_inline simd32(Ptr* ptr)
                        : value(__lasx_xvld(ptr, 0))
                    {
                    }

                    // in-place operators
                    simdutf_really_inline simd32& operator-=(const simd32 other)
                    {
                        value = __lasx_xvsub_w(value, other.value);
                        return *this;
                    }

                    // members
                    simdutf_really_inline uint64_t sum() const
                    {
                        const auto odd = __lasx_xvsrli_d(value, 32);
                        const auto even = __lasx_xvand_v(value, __lasx_xvreplgr2vr_d(0xffffffff));

                        const auto sum64 = __lasx_xvadd_d(odd, even);

                        return uint64_t(__lasx_xvpickve2gr_du(sum64, 0)) + uint64_t(__lasx_xvpickve2gr_du(sum64, 1)) + uint64_t(__lasx_xvpickve2gr_du(sum64, 2)) + uint64_t(__lasx_xvpickve2gr_du(sum64, 3));
                    }

                    // static members
                    static simdutf_really_inline simd32<uint32_t> splat(uint32_t x)
                    {
                        return __lasx_xvreplgr2vr_w(x);
                    }

                    static simdutf_really_inline simd32<uint32_t> zero()
                    {
                        return __lasx_xvrepli_w(0);
                    }
                };

                // ------------------------------------------------------------

                template <>
                struct simd32<bool>
                {
                    __m256i value;
                    static const int SIZE = sizeof(value);

                    // constructors
                    simdutf_really_inline simd32(__m256i v)
                        : value(v)
                    {
                    }
                };

                // ------------------------------------------------------------

                simdutf_really_inline simd32<uint32_t> operator&(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return __lasx_xvor_v(a.value, b.value);
                }

                simdutf_really_inline simd32<bool> operator<(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return __lasx_xvslt_wu(a.value, b.value);
                }

                simdutf_really_inline simd32<bool> operator>(const simd32<uint32_t> a,
                    const simd32<uint32_t> b)
                {
                    return __lasx_xvslt_wu(b.value, a.value);
                }

                // ------------------------------------------------------------

                simdutf_really_inline simd32<uint32_t> as_vector_u32(const simd32<bool> v)
                {
                    return v.value;
                }
                /* end file src/simdutf/lasx/simd32-inl.h */

            } // namespace simd
        } // unnamed namespace
    } // namespace lasx
} // namespace simdutf

        #endif // SIMDUTF_LASX_SIMD_H
        /* end file src/simdutf/lasx/simd.h */

        /* begin file src/simdutf/lasx/end.h */
        #undef SIMDUTF_SIMD_HAS_UNSIGNED_CMP
    /* end file src/simdutf/lasx/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_LASX

#endif // SIMDUTF_LASX_H
/* end file src/simdutf/lasx.h */
/* begin file src/simdutf/fallback.h */
#ifndef SIMDUTF_FALLBACK_H
    #define SIMDUTF_FALLBACK_H

    // Note that fallback.h is always imported last.

    // Default Fallback to on unless a builtin implementation has already been
    // selected.
    #ifndef SIMDUTF_IMPLEMENTATION_FALLBACK
        #if SIMDUTF_CAN_ALWAYS_RUN_ARM64 || SIMDUTF_CAN_ALWAYS_RUN_ICELAKE || SIMDUTF_CAN_ALWAYS_RUN_HASWELL || SIMDUTF_CAN_ALWAYS_RUN_WESTMERE || SIMDUTF_CAN_ALWAYS_RUN_PPC64 || SIMDUTF_CAN_ALWAYS_RUN_RVV || SIMDUTF_CAN_ALWAYS_RUN_LSX || SIMDUTF_CAN_ALWAYS_RUN_LASX
            #define SIMDUTF_IMPLEMENTATION_FALLBACK 0
        #else
            #define SIMDUTF_IMPLEMENTATION_FALLBACK 1
        #endif
    #endif

    #define SIMDUTF_CAN_ALWAYS_RUN_FALLBACK (SIMDUTF_IMPLEMENTATION_FALLBACK)

    #if SIMDUTF_IMPLEMENTATION_FALLBACK

namespace simdutf
{
    /**
     * Fallback implementation (runs on any machine).
     */
    namespace fallback
    {
    } // namespace fallback
} // namespace simdutf

        /* begin file src/simdutf/fallback/implementation.h */
        #ifndef SIMDUTF_FALLBACK_IMPLEMENTATION_H
            #define SIMDUTF_FALLBACK_IMPLEMENTATION_H

namespace simdutf
{
    namespace fallback
    {

        namespace
        {
            using namespace simdutf;
        }

        class implementation final : public simdutf::implementation
        {
        public:
            simdutf_really_inline implementation()
                : simdutf::implementation("fallback", "Generic fallback implementation",
                      0)
            {
            }

            simdutf_warn_unused bool validate_utf8(const char* buf,
                size_t len) const noexcept final;

            simdutf_warn_unused result
            validate_utf8_with_errors(const char* buf, size_t len) const noexcept final;

            simdutf_warn_unused size_t count_utf8(const char* buf,
                size_t length) const noexcept;
        };
    } // namespace fallback
} // namespace simdutf

        #endif // SIMDUTF_FALLBACK_IMPLEMENTATION_H
    /* end file src/simdutf/fallback/implementation.h */

    /* begin file src/simdutf/fallback/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "fallback"
    // #define SIMDUTF_IMPLEMENTATION fallback
    /* end file src/simdutf/fallback/begin.h */

    // Declarations
        /* begin file src/simdutf/fallback/bitmanipulation.h */
        #ifndef SIMDUTF_FALLBACK_BITMANIPULATION_H
            #define SIMDUTF_FALLBACK_BITMANIPULATION_H

            #include <limits>

namespace simdutf
{
    namespace fallback
    {
        namespace
        {
        } // unnamed namespace
    } // namespace fallback
} // namespace simdutf

        #endif // SIMDUTF_FALLBACK_BITMANIPULATION_H
    /* end file src/simdutf/fallback/bitmanipulation.h */

    /* begin file src/simdutf/fallback/end.h */
    /* end file src/simdutf/fallback/end.h */

    #endif // SIMDUTF_IMPLEMENTATION_FALLBACK
#endif // SIMDUTF_FALLBACK_H
/* end file src/simdutf/fallback.h */

// The scalar routines should be included once.
/* begin file src/scalar/swap_bytes.h */
#ifndef SIMDUTF_SWAP_BYTES_H
    #define SIMDUTF_SWAP_BYTES_H

namespace simdutf
{
    namespace scalar
    {

        inline simdutf_warn_unused uint16_t u16_swap_bytes(const uint16_t word)
        {
            return uint16_t((word >> 8) | (word << 8));
        }

        inline simdutf_warn_unused uint32_t u32_swap_bytes(const uint32_t word)
        {
            return ((word >> 24) & 0xff) | // move byte 3 to byte 0
                ((word << 8) & 0xff0000) | // move byte 1 to byte 2
                ((word >> 8) & 0xff00) | // move byte 2 to byte 1
                ((word << 24) & 0xff000000); // byte 0 to byte 3
        }

    } // namespace scalar
} // namespace simdutf

#endif
/* end file src/scalar/swap_bytes.h */
/* begin file src/scalar/utf8.h */
#ifndef SIMDUTF_UTF8_H
    #define SIMDUTF_UTF8_H

namespace simdutf
{
    namespace scalar
    {
        namespace
        {
            namespace utf8
            {
    #if SIMDUTF_IMPLEMENTATION_FALLBACK || SIMDUTF_IMPLEMENTATION_RVV
                // only used by the fallback kernel.
                // credit: based on code from Google Fuchsia (Apache Licensed)
                inline simdutf_warn_unused bool validate(const char* buf, size_t len) noexcept
                {
                    const uint8_t* data = reinterpret_cast<const uint8_t*>(buf);
                    uint64_t pos = 0;
                    uint32_t code_point = 0;
                    while (pos < len)
                    {
                        // check of the next 16 bytes are ascii.
                        uint64_t next_pos = pos + 16;
                        if (next_pos <= len)
                        { // if it is safe to read 16 more bytes, check that they are ascii
                            uint64_t v1;
                            std::memcpy(&v1, data + pos, sizeof(uint64_t));
                            uint64_t v2;
                            std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
                            uint64_t v { v1 | v2 };
                            if ((v & 0x8080808080808080) == 0)
                            {
                                pos = next_pos;
                                continue;
                            }
                        }
                        unsigned char byte = data[pos];

                        while (byte < 0b10000000)
                        {
                            if (++pos == len)
                            {
                                return true;
                            }
                            byte = data[pos];
                        }

                        if ((byte & 0b11100000) == 0b11000000)
                        {
                            next_pos = pos + 2;
                            if (next_pos > len)
                            {
                                return false;
                            }
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return false;
                            }
                            // range check
                            code_point = (byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
                            if ((code_point < 0x80) || (0x7ff < code_point))
                            {
                                return false;
                            }
                        }
                        else if ((byte & 0b11110000) == 0b11100000)
                        {
                            next_pos = pos + 3;
                            if (next_pos > len)
                            {
                                return false;
                            }
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return false;
                            }
                            if ((data[pos + 2] & 0b11000000) != 0b10000000)
                            {
                                return false;
                            }
                            // range check
                            code_point = (byte & 0b00001111) << 12 | (data[pos + 1] & 0b00111111) << 6 | (data[pos + 2] & 0b00111111);
                            if ((code_point < 0x800) || (0xffff < code_point) || (0xd7ff < code_point && code_point < 0xe000))
                            {
                                return false;
                            }
                        }
                        else if ((byte & 0b11111000) == 0b11110000)
                        { // 0b11110000
                            next_pos = pos + 4;
                            if (next_pos > len)
                            {
                                return false;
                            }
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return false;
                            }
                            if ((data[pos + 2] & 0b11000000) != 0b10000000)
                            {
                                return false;
                            }
                            if ((data[pos + 3] & 0b11000000) != 0b10000000)
                            {
                                return false;
                            }
                            // range check
                            code_point = (byte & 0b00000111) << 18 | (data[pos + 1] & 0b00111111) << 12 | (data[pos + 2] & 0b00111111) << 6 | (data[pos + 3] & 0b00111111);
                            if (code_point <= 0xffff || 0x10ffff < code_point)
                            {
                                return false;
                            }
                        }
                        else
                        {
                            // we may have a continuation
                            return false;
                        }
                        pos = next_pos;
                    }
                    return true;
                }
    #endif

                inline simdutf_warn_unused result validate_with_errors(const char* buf,
                    size_t len) noexcept
                {
                    const uint8_t* data = reinterpret_cast<const uint8_t*>(buf);
                    size_t pos = 0;
                    uint32_t code_point = 0;
                    while (pos < len)
                    {
                        // check of the next 16 bytes are ascii.
                        size_t next_pos = pos + 16;
                        if (next_pos <= len)
                        { // if it is safe to read 16 more bytes, check that they are ascii
                            uint64_t v1;
                            std::memcpy(&v1, data + pos, sizeof(uint64_t));
                            uint64_t v2;
                            std::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
                            uint64_t v { v1 | v2 };
                            if ((v & 0x8080808080808080) == 0)
                            {
                                pos = next_pos;
                                continue;
                            }
                        }
                        unsigned char byte = data[pos];

                        while (byte < 0b10000000)
                        {
                            if (++pos == len)
                            {
                                return result(error_code::SUCCESS, len);
                            }
                            byte = data[pos];
                        }

                        if ((byte & 0b11100000) == 0b11000000)
                        {
                            next_pos = pos + 2;
                            if (next_pos > len)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            // range check
                            code_point = (byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
                            if ((code_point < 0x80) || (0x7ff < code_point))
                            {
                                return result(error_code::OVERLONG, pos);
                            }
                        }
                        else if ((byte & 0b11110000) == 0b11100000)
                        {
                            next_pos = pos + 3;
                            if (next_pos > len)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 2] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            // range check
                            code_point = (byte & 0b00001111) << 12 | (data[pos + 1] & 0b00111111) << 6 | (data[pos + 2] & 0b00111111);
                            if ((code_point < 0x800) || (0xffff < code_point))
                            {
                                return result(error_code::OVERLONG, pos);
                            }
                            if (0xd7ff < code_point && code_point < 0xe000)
                            {
                                return result(error_code::SURROGATE, pos);
                            }
                        }
                        else if ((byte & 0b11111000) == 0b11110000)
                        { // 0b11110000
                            next_pos = pos + 4;
                            if (next_pos > len)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 2] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 3] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            // range check
                            code_point = (byte & 0b00000111) << 18 | (data[pos + 1] & 0b00111111) << 12 | (data[pos + 2] & 0b00111111) << 6 | (data[pos + 3] & 0b00111111);
                            if (code_point <= 0xffff)
                            {
                                return result(error_code::OVERLONG, pos);
                            }
                            if (0x10ffff < code_point)
                            {
                                return result(error_code::TOO_LARGE, pos);
                            }
                        }
                        else
                        {
                            // we either have too many continuation bytes or an invalid leading byte
                            if ((byte & 0b11000000) == 0b10000000)
                            {
                                return result(error_code::TOO_LONG, pos);
                            }
                            else
                            {
                                return result(error_code::HEADER_BITS, pos);
                            }
                        }
                        pos = next_pos;
                    }
                    return result(error_code::SUCCESS, len);
                }

                // Finds the previous leading byte starting backward from buf and validates with
                // errors from there Used to pinpoint the location of an error when an invalid
                // chunk is detected We assume that the stream starts with a leading byte, and
                // to check that it is the case, we ask that you pass a pointer to the start of
                // the stream (start).
                inline simdutf_warn_unused result rewind_and_validate_with_errors(
                    const char* start, const char* buf, size_t len) noexcept
                {
                    // First check that we start with a leading byte
                    if ((*start & 0b11000000) == 0b10000000)
                    {
                        return result(error_code::TOO_LONG, 0);
                    }
                    size_t extra_len { 0 };
                    // A leading byte cannot be further than 4 bytes away
                    for (int i = 0; i < 5; i++)
                    {
                        unsigned char byte = *buf;
                        if ((byte & 0b11000000) != 0b10000000)
                        {
                            break;
                        }
                        else
                        {
                            buf--;
                            extra_len++;
                        }
                    }

                    result res = validate_with_errors(buf, len + extra_len);
                    res.count -= extra_len;
                    return res;
                }

                inline size_t count_code_points(const char* buf, size_t len)
                {
                    const int8_t* p = reinterpret_cast<const int8_t*>(buf);
                    size_t counter { 0 };
                    for (size_t i = 0; i < len; i++)
                    {
                        // -65 is 0b10111111, anything larger in two-complement's should start a new
                        // code point.
                        if (p[i] > -65)
                        {
                            counter++;
                        }
                    }
                    return counter;
                }

                inline size_t utf16_length_from_utf8(const char* buf, size_t len)
                {
                    const int8_t* p = reinterpret_cast<const int8_t*>(buf);
                    size_t counter { 0 };
                    for (size_t i = 0; i < len; i++)
                    {
                        if (p[i] > -65)
                        {
                            counter++;
                        }
                        if (uint8_t(p[i]) >= 240)
                        {
                            counter++;
                        }
                    }
                    return counter;
                }

                simdutf_warn_unused inline size_t trim_partial_utf8(const char* input,
                    size_t length)
                {
                    if (length < 3)
                    {
                        switch (length)
                        {
                            case 2:
                                if (uint8_t(input[length - 1]) >= 0xc0)
                                {
                                    return length - 1;
                                } // 2-, 3- and 4-byte characters with only 1 byte left
                                if (uint8_t(input[length - 2]) >= 0xe0)
                                {
                                    return length - 2;
                                } // 3- and 4-byte characters with only 2 bytes left
                                return length;
                            case 1:
                                if (uint8_t(input[length - 1]) >= 0xc0)
                                {
                                    return length - 1;
                                } // 2-, 3- and 4-byte characters with only 1 byte left
                                return length;
                            case 0:
                                return length;
                            default:
                                break;
                        }
                    }
                    if (uint8_t(input[length - 1]) >= 0xc0)
                    {
                        return length - 1;
                    } // 2-, 3- and 4-byte characters with only 1 byte left
                    if (uint8_t(input[length - 2]) >= 0xe0)
                    {
                        return length - 2;
                    } // 3- and 4-byte characters with only 1 byte left
                    if (uint8_t(input[length - 3]) >= 0xf0)
                    {
                        return length - 3;
                    } // 4-byte characters with only 3 bytes left
                    return length;
                }

            } // namespace utf8
        } // unnamed namespace
    } // namespace scalar
} // namespace simdutf

#endif
/* end file src/scalar/utf8.h */

/* begin file src/scalar/utf8_to_utf32/valid_utf8_to_utf32.h */
#ifndef SIMDUTF_VALID_UTF8_TO_UTF32_H
    #define SIMDUTF_VALID_UTF8_TO_UTF32_H

namespace simdutf
{
    namespace scalar
    {
        namespace
        {
            namespace utf8_to_utf32
            {

                inline size_t convert_valid(const char* buf, size_t len,
                    char32_t* utf32_output)
                {
                    const uint8_t* data = reinterpret_cast<const uint8_t*>(buf);
                    size_t pos = 0;
                    char32_t* start { utf32_output };
                    while (pos < len)
                    {
                        // try to convert the next block of 8 ASCII bytes
                        if (pos + 8 <= len)
                        { // if it is safe to read 8 more bytes, check that they are ascii
                            uint64_t v;
                            ::memcpy(&v, data + pos, sizeof(uint64_t));
                            if ((v & 0x8080808080808080) == 0)
                            {
                                size_t final_pos = pos + 8;
                                while (pos < final_pos)
                                {
                                    *utf32_output++ = char32_t(buf[pos]);
                                    pos++;
                                }
                                continue;
                            }
                        }
                        uint8_t leading_byte = data[pos]; // leading byte
                        if (leading_byte < 0b10000000)
                        {
                            // converting one ASCII byte !!!
                            *utf32_output++ = char32_t(leading_byte);
                            pos++;
                        }
                        else if ((leading_byte & 0b11100000) == 0b11000000)
                        {
                            // We have a two-byte UTF-8
                            if (pos + 1 >= len)
                            {
                                break;
                            } // minimal bound checking
                            *utf32_output++ = char32_t(((leading_byte & 0b00011111) << 6) | (data[pos + 1] & 0b00111111));
                            pos += 2;
                        }
                        else if ((leading_byte & 0b11110000) == 0b11100000)
                        {
                            // We have a three-byte UTF-8
                            if (pos + 2 >= len)
                            {
                                break;
                            } // minimal bound checking
                            *utf32_output++ = char32_t(((leading_byte & 0b00001111) << 12) | ((data[pos + 1] & 0b00111111) << 6) | (data[pos + 2] & 0b00111111));
                            pos += 3;
                        }
                        else if ((leading_byte & 0b11111000) == 0b11110000)
                        { // 0b11110000
                            // we have a 4-byte UTF-8 word.
                            if (pos + 3 >= len)
                            {
                                break;
                            } // minimal bound checking
                            uint32_t code_word = ((leading_byte & 0b00000111) << 18) | ((data[pos + 1] & 0b00111111) << 12) | ((data[pos + 2] & 0b00111111) << 6) | (data[pos + 3] & 0b00111111);
                            *utf32_output++ = char32_t(code_word);
                            pos += 4;
                        }
                        else
                        {
                            // we may have a continuation but we do not do error checking
                            return 0;
                        }
                    }
                    return utf32_output - start;
                }

            } // namespace utf8_to_utf32
        } // unnamed namespace
    } // namespace scalar
} // namespace simdutf

#endif
/* end file src/scalar/utf8_to_utf32/valid_utf8_to_utf32.h */
/* begin file src/scalar/utf8_to_utf32/utf8_to_utf32.h */
#ifndef SIMDUTF_UTF8_TO_UTF32_H
    #define SIMDUTF_UTF8_TO_UTF32_H

namespace simdutf
{
    namespace scalar
    {
        namespace
        {
            namespace utf8_to_utf32
            {

                inline size_t convert(const char* buf, size_t len, char32_t* utf32_output)
                {
                    const uint8_t* data = reinterpret_cast<const uint8_t*>(buf);
                    size_t pos = 0;
                    char32_t* start { utf32_output };
                    while (pos < len)
                    {
                        // try to convert the next block of 16 ASCII bytes
                        if (pos + 16 <= len)
                        { // if it is safe to read 16 more bytes, check that they are ascii
                            uint64_t v1;
                            ::memcpy(&v1, data + pos, sizeof(uint64_t));
                            uint64_t v2;
                            ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
                            uint64_t v { v1 | v2 };
                            if ((v & 0x8080808080808080) == 0)
                            {
                                size_t final_pos = pos + 16;
                                while (pos < final_pos)
                                {
                                    *utf32_output++ = char32_t(buf[pos]);
                                    pos++;
                                }
                                continue;
                            }
                        }
                        uint8_t leading_byte = data[pos]; // leading byte
                        if (leading_byte < 0b10000000)
                        {
                            // converting one ASCII byte !!!
                            *utf32_output++ = char32_t(leading_byte);
                            pos++;
                        }
                        else if ((leading_byte & 0b11100000) == 0b11000000)
                        {
                            // We have a two-byte UTF-8
                            if (pos + 1 >= len)
                            {
                                return 0;
                            } // minimal bound checking
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return 0;
                            }
                            // range check
                            uint32_t code_point = (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
                            if (code_point < 0x80 || 0x7ff < code_point)
                            {
                                return 0;
                            }
                            *utf32_output++ = char32_t(code_point);
                            pos += 2;
                        }
                        else if ((leading_byte & 0b11110000) == 0b11100000)
                        {
                            // We have a three-byte UTF-8
                            if (pos + 2 >= len)
                            {
                                return 0;
                            } // minimal bound checking

                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return 0;
                            }
                            if ((data[pos + 2] & 0b11000000) != 0b10000000)
                            {
                                return 0;
                            }
                            // range check
                            uint32_t code_point = (leading_byte & 0b00001111) << 12 | (data[pos + 1] & 0b00111111) << 6 | (data[pos + 2] & 0b00111111);
                            if (code_point < 0x800 || 0xffff < code_point || (0xd7ff < code_point && code_point < 0xe000))
                            {
                                return 0;
                            }
                            *utf32_output++ = char32_t(code_point);
                            pos += 3;
                        }
                        else if ((leading_byte & 0b11111000) == 0b11110000)
                        { // 0b11110000
                            // we have a 4-byte UTF-8 word.
                            if (pos + 3 >= len)
                            {
                                return 0;
                            } // minimal bound checking
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return 0;
                            }
                            if ((data[pos + 2] & 0b11000000) != 0b10000000)
                            {
                                return 0;
                            }
                            if ((data[pos + 3] & 0b11000000) != 0b10000000)
                            {
                                return 0;
                            }

                            // range check
                            uint32_t code_point = (leading_byte & 0b00000111) << 18 | (data[pos + 1] & 0b00111111) << 12 | (data[pos + 2] & 0b00111111) << 6 | (data[pos + 3] & 0b00111111);
                            if (code_point <= 0xffff || 0x10ffff < code_point)
                            {
                                return 0;
                            }
                            *utf32_output++ = char32_t(code_point);
                            pos += 4;
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return utf32_output - start;
                }

                inline result convert_with_errors(const char* buf, size_t len,
                    char32_t* utf32_output)
                {
                    const uint8_t* data = reinterpret_cast<const uint8_t*>(buf);
                    size_t pos = 0;
                    char32_t* start { utf32_output };
                    while (pos < len)
                    {
                        // try to convert the next block of 16 ASCII bytes
                        if (pos + 16 <= len)
                        { // if it is safe to read 16 more bytes, check that they are ascii
                            uint64_t v1;
                            ::memcpy(&v1, data + pos, sizeof(uint64_t));
                            uint64_t v2;
                            ::memcpy(&v2, data + pos + sizeof(uint64_t), sizeof(uint64_t));
                            uint64_t v { v1 | v2 };
                            if ((v & 0x8080808080808080) == 0)
                            {
                                size_t final_pos = pos + 16;
                                while (pos < final_pos)
                                {
                                    *utf32_output++ = char32_t(buf[pos]);
                                    pos++;
                                }
                                continue;
                            }
                        }
                        uint8_t leading_byte = data[pos]; // leading byte
                        if (leading_byte < 0b10000000)
                        {
                            // converting one ASCII byte !!!
                            *utf32_output++ = char32_t(leading_byte);
                            pos++;
                        }
                        else if ((leading_byte & 0b11100000) == 0b11000000)
                        {
                            // We have a two-byte UTF-8
                            if (pos + 1 >= len)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            } // minimal bound checking
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            // range check
                            uint32_t code_point = (leading_byte & 0b00011111) << 6 | (data[pos + 1] & 0b00111111);
                            if (code_point < 0x80 || 0x7ff < code_point)
                            {
                                return result(error_code::OVERLONG, pos);
                            }
                            *utf32_output++ = char32_t(code_point);
                            pos += 2;
                        }
                        else if ((leading_byte & 0b11110000) == 0b11100000)
                        {
                            // We have a three-byte UTF-8
                            if (pos + 2 >= len)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            } // minimal bound checking

                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 2] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            // range check
                            uint32_t code_point = (leading_byte & 0b00001111) << 12 | (data[pos + 1] & 0b00111111) << 6 | (data[pos + 2] & 0b00111111);
                            if (code_point < 0x800 || 0xffff < code_point)
                            {
                                return result(error_code::OVERLONG, pos);
                            }
                            if (0xd7ff < code_point && code_point < 0xe000)
                            {
                                return result(error_code::SURROGATE, pos);
                            }
                            *utf32_output++ = char32_t(code_point);
                            pos += 3;
                        }
                        else if ((leading_byte & 0b11111000) == 0b11110000)
                        { // 0b11110000
                            // we have a 4-byte UTF-8 word.
                            if (pos + 3 >= len)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            } // minimal bound checking
                            if ((data[pos + 1] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 2] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }
                            if ((data[pos + 3] & 0b11000000) != 0b10000000)
                            {
                                return result(error_code::TOO_SHORT, pos);
                            }

                            // range check
                            uint32_t code_point = (leading_byte & 0b00000111) << 18 | (data[pos + 1] & 0b00111111) << 12 | (data[pos + 2] & 0b00111111) << 6 | (data[pos + 3] & 0b00111111);
                            if (code_point <= 0xffff)
                            {
                                return result(error_code::OVERLONG, pos);
                            }
                            if (0x10ffff < code_point)
                            {
                                return result(error_code::TOO_LARGE, pos);
                            }
                            *utf32_output++ = char32_t(code_point);
                            pos += 4;
                        }
                        else
                        {
                            // we either have too many continuation bytes or an invalid leading byte
                            if ((leading_byte & 0b11000000) == 0b10000000)
                            {
                                return result(error_code::TOO_LONG, pos);
                            }
                            else
                            {
                                return result(error_code::HEADER_BITS, pos);
                            }
                        }
                    }
                    return result(error_code::SUCCESS, utf32_output - start);
                }

                /**
                 * When rewind_and_convert_with_errors is called, we are pointing at 'buf' and
                 * we have up to len input bytes left, and we encountered some error. It is
                 * possible that the error is at 'buf' exactly, but it could also be in the
                 * previous bytes location (up to 3 bytes back).
                 *
                 * prior_bytes indicates how many bytes, prior to 'buf' may belong to the
                 * current memory section and can be safely accessed. We prior_bytes to access
                 * safely up to three bytes before 'buf'.
                 *
                 * The caller is responsible to ensure that len > 0.
                 *
                 * If the error is believed to have occurred prior to 'buf', the count value
                 * contain in the result will be SIZE_T - 1, SIZE_T - 2, or SIZE_T - 3.
                 */
                inline result rewind_and_convert_with_errors(size_t prior_bytes,
                    const char* buf, size_t len,
                    char32_t* utf32_output)
                {
                    size_t extra_len { 0 };
                    // We potentially need to go back in time and find a leading byte.
                    size_t how_far_back = 3; // 3 bytes in the past + current position
                    if (how_far_back > prior_bytes)
                    {
                        how_far_back = prior_bytes;
                    }
                    bool found_leading_bytes { false };
                    // important: it is i <= how_far_back and not 'i < how_far_back'.
                    for (size_t i = 0; i <= how_far_back; i++)
                    {
                        unsigned char byte = buf[-static_cast<std::ptrdiff_t>(i)];
                        found_leading_bytes = ((byte & 0b11000000) != 0b10000000);
                        if (found_leading_bytes)
                        {
                            if (i > 0 && byte < 128)
                            {
                                // If we had to go back and the leading byte is ascii
                                // then we can stop right away.
                                return result(error_code::TOO_LONG, 0 - i + 1);
                            }
                            buf -= i;
                            extra_len = i;
                            break;
                        }
                    }
                    //
                    // It is possible for this function to return a negative count in its result.
                    // C++ Standard Section 18.1 defines size_t is in <cstddef> which is described
                    // in C Standard as <stddef.h>. C Standard Section 4.1.5 defines size_t as an
                    // unsigned integral type of the result of the sizeof operator
                    //
                    // An unsigned type will simply wrap round arithmetically (well defined).
                    //
                    if (!found_leading_bytes)
                    {
                        // If how_far_back == 3, we may have four consecutive continuation bytes!!!
                        // [....] [continuation] [continuation] [continuation] | [buf is
                        // continuation] Or we possibly have a stream that does not start with a
                        // leading byte.
                        return result(error_code::TOO_LONG, 0 - how_far_back);
                    }

                    result res = convert_with_errors(buf, len + extra_len, utf32_output);
                    if (res.error)
                    {
                        res.count -= extra_len;
                    }
                    return res;
                }

            } // namespace utf8_to_utf32
        } // unnamed namespace
    } // namespace scalar
} // namespace simdutf

#endif
/* end file src/scalar/utf8_to_utf32/utf8_to_utf32.h */

/* begin file src/implementation.cpp */
#include <climits>
#include <initializer_list>
#include <type_traits>

static_assert(sizeof(uint8_t) == sizeof(char),
    "simdutf requires that uint8_t be a char");
static_assert(sizeof(uint16_t) == sizeof(char16_t),
    "simdutf requires that char16_t be 16 bits");
static_assert(sizeof(uint32_t) == sizeof(char32_t),
    "simdutf requires that char32_t be 32 bits");
// next line is redundant, but it is kept to catch defective systems.
static_assert(CHAR_BIT == 8, "simdutf requires 8-bit bytes");

// Useful for debugging purposes
namespace simdutf
{
    namespace
    {

        template <typename T>
        std::string toBinaryString(T b)
        {
            std::string binary = "";
            T mask = T(1) << (sizeof(T) * CHAR_BIT - 1);
            while (mask > 0)
            {
                binary += ((b & mask) == 0) ? '0' : '1';
                mask >>= 1;
            }
            return binary;
        }
    } // namespace
} // namespace simdutf

namespace simdutf
{
    bool implementation::supported_by_runtime_system() const
    {
        uint32_t required_instruction_sets = this->required_instruction_sets();
        uint32_t supported_instruction_sets = internal::detect_supported_architectures();
        return ((supported_instruction_sets & required_instruction_sets) == required_instruction_sets);
    }

    namespace internal
    {
// When there is a single implementation, we should not pay a price
// for dispatching to the best implementation. We should just use the
// one we have. This is a compile-time check.
#define SIMDUTF_SINGLE_IMPLEMENTATION \
    (SIMDUTF_IMPLEMENTATION_ICELAKE + SIMDUTF_IMPLEMENTATION_HASWELL + SIMDUTF_IMPLEMENTATION_WESTMERE + SIMDUTF_IMPLEMENTATION_ARM64 + SIMDUTF_IMPLEMENTATION_PPC64 + SIMDUTF_IMPLEMENTATION_LSX + SIMDUTF_IMPLEMENTATION_LASX + SIMDUTF_IMPLEMENTATION_FALLBACK == 1)

        // Static array of known implementations. We are hoping these get baked into the
        // executable without requiring a static initializer.

#if SIMDUTF_IMPLEMENTATION_ICELAKE
        static const icelake::implementation* get_icelake_singleton()
        {
            static const icelake::implementation icelake_singleton {};
            return &icelake_singleton;
        }
#endif
#if SIMDUTF_IMPLEMENTATION_HASWELL
        static const haswell::implementation* get_haswell_singleton()
        {
            static const haswell::implementation haswell_singleton {};
            return &haswell_singleton;
        }
#endif
#if SIMDUTF_IMPLEMENTATION_WESTMERE
        static const westmere::implementation* get_westmere_singleton()
        {
            static const westmere::implementation westmere_singleton {};
            return &westmere_singleton;
        }
#endif
#if SIMDUTF_IMPLEMENTATION_ARM64
        static const arm64::implementation* get_arm64_singleton()
        {
            static const arm64::implementation arm64_singleton {};
            return &arm64_singleton;
        }
#endif
#if SIMDUTF_IMPLEMENTATION_PPC64
        static const ppc64::implementation* get_ppc64_singleton()
        {
            static const ppc64::implementation ppc64_singleton {};
            return &ppc64_singleton;
        }
#endif
#if SIMDUTF_IMPLEMENTATION_RVV
        static const rvv::implementation* get_rvv_singleton()
        {
            static const rvv::implementation rvv_singleton {};
            return &rvv_singleton;
        }
#endif
#if SIMDUTF_IMPLEMENTATION_LSX
        static const lsx::implementation* get_lsx_singleton()
        {
            static const lsx::implementation lsx_singleton {};
            return &lsx_singleton;
        }
#endif
#if SIMDUTF_IMPLEMENTATION_LASX
        static const lasx::implementation* get_lasx_singleton()
        {
            static const lasx::implementation lasx_singleton {};
            return &lasx_singleton;
        }
#endif
#if SIMDUTF_IMPLEMENTATION_FALLBACK
        static const fallback::implementation* get_fallback_singleton()
        {
            static const fallback::implementation fallback_singleton {};
            return &fallback_singleton;
        }
#endif

#if SIMDUTF_SINGLE_IMPLEMENTATION
        static const implementation* get_single_implementation()
        {
            return
    #if SIMDUTF_IMPLEMENTATION_ICELAKE
                get_icelake_singleton();
    #endif
    #if SIMDUTF_IMPLEMENTATION_HASWELL
            get_haswell_singleton();
    #endif
    #if SIMDUTF_IMPLEMENTATION_WESTMERE
            get_westmere_singleton();
    #endif
    #if SIMDUTF_IMPLEMENTATION_ARM64
            get_arm64_singleton();
    #endif
    #if SIMDUTF_IMPLEMENTATION_PPC64
            get_ppc64_singleton();
    #endif
    #if SIMDUTF_IMPLEMENTATION_LSX
            get_lsx_singleton();
    #endif
    #if SIMDUTF_IMPLEMENTATION_LASX
            get_lasx_singleton();
    #endif
    #if SIMDUTF_IMPLEMENTATION_FALLBACK
            get_fallback_singleton();
    #endif
        }
#endif

        /**
         * @private Detects best supported implementation on first use, and sets it
         */
        class detect_best_supported_implementation_on_first_use final
            : public implementation
        {
        public:
            std::string name() const noexcept final { return set_best()->name(); }
            std::string description() const noexcept final
            {
                return set_best()->description();
            }
            uint32_t required_instruction_sets() const noexcept final
            {
                return set_best()->required_instruction_sets();
            }

            simdutf_warn_unused bool
            validate_utf8(const char* buf, size_t len) const noexcept final override
            {
                return set_best()->validate_utf8(buf, len);
            }

            simdutf_warn_unused result validate_utf8_with_errors(
                const char* buf, size_t len) const noexcept final override
            {
                return set_best()->validate_utf8_with_errors(buf, len);
            }

            simdutf_warn_unused size_t
            count_utf8(const char* buf, size_t len) const noexcept final override
            {
                return set_best()->count_utf8(buf, len);
            }

            simdutf_really_inline
            detect_best_supported_implementation_on_first_use() noexcept
                : implementation("best_supported_detector",
                      "Detects the best supported implementation and sets it",
                      0)
            {
            }

        private:
            const implementation* set_best() const noexcept;
        };

        static_assert(std::is_trivially_destructible<
                          detect_best_supported_implementation_on_first_use>::value,
            "detect_best_supported_implementation_on_first_use should be "
            "trivially destructible");

        static const std::initializer_list<const implementation*>&
        get_available_implementation_pointers()
        {
            static const std::initializer_list<const implementation*>
                available_implementation_pointers {
#if SIMDUTF_IMPLEMENTATION_ICELAKE
                    get_icelake_singleton(),
#endif
#if SIMDUTF_IMPLEMENTATION_HASWELL
                    get_haswell_singleton(),
#endif
#if SIMDUTF_IMPLEMENTATION_WESTMERE
                    get_westmere_singleton(),
#endif
#if SIMDUTF_IMPLEMENTATION_ARM64
                    get_arm64_singleton(),
#endif
#if SIMDUTF_IMPLEMENTATION_PPC64
                    get_ppc64_singleton(),
#endif
#if SIMDUTF_IMPLEMENTATION_RVV
                    get_rvv_singleton(),
#endif
#if SIMDUTF_IMPLEMENTATION_LSX
                    get_lsx_singleton(),
#endif
#if SIMDUTF_IMPLEMENTATION_LASX
                    get_lasx_singleton(),
#endif
#if SIMDUTF_IMPLEMENTATION_FALLBACK
                    get_fallback_singleton(),
#endif
                }; // available_implementation_pointers
            return available_implementation_pointers;
        }

        // So we can return UNSUPPORTED_ARCHITECTURE from the parser when there is no
        // support
        class unsupported_implementation final : public implementation
        {
        public:
            simdutf_warn_unused bool validate_utf8(const char*,
                size_t) const noexcept final override
            {
                return false; // Just refuse to validate. Given that we have a fallback
                              // implementation
                // it seems unlikely that unsupported_implementation will ever be used. If
                // it is used, then it will flag all strings as invalid. The alternative is
                // to return an error_code from which the user has to figure out whether the
                // string is valid UTF-8... which seems like a lot of work just to handle
                // the very unlikely case that we have an unsupported implementation. And,
                // when it does happen (that we have an unsupported implementation), what
                // are the chances that the programmer has a fallback? Given that *we*
                // provide the fallback, it implies that the programmer would need a
                // fallback for our fallback.
            }

            simdutf_warn_unused result validate_utf8_with_errors(
                const char*, size_t) const noexcept final override
            {
                return result(error_code::OTHER, 0);
            }

            simdutf_warn_unused size_t count_utf8(const char*,
                size_t) const noexcept final override
            {
                return 0;
            }

            unsupported_implementation()
                : implementation("unsupported",
                      "Unsupported CPU (no detected SIMD instructions)", 0)
            {
            }
        };

        const unsupported_implementation* get_unsupported_singleton()
        {
            static const unsupported_implementation unsupported_singleton {};
            return &unsupported_singleton;
        }
        static_assert(std::is_trivially_destructible<unsupported_implementation>::value,
            "unsupported_singleton should be trivially destructible");

        size_t available_implementation_list::size() const noexcept
        {
            return internal::get_available_implementation_pointers().size();
        }
        const implementation* const*
        available_implementation_list::begin() const noexcept
        {
            return internal::get_available_implementation_pointers().begin();
        }
        const implementation* const*
        available_implementation_list::end() const noexcept
        {
            return internal::get_available_implementation_pointers().end();
        }
        const implementation*
        available_implementation_list::detect_best_supported() const noexcept
        {
            // They are prelisted in priority order, so we just go down the list
            uint32_t supported_instruction_sets = internal::detect_supported_architectures();
            for (const implementation* impl :
                internal::get_available_implementation_pointers())
            {
                uint32_t required_instruction_sets = impl->required_instruction_sets();
                if ((supported_instruction_sets & required_instruction_sets) == required_instruction_sets)
                {
                    return impl;
                }
            }
            return get_unsupported_singleton(); // this should never happen?
        }

        const implementation*
        detect_best_supported_implementation_on_first_use::set_best() const noexcept
        {
            SIMDUTF_PUSH_DISABLE_WARNINGS
            SIMDUTF_DISABLE_DEPRECATED_WARNING // Disable CRT_SECURE warning on MSVC:
                                               // manually verified this is safe
                char* force_implementation_name
                = getenv("SIMDUTF_FORCE_IMPLEMENTATION");
            SIMDUTF_POP_DISABLE_WARNINGS

            if (force_implementation_name)
            {
                auto force_implementation = get_available_implementations()[force_implementation_name];
                if (force_implementation)
                {
                    return get_active_implementation() = force_implementation;
                }
                else
                {
                    // Note: abort() and stderr usage within the library is forbidden.
                    return get_active_implementation() = get_unsupported_singleton();
                }
            }
            return get_active_implementation() = get_available_implementations().detect_best_supported();
        }

    } // namespace internal

    /**
     * The list of available implementations compiled into simdutf.
     */
    SIMDUTF_DLLIMPORTEXPORT const internal::available_implementation_list&
    get_available_implementations()
    {
        static const internal::available_implementation_list
            available_implementations {};
        return available_implementations;
    }

    /**
     * The active implementation.
     */
    SIMDUTF_DLLIMPORTEXPORT internal::atomic_ptr<const implementation>&
    get_active_implementation()
    {
#if SIMDUTF_SINGLE_IMPLEMENTATION
        // skip runtime detection
        static internal::atomic_ptr<const implementation> active_implementation {
            internal::get_single_implementation()
        };
        return active_implementation;
#else
        static const internal::detect_best_supported_implementation_on_first_use
            detect_best_supported_implementation_on_first_use_singleton;
        static internal::atomic_ptr<const implementation> active_implementation {
            &detect_best_supported_implementation_on_first_use_singleton
        };
        return active_implementation;
#endif
    }

#if SIMDUTF_SINGLE_IMPLEMENTATION
    const implementation* get_default_implementation()
    {
        return internal::get_single_implementation();
    }
#else
    internal::atomic_ptr<const implementation>& get_default_implementation()
    {
        return get_active_implementation();
    }
#endif
#define SIMDUTF_GET_CURRENT_IMPLEMENTION

    simdutf_warn_unused bool validate_utf8(const char* buf, size_t len) noexcept
    {
        return get_default_implementation()->validate_utf8(buf, len);
    }
    simdutf_warn_unused result validate_utf8_with_errors(const char* buf,
        size_t len) noexcept
    {
        return get_default_implementation()->validate_utf8_with_errors(buf, len);
    }

    const implementation* builtin_implementation()
    {
        static const implementation* builtin_impl = get_available_implementations()[SIMDUTF_STRINGIFY(
            SIMDUTF_BUILTIN_IMPLEMENTATION)];
        return builtin_impl;
    }

    simdutf_warn_unused size_t trim_partial_utf8(const char* input, size_t length)
    {
        return scalar::utf8::trim_partial_utf8(input, length);
    }

} // namespace simdutf
/* end file src/implementation.cpp */

SIMDUTF_PUSH_DISABLE_WARNINGS
SIMDUTF_DISABLE_UNDESIRED_WARNINGS

#if SIMDUTF_IMPLEMENTATION_ARM64
    /* begin file src/arm64/implementation.cpp */
    /* begin file src/simdutf/arm64/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "arm64"
    // #define SIMDUTF_IMPLEMENTATION arm64
    #define SIMDUTF_SIMD_HAS_BYTEMASK 1
/* end file src/simdutf/arm64/begin.h */
namespace simdutf
{
    namespace arm64
    {
        namespace
        {
    #ifndef SIMDUTF_ARM64_H
        #error "arm64.h must be included"
    #endif
            using namespace simd;

            simdutf_really_inline bool is_ascii(const simd8x64<uint8_t>& input)
            {
                simd8<uint8_t> bits = input.reduce_or();
                return bits.max_val() < 0b10000000u;
            }

            simdutf_really_inline simd8<bool>
            must_be_2_3_continuation(const simd8<uint8_t> prev2,
                const simd8<uint8_t> prev3)
            {
                simd8<bool> is_third_byte = prev2 >= uint8_t(0b11100000u);
                simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
                return is_third_byte ^ is_fourth_byte;
            }

        } // unnamed namespace
    } // namespace arm64
} // namespace simdutf

/* begin file src/generic/buf_block_reader.h */
namespace simdutf
{
    namespace arm64
    {
        namespace
        {

            // Walks through a buffer in block-sized increments, loading the last part with
            // spaces
            template <size_t STEP_SIZE>
            struct buf_block_reader
            {
            public:
                simdutf_really_inline buf_block_reader(const uint8_t* _buf, size_t _len);
                simdutf_really_inline size_t block_index();
                simdutf_really_inline bool has_full_block() const;
                simdutf_really_inline const uint8_t* full_block() const;
                /**
                 * Get the last block, padded with spaces.
                 *
                 * There will always be a last block, with at least 1 byte, unless len == 0
                 * (in which case this function fills the buffer with spaces and returns 0. In
                 * particular, if len == STEP_SIZE there will be 0 full_blocks and 1 remainder
                 * block with STEP_SIZE bytes and no spaces for padding.
                 *
                 * @return the number of effective characters in the last block.
                 */
                simdutf_really_inline size_t get_remainder(uint8_t* dst) const;
                simdutf_really_inline void advance();

            private:
                const uint8_t* buf;
                const size_t len;
                const size_t lenminusstep;
                size_t idx;
            };

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text_64(const uint8_t* text)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    buf[i] = int8_t(text[i]) < ' ' ? '_' : int8_t(text[i]);
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text(const simd8x64<uint8_t>& in)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                in.store(reinterpret_cast<uint8_t*>(buf));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    if (buf[i] < ' ')
                    {
                        buf[i] = '_';
                    }
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            simdutf_unused static char* format_mask(uint64_t mask)
            {
                static char* buf = reinterpret_cast<char*>(malloc(64 + 1));
                for (size_t i = 0; i < 64; i++)
                {
                    buf[i] = (mask & (size_t(1) << i)) ? 'X' : ' ';
                }
                buf[64] = '\0';
                return buf;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline
            buf_block_reader<STEP_SIZE>::buf_block_reader(const uint8_t* _buf, size_t _len)
                : buf { _buf }
                , len { _len }
                , lenminusstep { len < STEP_SIZE ? 0 : len - STEP_SIZE }
                , idx { 0 }
            {
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t buf_block_reader<STEP_SIZE>::block_index()
            {
                return idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline bool buf_block_reader<STEP_SIZE>::has_full_block() const
            {
                return idx < lenminusstep;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline const uint8_t*
            buf_block_reader<STEP_SIZE>::full_block() const
            {
                return &buf[idx];
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t
            buf_block_reader<STEP_SIZE>::get_remainder(uint8_t* dst) const
            {
                if (len == idx)
                {
                    return 0;
                } // memcpy(dst, null, 0) will trigger an error with some sanitizers
                std::memset(dst, 0x20,
                    STEP_SIZE); // std::memset STEP_SIZE because it is more efficient
                                // to write out 8 or 16 bytes at once.
                std::memcpy(dst, buf + idx, len - idx);
                return len - idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance()
            {
                idx += STEP_SIZE;
            }

        } // unnamed namespace
    } // namespace arm64
} // namespace simdutf
/* end file src/generic/buf_block_reader.h */
/* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
namespace simdutf
{
    namespace arm64
    {
        namespace
        {
            namespace utf8_validation
            {

                using namespace simd;

                simdutf_really_inline simd8<uint8_t>
                check_special_cases(const simd8<uint8_t> input, const simd8<uint8_t> prev1)
                {
                    // Bit 0 = Too Short (lead byte/ASCII followed by lead byte/ASCII)
                    // Bit 1 = Too Long (ASCII followed by continuation)
                    // Bit 2 = Overlong 3-byte
                    // Bit 4 = Surrogate
                    // Bit 5 = Overlong 2-byte
                    // Bit 7 = Two Continuations
                    constexpr const uint8_t TOO_SHORT = 1 << 0; // 11______ 0_______
                                                                // 11______ 11______
                    constexpr const uint8_t TOO_LONG = 1 << 1; // 0_______ 10______
                    constexpr const uint8_t OVERLONG_3 = 1 << 2; // 11100000 100_____
                    constexpr const uint8_t SURROGATE = 1 << 4; // 11101101 101_____
                    constexpr const uint8_t OVERLONG_2 = 1 << 5; // 1100000_ 10______
                    constexpr const uint8_t TWO_CONTS = 1 << 7; // 10______ 10______
                    constexpr const uint8_t TOO_LARGE = 1 << 3; // 11110100 1001____
                                                                // 11110100 101_____
                                                                // 11110101 1001____
                                                                // 11110101 101_____
                                                                // 1111011_ 1001____
                                                                // 1111011_ 101_____
                                                                // 11111___ 1001____
                                                                // 11111___ 101_____
                    constexpr const uint8_t TOO_LARGE_1000 = 1 << 6;
                    // 11110101 1000____
                    // 1111011_ 1000____
                    // 11111___ 1000____
                    constexpr const uint8_t OVERLONG_4 = 1 << 6; // 11110000 1000____

                    const simd8<uint8_t> byte_1_high = prev1.shr<4>().lookup_16<uint8_t>(
                        // 0_______ ________ <ASCII in byte 1>
                        TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG,
                        TOO_LONG,
                        // 10______ ________ <continuation in byte 1>
                        TWO_CONTS, TWO_CONTS, TWO_CONTS, TWO_CONTS,
                        // 1100____ ________ <two byte lead in byte 1>
                        TOO_SHORT | OVERLONG_2,
                        // 1101____ ________ <two byte lead in byte 1>
                        TOO_SHORT,
                        // 1110____ ________ <three byte lead in byte 1>
                        TOO_SHORT | OVERLONG_3 | SURROGATE,
                        // 1111____ ________ <four+ byte lead in byte 1>
                        TOO_SHORT | TOO_LARGE | TOO_LARGE_1000 | OVERLONG_4);
                    constexpr const uint8_t CARRY = TOO_SHORT | TOO_LONG | TWO_CONTS; // These all have ____ in byte 1 .
                    const simd8<uint8_t> byte_1_low = (prev1 & 0x0F)
                                                          .lookup_16<uint8_t>(
                                                              // ____0000 ________
                                                              CARRY | OVERLONG_3 | OVERLONG_2 | OVERLONG_4,
                                                              // ____0001 ________
                                                              CARRY | OVERLONG_2,
                                                              // ____001_ ________
                                                              CARRY, CARRY,

                                                              // ____0100 ________
                                                              CARRY | TOO_LARGE,
                                                              // ____0101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____011_ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,

                                                              // ____1___ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____1101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000 | SURROGATE,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000);
                    const simd8<uint8_t> byte_2_high = input.shr<4>().lookup_16<uint8_t>(
                        // ________ 0_______ <ASCII in byte 2>
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT,
                        TOO_SHORT, TOO_SHORT,

                        // ________ 1000____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE_1000 | OVERLONG_4,
                        // ________ 1001____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE,
                        // ________ 101_____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,

                        // ________ 11______
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT);
                    return (byte_1_high & byte_1_low & byte_2_high);
                }
                simdutf_really_inline simd8<uint8_t>
                check_multibyte_lengths(const simd8<uint8_t> input,
                    const simd8<uint8_t> prev_input,
                    const simd8<uint8_t> sc)
                {
                    simd8<uint8_t> prev2 = input.prev<2>(prev_input);
                    simd8<uint8_t> prev3 = input.prev<3>(prev_input);
                    simd8<uint8_t> must23 = simd8<uint8_t>(must_be_2_3_continuation(prev2, prev3));
                    simd8<uint8_t> must23_80 = must23 & uint8_t(0x80);
                    return must23_80 ^ sc;
                }

                //
                // Return nonzero if there are incomplete multibyte characters at the end of the
                // block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
                //
                simdutf_really_inline simd8<uint8_t> is_incomplete(const simd8<uint8_t> input)
                {
                    // If the previous input's last 3 bytes match this, they're too short (they
                    // ended at EOF):
                    // ... 1111____ 111_____ 11______
                    static const uint8_t max_array[32] = { 255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        0b11110000u - 1,
                        0b11100000u - 1,
                        0b11000000u - 1 };
                    const simd8<uint8_t> max_value(
                        &max_array[sizeof(max_array) - sizeof(simd8<uint8_t>)]);
                    return input.gt_bits(max_value);
                }

                struct utf8_checker
                {
                    // If this is nonzero, there has been a UTF-8 error.
                    simd8<uint8_t> error;
                    // The last input we received
                    simd8<uint8_t> prev_input_block;
                    // Whether the last input we received was incomplete (used for ASCII fast
                    // path)
                    simd8<uint8_t> prev_incomplete;

                    //
                    // Check whether the current bytes are valid UTF-8.
                    //
                    simdutf_really_inline void check_utf8_bytes(const simd8<uint8_t> input,
                        const simd8<uint8_t> prev_input)
                    {
                        // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
                        // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
                        // small negative numbers)
                        simd8<uint8_t> prev1 = input.prev<1>(prev_input);
                        simd8<uint8_t> sc = check_special_cases(input, prev1);
                        this->error |= check_multibyte_lengths(input, prev_input, sc);
                    }

                    // The only problem that can happen at EOF is that a multibyte character is
                    // too short or a byte value too large in the last bytes: check_special_cases
                    // only checks for bytes too large in the first of two bytes.
                    simdutf_really_inline void check_eof()
                    {
                        // If the previous block had incomplete UTF-8 characters at the end, an
                        // ASCII block can't possibly finish them.
                        this->error |= this->prev_incomplete;
                    }

                    simdutf_really_inline void check_next_input(const simd8x64<uint8_t>& input)
                    {
                        if (simdutf_likely(is_ascii(input)))
                        {
                            this->error |= this->prev_incomplete;
                        }
                        else
                        {
                            // you might think that a for-loop would work, but under Visual Studio, it
                            // is not good enough.
                            static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),
                                "We support either two or four chunks per 64-byte block.");
                            if (simd8x64<uint8_t>::NUM_CHUNKS == 2)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                            }
                            else if (simd8x64<uint8_t>::NUM_CHUNKS == 4)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                                this->check_utf8_bytes(input.chunks[2], input.chunks[1]);
                                this->check_utf8_bytes(input.chunks[3], input.chunks[2]);
                            }
                            this->prev_incomplete = is_incomplete(input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1]);
                            this->prev_input_block = input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1];
                        }
                    }

                    // do not forget to call check_eof!
                    simdutf_really_inline bool errors() const
                    {
                        return this->error.any_bits_set_anywhere();
                    }

                }; // struct utf8_checker
            } // namespace utf8_validation

            using utf8_validation::utf8_checker;

        } // unnamed namespace
    } // namespace arm64
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
/* begin file src/generic/utf8_validation/utf8_validator.h */
namespace simdutf
{
    namespace arm64
    {
        namespace
        {
            namespace utf8_validation
            {

                /**
                 * Validates that the string is actual UTF-8.
                 */
                template <class checker>
                bool generic_validate_utf8(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        reader.advance();
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    return !c.errors();
                }

                bool generic_validate_utf8(const char* input, size_t length)
                {
                    return generic_validate_utf8<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

                /**
                 * Validates that the string is actual UTF-8 and stops on errors.
                 */
                template <class checker>
                result generic_validate_utf8_with_errors(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    size_t count { 0 };
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        if (c.errors())
                        {
                            if (count != 0)
                            {
                                count--;
                            } // Sometimes the error is only detected in the next chunk
                            result res = scalar::utf8::rewind_and_validate_with_errors(
                                reinterpret_cast<const char*>(input),
                                reinterpret_cast<const char*>(input + count), length - count);
                            res.count += count;
                            return res;
                        }
                        reader.advance();
                        count += 64;
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    if (c.errors())
                    {
                        if (count != 0)
                        {
                            count--;
                        } // Sometimes the error is only detected in the next chunk
                        result res = scalar::utf8::rewind_and_validate_with_errors(
                            reinterpret_cast<const char*>(input),
                            reinterpret_cast<const char*>(input) + count, length - count);
                        res.count += count;
                        return res;
                    }
                    else
                    {
                        return result(error_code::SUCCESS, length);
                    }
                }

                result generic_validate_utf8_with_errors(const char* input, size_t length)
                {
                    return generic_validate_utf8_with_errors<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

            } // namespace utf8_validation
        } // unnamed namespace
    } // namespace arm64
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_validator.h */

// other functions
/* begin file src/generic/utf8.h */
namespace simdutf
{
    namespace arm64
    {
        namespace
        {
            namespace utf8
            {

                using namespace simd;

                simdutf_really_inline size_t count_code_points(const char* in, size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.gt(-65);
                        count += count_ones(utf8_continuation_mask);
                    }
                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }

    #ifdef SIMDUTF_SIMD_HAS_BYTEMASK
                simdutf_really_inline size_t count_code_points_bytemask(const char* in,
                    size_t size)
                {
                    using vector_i8 = simd8<int8_t>;
                    using vector_u8 = simd8<uint8_t>;
                    using vector_u64 = simd64<uint64_t>;

                    constexpr size_t N = vector_i8::SIZE;
                    constexpr size_t max_iterations = 255 / 4;

                    size_t pos = 0;
                    size_t count = 0;

                    auto counters = vector_u64::zero();
                    auto local = vector_u8::zero();
                    size_t iterations = 0;
                    for (; pos + 4 * N <= size; pos += 4 * N)
                    {
                        const auto input0 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 0 * N));
                        const auto input1 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 1 * N));
                        const auto input2 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 2 * N));
                        const auto input3 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 3 * N));
                        const auto mask0 = input0 > int8_t(-65);
                        const auto mask1 = input1 > int8_t(-65);
                        const auto mask2 = input2 > int8_t(-65);
                        const auto mask3 = input3 > int8_t(-65);

                        local -= vector_u8(mask0);
                        local -= vector_u8(mask1);
                        local -= vector_u8(mask2);
                        local -= vector_u8(mask3);

                        iterations += 1;
                        if (iterations == max_iterations)
                        {
                            counters += sum_8bytes(local);
                            local = vector_u8::zero();
                            iterations = 0;
                        }
                    }

                    if (iterations > 0)
                    {
                        count += local.sum_bytes();
                    }

                    count += counters.sum();

                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }
    #endif

                simdutf_really_inline size_t utf16_length_from_utf8(const char* in,
                    size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    // This algorithm could no doubt be improved!
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.lt(-65 + 1);
                        // We count one word for anything that is not a continuation (so
                        // leading bytes).
                        count += 64 - count_ones(utf8_continuation_mask);
                        int64_t utf8_4byte = input.gteq_unsigned(240);
                        count += count_ones(utf8_4byte);
                    }
                    return count + scalar::utf8::utf16_length_from_utf8(in + pos, size - pos);
                }
            } // namespace utf8
        } // unnamed namespace
    } // namespace arm64
} // namespace simdutf
/* end file src/generic/utf8.h */

//
// Implementation-specific overrides
//
namespace simdutf
{
    namespace arm64
    {

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* buf, size_t len) const noexcept
        {
            return arm64::utf8_validation::generic_validate_utf8(buf, len);
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* buf, size_t len) const noexcept
        {
            return arm64::utf8_validation::generic_validate_utf8_with_errors(buf, len);
        }

        simdutf_warn_unused size_t
        implementation::count_utf8(const char* input, size_t length) const noexcept
        {
            return utf8::count_code_points(input, length);
        }

    } // namespace arm64
} // namespace simdutf

/* begin file src/simdutf/arm64/end.h */
/* end file src/simdutf/arm64/end.h */
/* end file src/arm64/implementation.cpp */
#endif
#if SIMDUTF_IMPLEMENTATION_FALLBACK
/* begin file src/fallback/implementation.cpp */
/* begin file src/simdutf/fallback/begin.h */
// redefining SIMDUTF_IMPLEMENTATION to "fallback"
// #define SIMDUTF_IMPLEMENTATION fallback
/* end file src/simdutf/fallback/begin.h */

namespace simdutf
{
    namespace fallback
    {

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* buf, size_t len) const noexcept
        {
            return scalar::utf8::validate(buf, len);
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* buf, size_t len) const noexcept
        {
            return scalar::utf8::validate_with_errors(buf, len);
        }

        simdutf_warn_unused size_t
        implementation::count_utf8(const char* input, size_t length) const noexcept
        {
            return scalar::utf8::count_code_points(input, length);
        }

    } // namespace fallback
} // namespace simdutf

/* begin file src/simdutf/fallback/end.h */
/* end file src/simdutf/fallback/end.h */
/* end file src/fallback/implementation.cpp */
#endif
#if SIMDUTF_IMPLEMENTATION_ICELAKE
    /* begin file src/icelake/implementation.cpp */
    #include <tuple>
    #include <utility>

/* begin file src/simdutf/icelake/begin.h */
// redefining SIMDUTF_IMPLEMENTATION to "icelake"
// #define SIMDUTF_IMPLEMENTATION icelake

    #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
    // nothing needed.
    #else
SIMDUTF_TARGET_ICELAKE
    #endif

    #if SIMDUTF_GCC11ORMORE // workaround for
                            // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
// clang-format off
SIMDUTF_DISABLE_GCC_WARNING(-Wmaybe-uninitialized)
    // clang-format on
    #endif // end of workaround
/* end file src/simdutf/icelake/begin.h */
namespace simdutf
{
    namespace icelake
    {
        namespace
        {
    #ifndef SIMDUTF_ICELAKE_H
        #error "icelake.h must be included"
    #endif
            using namespace simd;

            /* begin file src/icelake/icelake_macros.inl.cpp */
            /*
                This upcoming macro (SIMDUTF_ICELAKE_TRANSCODE16) takes 16 + 4 bytes (of a
               UTF-8 string) and loads all possible 4-byte substring into an AVX512
               register.

                For example if we have bytes abcdefgh... we create following 32-bit lanes

                [abcd|bcde|cdef|defg|efgh|...]
                 ^                          ^
                 byte 0 of reg              byte 63 of reg
            */
            /** pshufb
                    # lane{0,1,2} have got bytes: [  0,  1,  2,  3,  4,  5,  6,  8,  9, 10,
               11, 12, 13, 14, 15] # lane3 has got bytes:        [ 16, 17, 18, 19,  4,  5,
               6,  8,  9, 10, 11, 12, 13, 14, 15]

                    expand_ver2 = [
                        # lane 0:
                        0, 1, 2, 3,
                        1, 2, 3, 4,
                        2, 3, 4, 5,
                        3, 4, 5, 6,

                        # lane 1:
                        4, 5, 6, 7,
                        5, 6, 7, 8,
                        6, 7, 8, 9,
                        7, 8, 9, 10,

                        # lane 2:
                         8,  9, 10, 11,
                         9, 10, 11, 12,
                        10, 11, 12, 13,
                        11, 12, 13, 14,

                        # lane 3 order: 13, 14, 15, 16 14, 15, 16, 17, 15, 16, 17, 18, 16,
               17, 18, 19 12, 13, 14, 15, 13, 14, 15,  0, 14, 15,  0,  1, 15,  0,  1,  2,
                    ]
            */

    #define SIMDUTF_ICELAKE_TRANSCODE16(LANE0, LANE1, MASKED)                                   \
        {                                                                                       \
            const __m512i merged = _mm512_mask_mov_epi32(LANE0, 0x1000, LANE1);                 \
            const __m512i expand_ver2 = _mm512_setr_epi64(                                      \
                0x0403020103020100, 0x0605040305040302, 0x0807060507060504,                     \
                0x0a09080709080706, 0x0c0b0a090b0a0908, 0x0e0d0c0b0d0c0b0a,                     \
                0x000f0e0d0f0e0d0c, 0x0201000f01000f0e);                                        \
            const __m512i input = _mm512_shuffle_epi8(merged, expand_ver2);                     \
                                                                                                \
            __mmask16 leading_bytes;                                                            \
            const __m512i v_0000_00c0 = _mm512_set1_epi32(0xc0);                                \
            const __m512i t0 = _mm512_and_si512(input, v_0000_00c0);                            \
            const __m512i v_0000_0080 = _mm512_set1_epi32(0x80);                                \
            leading_bytes = _mm512_cmpneq_epu32_mask(t0, v_0000_0080);                          \
                                                                                                \
            __m512i char_class;                                                                 \
            char_class = _mm512_srli_epi32(input, 4);                                           \
            /*  char_class = ((input >> 4) & 0x0f) | 0x80808000 */                              \
            const __m512i v_0000_000f = _mm512_set1_epi32(0x0f);                                \
            const __m512i v_8080_8000 = _mm512_set1_epi32(0x80808000);                          \
            char_class = _mm512_ternarylogic_epi32(char_class, v_0000_000f, v_8080_8000, 0xea); \
                                                                                                \
            const int valid_count = static_cast<int>(count_ones(leading_bytes));                \
            const __m512i utf32 = expanded_utf8_to_utf32(char_class, input);                    \
                                                                                                \
            const __m512i out = _mm512_mask_compress_epi32(_mm512_setzero_si512(),              \
                leading_bytes, utf32);                                                          \
                                                                                                \
            if (UTF32)                                                                          \
            {                                                                                   \
                if (MASKED)                                                                     \
                {                                                                               \
                    const __mmask16 valid = uint16_t((1 << valid_count) - 1);                   \
                    _mm512_mask_storeu_epi32((__m512i*)output, valid, out);                     \
                }                                                                               \
                else                                                                            \
                {                                                                               \
                    _mm512_storeu_si512((__m512i*)output, out);                                 \
                }                                                                               \
                output += valid_count;                                                          \
            }                                                                                   \
            else                                                                                \
            {                                                                                   \
                if (MASKED)                                                                     \
                {                                                                               \
                    output += utf32_to_utf16_masked<big_endian>(                                \
                        byteflip, out, valid_count, reinterpret_cast<char16_t*>(output));       \
                }                                                                               \
                else                                                                            \
                {                                                                               \
                    output += utf32_to_utf16<big_endian>(                                       \
                        byteflip, out, valid_count, reinterpret_cast<char16_t*>(output));       \
                }                                                                               \
            }                                                                                   \
        }

    #define SIMDUTF_ICELAKE_WRITE_UTF16_OR_UTF32(INPUT, VALID_COUNT, MASKED)           \
        {                                                                              \
            if (UTF32)                                                                 \
            {                                                                          \
                if (MASKED)                                                            \
                {                                                                      \
                    const __mmask16 valid_mask = uint16_t((1 << VALID_COUNT) - 1);     \
                    _mm512_mask_storeu_epi32((__m512i*)output, valid_mask, INPUT);     \
                }                                                                      \
                else                                                                   \
                {                                                                      \
                    _mm512_storeu_si512((__m512i*)output, INPUT);                      \
                }                                                                      \
                output += VALID_COUNT;                                                 \
            }                                                                          \
            else                                                                       \
            {                                                                          \
                if (MASKED)                                                            \
                {                                                                      \
                    output += utf32_to_utf16_masked<big_endian>(                       \
                        byteflip, INPUT, VALID_COUNT,                                  \
                        reinterpret_cast<char16_t*>(output));                          \
                }                                                                      \
                else                                                                   \
                {                                                                      \
                    output += utf32_to_utf16<big_endian>(byteflip, INPUT, VALID_COUNT, \
                        reinterpret_cast<char16_t*>(output));                          \
                }                                                                      \
            }                                                                          \
        }

    #define SIMDUTF_ICELAKE_STORE_ASCII(UTF32, utf8, output)                  \
        if (UTF32)                                                            \
        {                                                                     \
            const __m128i t0 = _mm512_castsi512_si128(utf8);                  \
            const __m128i t1 = _mm512_extracti32x4_epi32(utf8, 1);            \
            const __m128i t2 = _mm512_extracti32x4_epi32(utf8, 2);            \
            const __m128i t3 = _mm512_extracti32x4_epi32(utf8, 3);            \
            _mm512_storeu_si512((__m512i*)(output + 0 * 16),                  \
                _mm512_cvtepu8_epi32(t0));                                    \
            _mm512_storeu_si512((__m512i*)(output + 1 * 16),                  \
                _mm512_cvtepu8_epi32(t1));                                    \
            _mm512_storeu_si512((__m512i*)(output + 2 * 16),                  \
                _mm512_cvtepu8_epi32(t2));                                    \
            _mm512_storeu_si512((__m512i*)(output + 3 * 16),                  \
                _mm512_cvtepu8_epi32(t3));                                    \
        }                                                                     \
        else                                                                  \
        {                                                                     \
            const __m256i h0 = _mm512_castsi512_si256(utf8);                  \
            const __m256i h1 = _mm512_extracti64x4_epi64(utf8, 1);            \
            if (big_endian)                                                   \
            {                                                                 \
                _mm512_storeu_si512(                                          \
                    (__m512i*)(output + 0 * 16),                              \
                    _mm512_shuffle_epi8(_mm512_cvtepu8_epi16(h0), byteflip)); \
                _mm512_storeu_si512(                                          \
                    (__m512i*)(output + 2 * 16),                              \
                    _mm512_shuffle_epi8(_mm512_cvtepu8_epi16(h1), byteflip)); \
            }                                                                 \
            else                                                              \
            {                                                                 \
                _mm512_storeu_si512((__m512i*)(output + 0 * 16),              \
                    _mm512_cvtepu8_epi16(h0));                                \
                _mm512_storeu_si512((__m512i*)(output + 2 * 16),              \
                    _mm512_cvtepu8_epi16(h1));                                \
            }                                                                 \
        }
            /* end file src/icelake/icelake_macros.inl.cpp */
            /* begin file src/icelake/icelake_common.inl.cpp */
            // file included directly
            /**
             * Store the last N bytes of previous followed by 512-N bytes from input.
             */
            template <int N>
            __m512i prev(__m512i input, __m512i previous)
            {
                static_assert(N <= 32, "N must be no larger than 32");
                const __m512i movemask = _mm512_setr_epi32(28, 29, 30, 31, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);
                const __m512i rotated = _mm512_permutex2var_epi32(input, movemask, previous);
    #if SIMDUTF_GCC8 || SIMDUTF_GCC9
                constexpr int shift = 16 - N; // workaround for GCC8,9
                return _mm512_alignr_epi8(input, rotated, shift);
    #else
                return _mm512_alignr_epi8(input, rotated, 16 - N);
    #endif // SIMDUTF_GCC8 || SIMDUTF_GCC9
            }

            template <unsigned idx0, unsigned idx1, unsigned idx2, unsigned idx3>
            __m512i shuffle_epi128(__m512i v)
            {
                static_assert((idx0 >= 0 && idx0 <= 3), "idx0 must be in range 0..3");
                static_assert((idx1 >= 0 && idx1 <= 3), "idx1 must be in range 0..3");
                static_assert((idx2 >= 0 && idx2 <= 3), "idx2 must be in range 0..3");
                static_assert((idx3 >= 0 && idx3 <= 3), "idx3 must be in range 0..3");

                constexpr unsigned shuffle = idx0 | (idx1 << 2) | (idx2 << 4) | (idx3 << 6);
                return _mm512_shuffle_i32x4(v, v, shuffle);
            }

            template <unsigned idx>
            constexpr __m512i broadcast_epi128(__m512i v)
            {
                return shuffle_epi128<idx, idx, idx, idx>(v);
            }
            /* end file src/icelake/icelake_common.inl.cpp */
            /* begin file src/icelake/icelake_utf8_common.inl.cpp */
            // Common procedures for both validating and non-validating conversions from
            // UTF-8.
            enum block_processing_mode
            {
                SIMDUTF_FULL,
                SIMDUTF_TAIL
            };

            using utf8_to_utf16_result = std::pair<const char*, char16_t*>;
            using utf8_to_utf32_result = std::pair<const char*, uint32_t*>;

            /*
                process_block_utf8_to_utf16 converts up to 64 bytes from 'in' from UTF-8
                to UTF-16. When tail = SIMDUTF_FULL, then the full input buffer (64 bytes)
                might be used. When tail = SIMDUTF_TAIL, we take into account 'gap' which
                indicates how many input bytes are relevant.

                Returns true when the result is correct, otherwise it returns false.

                The provided in and out pointers are advanced according to how many input
                bytes have been processed, upon success.
            */
            template <block_processing_mode tail, endianness big_endian>
            simdutf_really_inline bool
            process_block_utf8_to_utf16(const char*& in, char16_t*& out, size_t gap)
            {
                // constants
                __m512i mask_identity = _mm512_set_epi8(
                    63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46,
                    45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28,
                    27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
                    8, 7, 6, 5, 4, 3, 2, 1, 0);
                __m512i mask_c0c0c0c0 = _mm512_set1_epi32(0xc0c0c0c0);
                __m512i mask_80808080 = _mm512_set1_epi32(0x80808080);
                __m512i mask_f0f0f0f0 = _mm512_set1_epi32(0xf0f0f0f0);
                __m512i mask_dfdfdfdf_tail = _mm512_set_epi64(
                    0xffffdfdfdfdfdfdf, 0xdfdfdfdfdfdfdfdf, 0xdfdfdfdfdfdfdfdf,
                    0xdfdfdfdfdfdfdfdf, 0xdfdfdfdfdfdfdfdf, 0xdfdfdfdfdfdfdfdf,
                    0xdfdfdfdfdfdfdfdf, 0xdfdfdfdfdfdfdfdf);
                __m512i mask_c2c2c2c2 = _mm512_set1_epi32(0xc2c2c2c2);
                __m512i mask_ffffffff = _mm512_set1_epi32(0xffffffff);
                __m512i mask_d7c0d7c0 = _mm512_set1_epi32(0xd7c0d7c0);
                __m512i mask_dc00dc00 = _mm512_set1_epi32(0xdc00dc00);
                __m512i byteflip = _mm512_setr_epi64(0x0607040502030001, 0x0e0f0c0d0a0b0809,
                    0x0607040502030001, 0x0e0f0c0d0a0b0809,
                    0x0607040502030001, 0x0e0f0c0d0a0b0809,
                    0x0607040502030001, 0x0e0f0c0d0a0b0809);
                // Note that 'tail' is a compile-time constant !
                __mmask64 b = (tail == SIMDUTF_FULL) ? 0xFFFFFFFFFFFFFFFF : (uint64_t(1) << gap) - 1;
                __m512i input = (tail == SIMDUTF_FULL) ? _mm512_loadu_si512(in)
                                                       : _mm512_maskz_loadu_epi8(b, in);
                __mmask64 m1 = (tail == SIMDUTF_FULL)
                    ? _mm512_cmplt_epu8_mask(input, mask_80808080)
                    : _mm512_mask_cmplt_epu8_mask(b, input, mask_80808080);
                if (_ktestc_mask64_u8(m1,
                        b))
                { // NOT(m1) AND b -- if all zeroes, then all ASCII
                  // alternatively, we could do 'if (m1 == b) { '
                    if (tail == SIMDUTF_FULL)
                    {
                        in += 64; // consumed 64 bytes
                        // we convert a full 64-byte block, writing 128 bytes.
                        __m512i input1 = _mm512_cvtepu8_epi16(_mm512_castsi512_si256(input));
                        if (big_endian)
                        {
                            input1 = _mm512_shuffle_epi8(input1, byteflip);
                        }
                        _mm512_storeu_si512(out, input1);
                        out += 32;
                        __m512i input2 = _mm512_cvtepu8_epi16(_mm512_extracti64x4_epi64(input, 1));
                        if (big_endian)
                        {
                            input2 = _mm512_shuffle_epi8(input2, byteflip);
                        }
                        _mm512_storeu_si512(out, input2);
                        out += 32;
                        return true; // we are done
                    }
                    else
                    {
                        in += gap;
                        if (gap <= 32)
                        {
                            __m512i input1 = _mm512_cvtepu8_epi16(_mm512_castsi512_si256(input));
                            if (big_endian)
                            {
                                input1 = _mm512_shuffle_epi8(input1, byteflip);
                            }
                            _mm512_mask_storeu_epi16(out, __mmask32((uint64_t(1) << (gap)) - 1),
                                input1);
                            out += gap;
                        }
                        else
                        {
                            __m512i input1 = _mm512_cvtepu8_epi16(_mm512_castsi512_si256(input));
                            if (big_endian)
                            {
                                input1 = _mm512_shuffle_epi8(input1, byteflip);
                            }
                            _mm512_storeu_si512(out, input1);
                            out += 32;
                            __m512i input2 = _mm512_cvtepu8_epi16(_mm512_extracti64x4_epi64(input, 1));
                            if (big_endian)
                            {
                                input2 = _mm512_shuffle_epi8(input2, byteflip);
                            }
                            _mm512_mask_storeu_epi16(
                                out, __mmask32((uint32_t(1) << (gap - 32)) - 1), input2);
                            out += gap - 32;
                        }
                        return true; // we are done
                    }
                }
                // classify characters further
                __mmask64 m234 = _mm512_cmp_epu8_mask(
                    mask_c0c0c0c0, input,
                    _MM_CMPINT_LE); // 0xc0 <= input, 2, 3, or 4 leading byte
                __mmask64 m34 = _mm512_cmp_epu8_mask(mask_dfdfdfdf_tail, input,
                    _MM_CMPINT_LT); // 0xdf < input,  3 or 4 leading byte

                __mmask64 milltwobytes = _mm512_mask_cmp_epu8_mask(
                    m234, input, mask_c2c2c2c2,
                    _MM_CMPINT_LT); // 0xc0 <= input < 0xc2 (illegal two byte sequence)
                                    // Overlong 2-byte sequence
                if (_ktestz_mask64_u8(milltwobytes, milltwobytes) == 0)
                {
                    // Overlong 2-byte sequence
                    return false;
                }
                if (_ktestz_mask64_u8(m34, m34) == 0)
                {
                    // We have a 3-byte sequence and/or a 2-byte sequence, or possibly even a
                    // 4-byte sequence!
                    __mmask64 m4 = _mm512_cmp_epu8_mask(
                        input, mask_f0f0f0f0,
                        _MM_CMPINT_NLT); // 0xf0 <= zmm0 (4 byte start bytes)

                    __mmask64 mask_not_ascii = (tail == SIMDUTF_FULL)
                        ? _knot_mask64(m1)
                        : _kand_mask64(_knot_mask64(m1), b);

                    __mmask64 mp1 = _kshiftli_mask64(m234, 1);
                    __mmask64 mp2 = _kshiftli_mask64(m34, 2);
                    // We could do it as follows...
                    // if (_kortestz_mask64_u8(m4,m4)) { // compute the bitwise OR of the 64-bit
                    // masks a and b and return 1 if all zeroes but GCC generates better code
                    // when we do:
                    if (m4 == 0)
                    { // compute the bitwise OR of the 64-bit masks a and b and
                      // return 1 if all zeroes
                        // Fast path with 1,2,3 bytes
                        __mmask64 mc = _kor_mask64(mp1, mp2); // expected continuation bytes
                        __mmask64 m1234 = _kor_mask64(m1, m234);
                        // mismatched continuation bytes:
                        if (tail == SIMDUTF_FULL)
                        {
                            __mmask64 xnormcm1234 = _kxnor_mask64(
                                mc,
                                m1234); // XNOR of mc and m1234 should be all zero if they differ
                            // the presence of a 1 bit indicates that they overlap.
                            // _kortestz_mask64_u8: compute the bitwise OR of 64-bit masksand return
                            // 1 if all zeroes.
                            if (!_kortestz_mask64_u8(xnormcm1234, xnormcm1234))
                            {
                                return false;
                            }
                        }
                        else
                        {
                            __mmask64 bxorm1234 = _kxor_mask64(b, m1234);
                            if (mc != bxorm1234)
                            {
                                return false;
                            }
                        }
                        // mend: identifying the last bytes of each sequence to be decoded
                        __mmask64 mend = _kshiftri_mask64(m1234, 1);
                        if (tail != SIMDUTF_FULL)
                        {
                            mend = _kor_mask64(mend, (uint64_t(1) << (gap - 1)));
                        }

                        __m512i last_and_third = _mm512_maskz_compress_epi8(mend, mask_identity);
                        __m512i last_and_thirdu16 = _mm512_cvtepu8_epi16(_mm512_castsi512_si256(last_and_third));

                        __m512i nonasciitags = _mm512_maskz_mov_epi8(
                            mask_not_ascii, mask_c0c0c0c0); // ASCII: 00000000  other: 11000000
                        __m512i clearedbytes = _mm512_andnot_si512(
                            nonasciitags, input); // high two bits cleared where not ASCII
                        __m512i lastbytes = _mm512_maskz_permutexvar_epi8(
                            0x5555555555555555, last_and_thirdu16,
                            clearedbytes); // the last byte of each character

                        __mmask64 mask_before_non_ascii = _kshiftri_mask64(
                            mask_not_ascii, 1); // bytes that precede non-ASCII bytes
                        __m512i indexofsecondlastbytes = _mm512_add_epi16(
                            mask_ffffffff, last_and_thirdu16); // indices of the second last bytes
                        __m512i beforeasciibytes = _mm512_maskz_mov_epi8(mask_before_non_ascii, clearedbytes);
                        __m512i secondlastbytes = _mm512_maskz_permutexvar_epi8(
                            0x5555555555555555, indexofsecondlastbytes,
                            beforeasciibytes); // the second last bytes (of two, three byte seq,
                                               // surrogates)
                        secondlastbytes = _mm512_slli_epi16(secondlastbytes, 6); // shifted into position

                        __m512i indexofthirdlastbytes = _mm512_add_epi16(
                            mask_ffffffff,
                            indexofsecondlastbytes); // indices of the second last bytes
                        __m512i thirdlastbyte = _mm512_maskz_mov_epi8(m34,
                            clearedbytes); // only those that are the third
                                           // last byte of a sequence
                        __m512i thirdlastbytes = _mm512_maskz_permutexvar_epi8(
                            0x5555555555555555, indexofthirdlastbytes,
                            thirdlastbyte); // the third last bytes (of three byte sequences, hi
                                            // surrogate)
                        thirdlastbytes = _mm512_slli_epi16(thirdlastbytes, 12); // shifted into position
                        __m512i Wout = _mm512_ternarylogic_epi32(lastbytes, secondlastbytes,
                            thirdlastbytes, 254);
                        // the elements of Wout excluding the last element if it happens to be a
                        // high surrogate:

                        __mmask64 mprocessed = (tail == SIMDUTF_FULL)
                            ? _pdep_u64(0xFFFFFFFF, mend)
                            : _pdep_u64(
                                  0xFFFFFFFF,
                                  _kand_mask64(
                                      mend, b)); // we adjust mend at the end of the output.

                        // Encodings out of range...
                        {
                            // the location of 3-byte sequence start bytes in the input
                            __mmask64 m3 = m34 & (b ^ m4);
                            // code units in Wout corresponding to 3-byte sequences.
                            __mmask32 M3 = __mmask32(_pext_u64(m3 << 2, mend));
                            __m512i mask_08000800 = _mm512_set1_epi32(0x08000800);
                            __mmask32 Msmall800 = _mm512_mask_cmplt_epu16_mask(M3, Wout, mask_08000800);
                            __m512i mask_d800d800 = _mm512_set1_epi32(0xd800d800);
                            __m512i Moutminusd800 = _mm512_sub_epi16(Wout, mask_d800d800);
                            __mmask32 M3s = _mm512_mask_cmplt_epu16_mask(M3, Moutminusd800, mask_08000800);
                            if (_kor_mask32(Msmall800, M3s))
                            {
                                return false;
                            }
                        }
                        int64_t nout = _mm_popcnt_u64(mprocessed);
                        in += 64 - _lzcnt_u64(mprocessed);
                        if (big_endian)
                        {
                            Wout = _mm512_shuffle_epi8(Wout, byteflip);
                        }
                        _mm512_mask_storeu_epi16(out, __mmask32((uint64_t(1) << nout) - 1), Wout);
                        out += nout;
                        return true; // ok
                    }
                    //
                    // We have a 4-byte sequence, this is the general case.
                    // Slow!
                    __mmask64 mp3 = _kshiftli_mask64(m4, 3);
                    __mmask64 mc = _kor_mask64(_kor_mask64(mp1, mp2), mp3); // expected continuation bytes
                    __mmask64 m1234 = _kor_mask64(m1, m234);

                    // mend: identifying the last bytes of each sequence to be decoded
                    __mmask64 mend = _kor_mask64(_kshiftri_mask64(_kor_mask64(mp3, m1234), 1), mp3);
                    if (tail != SIMDUTF_FULL)
                    {
                        mend = _kor_mask64(mend, __mmask64(uint64_t(1) << (gap - 1)));
                    }
                    __m512i last_and_third = _mm512_maskz_compress_epi8(mend, mask_identity);
                    __m512i last_and_thirdu16 = _mm512_cvtepu8_epi16(_mm512_castsi512_si256(last_and_third));

                    __m512i nonasciitags = _mm512_maskz_mov_epi8(
                        mask_not_ascii, mask_c0c0c0c0); // ASCII: 00000000  other: 11000000
                    __m512i clearedbytes = _mm512_andnot_si512(
                        nonasciitags, input); // high two bits cleared where not ASCII
                    __m512i lastbytes = _mm512_maskz_permutexvar_epi8(
                        0x5555555555555555, last_and_thirdu16,
                        clearedbytes); // the last byte of each character

                    __mmask64 mask_before_non_ascii = _kshiftri_mask64(
                        mask_not_ascii, 1); // bytes that precede non-ASCII bytes
                    __m512i indexofsecondlastbytes = _mm512_add_epi16(
                        mask_ffffffff, last_and_thirdu16); // indices of the second last bytes
                    __m512i beforeasciibytes = _mm512_maskz_mov_epi8(mask_before_non_ascii, clearedbytes);
                    __m512i secondlastbytes = _mm512_maskz_permutexvar_epi8(
                        0x5555555555555555, indexofsecondlastbytes,
                        beforeasciibytes); // the second last bytes (of two, three byte seq,
                                           // surrogates)
                    secondlastbytes = _mm512_slli_epi16(secondlastbytes, 6); // shifted into position

                    __m512i indexofthirdlastbytes = _mm512_add_epi16(
                        mask_ffffffff,
                        indexofsecondlastbytes); // indices of the second last bytes
                    __m512i thirdlastbyte = _mm512_maskz_mov_epi8(
                        m34,
                        clearedbytes); // only those that are the third last byte of a sequence
                    __m512i thirdlastbytes = _mm512_maskz_permutexvar_epi8(
                        0x5555555555555555, indexofthirdlastbytes,
                        thirdlastbyte); // the third last bytes (of three byte sequences, hi
                                        // surrogate)
                    thirdlastbytes = _mm512_slli_epi16(thirdlastbytes, 12); // shifted into position
                    __m512i thirdsecondandlastbytes = _mm512_ternarylogic_epi32(
                        lastbytes, secondlastbytes, thirdlastbytes, 254);
                    uint64_t Mlo_uint64 = _pext_u64(mp3, mend);
                    __mmask32 Mlo = __mmask32(Mlo_uint64);
                    __mmask32 Mhi = __mmask32(Mlo_uint64 >> 1);
                    __m512i lo_surr_mask = _mm512_maskz_mov_epi16(
                        Mlo,
                        mask_dc00dc00); // lo surr: 1101110000000000, other:  0000000000000000
                    __m512i shifted4_thirdsecondandlastbytes = _mm512_srli_epi16(thirdsecondandlastbytes,
                        4); // hi surr: 00000WVUTSRQPNML  vuts = WVUTS - 1
                    __m512i tagged_lo_surrogates = _mm512_or_si512(
                        thirdsecondandlastbytes,
                        lo_surr_mask); // lo surr: 110111KJHGFEDCBA, other:  unchanged
                    __m512i Wout = _mm512_mask_add_epi16(
                        tagged_lo_surrogates, Mhi, shifted4_thirdsecondandlastbytes,
                        mask_d7c0d7c0); // hi sur: 110110vutsRQPNML, other:  unchanged
                    // the elements of Wout excluding the last element if it happens to be a
                    // high surrogate:
                    __mmask32 Mout = ~(Mhi & 0x80000000);
                    __mmask64 mprocessed = (tail == SIMDUTF_FULL)
                        ? _pdep_u64(Mout, mend)
                        : _pdep_u64(
                              Mout,
                              _kand_mask64(mend,
                                  b)); // we adjust mend at the end of the output.

                    // mismatched continuation bytes:
                    if (tail == SIMDUTF_FULL)
                    {
                        __mmask64 xnormcm1234 = _kxnor_mask64(
                            mc, m1234); // XNOR of mc and m1234 should be all zero if they differ
                        // the presence of a 1 bit indicates that they overlap.
                        // _kortestz_mask64_u8: compute the bitwise OR of 64-bit masksand return 1
                        // if all zeroes.
                        if (!_kortestz_mask64_u8(xnormcm1234, xnormcm1234))
                        {
                            return false;
                        }
                    }
                    else
                    {
                        __mmask64 bxorm1234 = _kxor_mask64(b, m1234);
                        if (mc != bxorm1234)
                        {
                            return false;
                        }
                    }
                    // Encodings out of range...
                    {
                        // the location of 3-byte sequence start bytes in the input
                        __mmask64 m3 = m34 & (b ^ m4);
                        // code units in Wout corresponding to 3-byte sequences.
                        __mmask32 M3 = __mmask32(_pext_u64(m3 << 2, mend));
                        __m512i mask_08000800 = _mm512_set1_epi32(0x08000800);
                        __mmask32 Msmall800 = _mm512_mask_cmplt_epu16_mask(M3, Wout, mask_08000800);
                        __m512i mask_d800d800 = _mm512_set1_epi32(0xd800d800);
                        __m512i Moutminusd800 = _mm512_sub_epi16(Wout, mask_d800d800);
                        __mmask32 M3s = _mm512_mask_cmplt_epu16_mask(M3, Moutminusd800, mask_08000800);
                        __m512i mask_04000400 = _mm512_set1_epi32(0x04000400);
                        __mmask32 M4s = _mm512_mask_cmpge_epu16_mask(Mhi, Moutminusd800, mask_04000400);
                        if (!_kortestz_mask32_u8(M4s, _kor_mask32(Msmall800, M3s)))
                        {
                            return false;
                        }
                    }
                    in += 64 - _lzcnt_u64(mprocessed);
                    int64_t nout = _mm_popcnt_u64(mprocessed);
                    if (big_endian)
                    {
                        Wout = _mm512_shuffle_epi8(Wout, byteflip);
                    }
                    _mm512_mask_storeu_epi16(out, __mmask32((uint64_t(1) << nout) - 1), Wout);
                    out += nout;
                    return true; // ok
                }
                // Fast path 2: all ASCII or 2 byte
                __mmask64 continuation_or_ascii = (tail == SIMDUTF_FULL)
                    ? _knot_mask64(m234)
                    : _kand_mask64(_knot_mask64(m234), b);
                // on top of -0xc0 we subtract -2 which we get back later of the
                // continuation byte tags
                __m512i leading2byte = _mm512_maskz_sub_epi8(m234, input, mask_c2c2c2c2);
                __mmask64 leading = tail == (tail == SIMDUTF_FULL)
                    ? _kor_mask64(m1, m234)
                    : _kand_mask64(_kor_mask64(m1, m234),
                          b); // first bytes of each sequence
                if (tail == SIMDUTF_FULL)
                {
                    __mmask64 xnor234leading = _kxnor_mask64(_kshiftli_mask64(m234, 1), leading);
                    if (!_kortestz_mask64_u8(xnor234leading, xnor234leading))
                    {
                        return false;
                    }
                }
                else
                {
                    __mmask64 bxorleading = _kxor_mask64(b, leading);
                    if (_kshiftli_mask64(m234, 1) != bxorleading)
                    {
                        return false;
                    }
                }
                //
                if (tail == SIMDUTF_FULL)
                {
                    // In the two-byte/ASCII scenario, we are easily latency bound, so we want
                    // to increment the input buffer as quickly as possible.
                    // We process 32 bytes unless the byte at index 32 is a continuation byte,
                    // in which case we include it as well for a total of 33 bytes.
                    // Note that if x is an ASCII byte, then the following is false:
                    // int8_t(x) <= int8_t(0xc0) under two's complement.
                    in += 32;
                    if (int8_t(*in) <= int8_t(0xc0))
                        in++;
                    // The alternative is to do
                    // in += 64 - _lzcnt_u64(_pdep_u64(0xFFFFFFFF, continuation_or_ascii));
                    // but it requires loading the input, doing the mask computation, and
                    // converting back the mask to a general register. It just takes too long,
                    // leaving the processor likely to be idle.
                }
                else
                {
                    in += 64 - _lzcnt_u64(_pdep_u64(0xFFFFFFFF, continuation_or_ascii));
                }
                __m512i lead = _mm512_maskz_compress_epi8(
                    leading, leading2byte); // will contain zero for ascii, and the data
                lead = _mm512_cvtepu8_epi16(
                    _mm512_castsi512_si256(lead)); // ... zero extended into code units
                __m512i follow = _mm512_maskz_compress_epi8(
                    continuation_or_ascii, input); // the last bytes of each sequence
                follow = _mm512_cvtepu8_epi16(
                    _mm512_castsi512_si256(follow)); // ... zero extended into code units
                lead = _mm512_slli_epi16(lead, 6); // shifted into position
                __m512i final = _mm512_add_epi16(follow, lead); // combining lead and follow

                if (big_endian)
                {
                    final = _mm512_shuffle_epi8(final, byteflip);
                }
                if (tail == SIMDUTF_FULL)
                {
                    // Next part is UTF-16 specific and can be generalized to UTF-32.
                    int nout = _mm_popcnt_u32(uint32_t(leading));
                    _mm512_mask_storeu_epi16(out, __mmask32((uint64_t(1) << nout) - 1), final);
                    out += nout; // UTF-8 to UTF-16 is only expansionary in this case.
                }
                else
                {
                    int nout = int(_mm_popcnt_u64(_pdep_u64(0xFFFFFFFF, leading)));
                    _mm512_mask_storeu_epi16(out, __mmask32((uint64_t(1) << nout) - 1), final);
                    out += nout; // UTF-8 to UTF-16 is only expansionary in this case.
                }

                return true; // we are fine.
            }

            /*
                utf32_to_utf16_masked converts `count` lower UTF-32 code units
                from input `utf32` into UTF-16. It differs from utf32_to_utf16
                in that it 'masks' the writes.

                Returns how many 16-bit code units were stored.

                byteflip is used for flipping 16-bit code units, and it should be
                    __m512i byteflip = _mm512_setr_epi64(
                        0x0607040502030001,
                        0x0e0f0c0d0a0b0809,
                        0x0607040502030001,
                        0x0e0f0c0d0a0b0809,
                        0x0607040502030001,
                        0x0e0f0c0d0a0b0809,
                        0x0607040502030001,
                        0x0e0f0c0d0a0b0809
                    );
                We pass it to the (always inlined) function to encourage the compiler to
                keep the value in a (constant) register.
            */
            template <endianness big_endian>
            simdutf_really_inline size_t utf32_to_utf16_masked(const __m512i byteflip,
                __m512i utf32,
                unsigned int count,
                char16_t* output)
            {

                const __mmask16 valid = uint16_t((1 << count) - 1);
                // 1. check if we have any surrogate pairs
                const __m512i v_0000_ffff = _mm512_set1_epi32(0x0000ffff);
                const __mmask16 sp_mask = _mm512_mask_cmpgt_epu32_mask(valid, utf32, v_0000_ffff);

                if (sp_mask == 0)
                {
                    if (big_endian)
                    {
                        _mm256_mask_storeu_epi16(
                            (__m256i*)output, valid,
                            _mm256_shuffle_epi8(_mm512_cvtepi32_epi16(utf32),
                                _mm512_castsi512_si256(byteflip)));
                    }
                    else
                    {
                        _mm256_mask_storeu_epi16((__m256i*)output, valid,
                            _mm512_cvtepi32_epi16(utf32));
                    }
                    return count;
                }

                {
                    // build surrogate pair code units in 32-bit lanes

                    //    t0 = 8 x [000000000000aaaa|aaaaaabbbbbbbbbb]
                    const __m512i v_0001_0000 = _mm512_set1_epi32(0x00010000);
                    const __m512i t0 = _mm512_sub_epi32(utf32, v_0001_0000);

                    //    t1 = 8 x [000000aaaaaaaaaa|bbbbbbbbbb000000]
                    const __m512i t1 = _mm512_slli_epi32(t0, 6);

                    //    t2 = 8 x [000000aaaaaaaaaa|aaaaaabbbbbbbbbb] -- copy hi word from t1
                    //    to t0
                    //         0xe4 = (t1 and v_ffff_0000) or (t0 and not v_ffff_0000)
                    const __m512i v_ffff_0000 = _mm512_set1_epi32(0xffff0000);
                    const __m512i t2 = _mm512_ternarylogic_epi32(t1, t0, v_ffff_0000, 0xe4);

                    //    t2 = 8 x [110110aaaaaaaaaa|110111bbbbbbbbbb] -- copy hi word from t1
                    //    to t0
                    //         0xba = (t2 and not v_fc00_fc000) or v_d800_dc00
                    const __m512i v_fc00_fc00 = _mm512_set1_epi32(0xfc00fc00);
                    const __m512i v_d800_dc00 = _mm512_set1_epi32(0xd800dc00);
                    const __m512i t3 = _mm512_ternarylogic_epi32(t2, v_fc00_fc00, v_d800_dc00, 0xba);
                    const __m512i t4 = _mm512_mask_blend_epi32(sp_mask, utf32, t3);
                    __m512i t5 = _mm512_ror_epi32(t4, 16);
                    // Here we want to trim all of the upper 16-bit code units from the 2-byte
                    // characters represented as 4-byte values. We can compute it from
                    // sp_mask or the following... It can be more optimized!
                    const __mmask32 nonzero = _kor_mask32(
                        0xaaaaaaaa, _mm512_cmpneq_epi16_mask(t5, _mm512_setzero_si512()));
                    const __mmask32 nonzero_masked = _kand_mask32(nonzero, __mmask32((uint64_t(1) << (2 * count)) - 1));
                    if (big_endian)
                    {
                        t5 = _mm512_shuffle_epi8(t5, byteflip);
                    }
                    // we deliberately avoid _mm512_mask_compressstoreu_epi16 for portability
                    // (AMD Zen4 has terrible performance with it, it is effectively broken)
                    __m512i compressed = _mm512_maskz_compress_epi16(nonzero_masked, t5);
                    _mm512_mask_storeu_epi16(
                        output, _bzhi_u32(0xFFFFFFFF, count + _mm_popcnt_u32(sp_mask)),
                        compressed);
                    //_mm512_mask_compressstoreu_epi16(output, nonzero_masked, t5);
                }

                return count + static_cast<unsigned int>(count_ones(sp_mask));
            }

            /*
                utf32_to_utf16 converts `count` lower UTF-32 code units
                from input `utf32` into UTF-16. It may overflow.

                Returns how many 16-bit code units were stored.

                byteflip is used for flipping 16-bit code units, and it should be
                    __m512i byteflip = _mm512_setr_epi64(
                        0x0607040502030001,
                        0x0e0f0c0d0a0b0809,
                        0x0607040502030001,
                        0x0e0f0c0d0a0b0809,
                        0x0607040502030001,
                        0x0e0f0c0d0a0b0809,
                        0x0607040502030001,
                        0x0e0f0c0d0a0b0809
                    );
                We pass it to the (always inlined) function to encourage the compiler to
                keep the value in a (constant) register.
            */
            template <endianness big_endian>
            simdutf_really_inline size_t utf32_to_utf16(const __m512i byteflip,
                __m512i utf32, unsigned int count,
                char16_t* output)
            {
                // check if we have any surrogate pairs
                const __m512i v_0000_ffff = _mm512_set1_epi32(0x0000ffff);
                const __mmask16 sp_mask = _mm512_cmpgt_epu32_mask(utf32, v_0000_ffff);

                if (sp_mask == 0)
                {
                    // technically, it should be _mm256_storeu_epi16
                    if (big_endian)
                    {
                        _mm256_storeu_si256(
                            (__m256i*)output,
                            _mm256_shuffle_epi8(_mm512_cvtepi32_epi16(utf32),
                                _mm512_castsi512_si256(byteflip)));
                    }
                    else
                    {
                        _mm256_storeu_si256((__m256i*)output, _mm512_cvtepi32_epi16(utf32));
                    }
                    return count;
                }

                {
                    // build surrogate pair code units in 32-bit lanes

                    //    t0 = 8 x [000000000000aaaa|aaaaaabbbbbbbbbb]
                    const __m512i v_0001_0000 = _mm512_set1_epi32(0x00010000);
                    const __m512i t0 = _mm512_sub_epi32(utf32, v_0001_0000);

                    //    t1 = 8 x [000000aaaaaaaaaa|bbbbbbbbbb000000]
                    const __m512i t1 = _mm512_slli_epi32(t0, 6);

                    //    t2 = 8 x [000000aaaaaaaaaa|aaaaaabbbbbbbbbb] -- copy hi word from t1
                    //    to t0
                    //         0xe4 = (t1 and v_ffff_0000) or (t0 and not v_ffff_0000)
                    const __m512i v_ffff_0000 = _mm512_set1_epi32(0xffff0000);
                    const __m512i t2 = _mm512_ternarylogic_epi32(t1, t0, v_ffff_0000, 0xe4);

                    //    t2 = 8 x [110110aaaaaaaaaa|110111bbbbbbbbbb] -- copy hi word from t1
                    //    to t0
                    //         0xba = (t2 and not v_fc00_fc000) or v_d800_dc00
                    const __m512i v_fc00_fc00 = _mm512_set1_epi32(0xfc00fc00);
                    const __m512i v_d800_dc00 = _mm512_set1_epi32(0xd800dc00);
                    const __m512i t3 = _mm512_ternarylogic_epi32(t2, v_fc00_fc00, v_d800_dc00, 0xba);
                    const __m512i t4 = _mm512_mask_blend_epi32(sp_mask, utf32, t3);
                    __m512i t5 = _mm512_ror_epi32(t4, 16);
                    const __mmask32 nonzero = _kor_mask32(
                        0xaaaaaaaa, _mm512_cmpneq_epi16_mask(t5, _mm512_setzero_si512()));
                    if (big_endian)
                    {
                        t5 = _mm512_shuffle_epi8(t5, byteflip);
                    }
                    // we deliberately avoid _mm512_mask_compressstoreu_epi16 for portability
                    // (zen4)
                    __m512i compressed = _mm512_maskz_compress_epi16(nonzero, t5);
                    _mm512_mask_storeu_epi16(
                        output,
                        (1 << (count + static_cast<unsigned int>(count_ones(sp_mask)))) - 1,
                        compressed);
                    //_mm512_mask_compressstoreu_epi16(output, nonzero, t5);
                }

                return count + static_cast<unsigned int>(count_ones(sp_mask));
            }

            /*
                expanded_utf8_to_utf32 converts expanded UTF-8 characters (`utf8`)
                stored at separate 32-bit lanes.

                For each lane we have also a character class (`char_class), given in form
                0x8080800N, where N is 4 highest bits from the leading byte; 0x80 resets
                corresponding bytes during pshufb.
            */
            simdutf_really_inline __m512i expanded_utf8_to_utf32(__m512i char_class,
                __m512i utf8)
            {
                /*
                    Input:
                    - utf8: bytes stored at separate 32-bit code units
                    - valid: which code units have valid UTF-8 characters

                    Bit layout of single word. We show 4 cases for each possible
                    UTF-8 character encoding. The `?` denotes bits we must not
                    assume their value.

                    |10dd.dddd|10cc.cccc|10bb.bbbb|1111.0aaa| 4-byte char
                    |????.????|10cc.cccc|10bb.bbbb|1110.aaaa| 3-byte char
                    |????.????|????.????|10bb.bbbb|110a.aaaa| 2-byte char
                    |????.????|????.????|????.????|0aaa.aaaa| ASCII char
                      byte 3    byte 2    byte 1     byte 0
                */

                /* 1. Reset control bits of continuation bytes and the MSB
                      of the leading byte; this makes all bytes unsigned (and
                      does not alter ASCII char).

                    |00dd.dddd|00cc.cccc|00bb.bbbb|0111.0aaa| 4-byte char
                    |00??.????|00cc.cccc|00bb.bbbb|0110.aaaa| 3-byte char
                    |00??.????|00??.????|00bb.bbbb|010a.aaaa| 2-byte char
                    |00??.????|00??.????|00??.????|0aaa.aaaa| ASCII char
                     ^^        ^^        ^^        ^
                */
                __m512i values;
                const __m512i v_3f3f_3f7f = _mm512_set1_epi32(0x3f3f3f7f);
                values = _mm512_and_si512(utf8, v_3f3f_3f7f);

                /* 2. Swap and join fields A-B and C-D

                    |0000.cccc|ccdd.dddd|0001.110a|aabb.bbbb| 4-byte char
                    |0000.cccc|cc??.????|0001.10aa|aabb.bbbb| 3-byte char
                    |0000.????|????.????|0001.0aaa|aabb.bbbb| 2-byte char
                    |0000.????|????.????|000a.aaaa|aa??.????| ASCII char */
                const __m512i v_0140_0140 = _mm512_set1_epi32(0x01400140);
                values = _mm512_maddubs_epi16(values, v_0140_0140);

                /* 3. Swap and join fields AB & CD

                    |0000.0001|110a.aabb|bbbb.cccc|ccdd.dddd| 4-byte char
                    |0000.0001|10aa.aabb|bbbb.cccc|cc??.????| 3-byte char
                    |0000.0001|0aaa.aabb|bbbb.????|????.????| 2-byte char
                    |0000.000a|aaaa.aa??|????.????|????.????| ASCII char */
                const __m512i v_0001_1000 = _mm512_set1_epi32(0x00011000);
                values = _mm512_madd_epi16(values, v_0001_1000);

                /* 4. Shift left the values by variable amounts to reset highest UTF-8 bits
                    |aaab.bbbb|bccc.cccd|dddd.d000|0000.0000| 4-byte char -- by 11
                    |aaaa.bbbb|bbcc.cccc|????.??00|0000.0000| 3-byte char -- by 10
                    |aaaa.abbb|bbb?.????|????.???0|0000.0000| 2-byte char -- by 9
                    |aaaa.aaa?|????.????|????.????|?000.0000| ASCII char -- by 7 */
                {
                    /** pshufb

                    continuation = 0
                    ascii    = 7
                    _2_bytes = 9
                    _3_bytes = 10
                    _4_bytes = 11

                    shift_left_v3 = 4 * [
                        ascii, # 0000
                        ascii, # 0001
                        ascii, # 0010
                        ascii, # 0011
                        ascii, # 0100
                        ascii, # 0101
                        ascii, # 0110
                        ascii, # 0111
                        continuation, # 1000
                        continuation, # 1001
                        continuation, # 1010
                        continuation, # 1011
                        _2_bytes, # 1100
                        _2_bytes, # 1101
                        _3_bytes, # 1110
                        _4_bytes, # 1111
                    ] */
                    const __m512i shift_left_v3 = _mm512_setr_epi64(
                        0x0707070707070707, 0x0b0a090900000000, 0x0707070707070707,
                        0x0b0a090900000000, 0x0707070707070707, 0x0b0a090900000000,
                        0x0707070707070707, 0x0b0a090900000000);

                    const __m512i shift = _mm512_shuffle_epi8(shift_left_v3, char_class);
                    values = _mm512_sllv_epi32(values, shift);
                }

                /* 5. Shift right the values by variable amounts to reset lowest bits
                    |0000.0000|000a.aabb|bbbb.cccc|ccdd.dddd| 4-byte char -- by 11
                    |0000.0000|0000.0000|aaaa.bbbb|bbcc.cccc| 3-byte char -- by 16
                    |0000.0000|0000.0000|0000.0aaa|aabb.bbbb| 2-byte char -- by 21
                    |0000.0000|0000.0000|0000.0000|0aaa.aaaa| ASCII char -- by 25 */
                {
                    // 4 * [25, 25, 25, 25, 25, 25, 25, 25, 0, 0, 0, 0, 21, 21, 16, 11]
                    const __m512i shift_right = _mm512_setr_epi64(
                        0x1919191919191919, 0x0b10151500000000, 0x1919191919191919,
                        0x0b10151500000000, 0x1919191919191919, 0x0b10151500000000,
                        0x1919191919191919, 0x0b10151500000000);

                    const __m512i shift = _mm512_shuffle_epi8(shift_right, char_class);
                    values = _mm512_srlv_epi32(values, shift);
                }

                return values;
            }

            simdutf_really_inline __m512i expand_and_identify(__m512i lane0, __m512i lane1,
                int& count)
            {
                const __m512i merged = _mm512_mask_mov_epi32(lane0, 0x1000, lane1);
                const __m512i expand_ver2 = _mm512_setr_epi64(
                    0x0403020103020100, 0x0605040305040302, 0x0807060507060504,
                    0x0a09080709080706, 0x0c0b0a090b0a0908, 0x0e0d0c0b0d0c0b0a,
                    0x000f0e0d0f0e0d0c, 0x0201000f01000f0e);
                const __m512i input = _mm512_shuffle_epi8(merged, expand_ver2);
                const __m512i v_0000_00c0 = _mm512_set1_epi32(0xc0);
                const __m512i t0 = _mm512_and_si512(input, v_0000_00c0);
                const __m512i v_0000_0080 = _mm512_set1_epi32(0x80);
                const __mmask16 leading_bytes = _mm512_cmpneq_epu32_mask(t0, v_0000_0080);
                count = static_cast<int>(count_ones(leading_bytes));
                return _mm512_mask_compress_epi32(_mm512_setzero_si512(), leading_bytes,
                    input);
            }

            simdutf_really_inline __m512i expand_utf8_to_utf32(__m512i input)
            {
                __m512i char_class = _mm512_srli_epi32(input, 4);
                /*  char_class = ((input >> 4) & 0x0f) | 0x80808000 */
                const __m512i v_0000_000f = _mm512_set1_epi32(0x0f);
                const __m512i v_8080_8000 = _mm512_set1_epi32(0x80808000);
                char_class = _mm512_ternarylogic_epi32(char_class, v_0000_000f, v_8080_8000, 0xea);
                return expanded_utf8_to_utf32(char_class, input);
            }
            /* end file src/icelake/icelake_utf8_common.inl.cpp */

            /* begin file src/icelake/icelake_utf8_validation.inl.cpp */
            // file included directly

            simdutf_really_inline __m512i check_special_cases(__m512i input,
                const __m512i prev1)
            {
                __m512i mask1 = _mm512_setr_epi64(0x0202020202020202, 0x4915012180808080,
                    0x0202020202020202, 0x4915012180808080,
                    0x0202020202020202, 0x4915012180808080,
                    0x0202020202020202, 0x4915012180808080);
                const __m512i v_0f = _mm512_set1_epi8(0x0f);
                __m512i index1 = _mm512_and_si512(_mm512_srli_epi16(prev1, 4), v_0f);

                __m512i byte_1_high = _mm512_shuffle_epi8(mask1, index1);
                __m512i mask2 = _mm512_setr_epi64(0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb,
                    0xcbcbcb8b8383a3e7, 0xcbcbdbcbcbcbcbcb);
                __m512i index2 = _mm512_and_si512(prev1, v_0f);

                __m512i byte_1_low = _mm512_shuffle_epi8(mask2, index2);
                __m512i mask3 = _mm512_setr_epi64(0x101010101010101, 0x1010101babaaee6, 0x101010101010101,
                    0x1010101babaaee6, 0x101010101010101, 0x1010101babaaee6,
                    0x101010101010101, 0x1010101babaaee6);
                __m512i index3 = _mm512_and_si512(_mm512_srli_epi16(input, 4), v_0f);
                __m512i byte_2_high = _mm512_shuffle_epi8(mask3, index3);
                return _mm512_ternarylogic_epi64(byte_1_high, byte_1_low, byte_2_high, 128);
            }

            simdutf_really_inline __m512i check_multibyte_lengths(const __m512i input,
                const __m512i prev_input,
                const __m512i sc)
            {
                __m512i prev2 = prev<2>(input, prev_input);
                __m512i prev3 = prev<3>(input, prev_input);
                __m512i is_third_byte = _mm512_subs_epu8(
                    prev2, _mm512_set1_epi8(0b11100000u - 1)); // Only 111_____ will be > 0
                __m512i is_fourth_byte = _mm512_subs_epu8(
                    prev3, _mm512_set1_epi8(0b11110000u - 1)); // Only 1111____ will be > 0
                __m512i is_third_or_fourth_byte = _mm512_or_si512(is_third_byte, is_fourth_byte);
                const __m512i v_7f = _mm512_set1_epi8(char(0x7f));
                is_third_or_fourth_byte = _mm512_adds_epu8(v_7f, is_third_or_fourth_byte);
                // We want to compute (is_third_or_fourth_byte AND v80) XOR sc.
                const __m512i v_80 = _mm512_set1_epi8(char(0x80));
                return _mm512_ternarylogic_epi32(is_third_or_fourth_byte, v_80, sc,
                    0b1101010);
                //__m512i is_third_or_fourth_byte_mask =
                //_mm512_and_si512(is_third_or_fourth_byte, v_80); return
                // _mm512_xor_si512(is_third_or_fourth_byte_mask, sc);
            }
            //
            // Return nonzero if there are incomplete multibyte characters at the end of the
            // block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
            //
            simdutf_really_inline __m512i is_incomplete(const __m512i input)
            {
                // If the previous input's last 3 bytes match this, they're too short (they
                // ended at EOF):
                // ... 1111____ 111_____ 11______
                __m512i max_value = _mm512_setr_epi64(0xffffffffffffffff, 0xffffffffffffffff,
                    0xffffffffffffffff, 0xffffffffffffffff,
                    0xffffffffffffffff, 0xffffffffffffffff,
                    0xffffffffffffffff, 0xbfdfefffffffffff);
                return _mm512_subs_epu8(input, max_value);
            }

            struct avx512_utf8_checker
            {
                // If this is nonzero, there has been a UTF-8 error.
                __m512i error {};

                // The last input we received
                __m512i prev_input_block {};
                // Whether the last input we received was incomplete (used for ASCII fast
                // path)
                __m512i prev_incomplete {};

                //
                // Check whether the current bytes are valid UTF-8.
                //
                simdutf_really_inline void check_utf8_bytes(const __m512i input,
                    const __m512i prev_input)
                {
                    // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
                    // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
                    // small negative numbers)
                    __m512i prev1 = prev<1>(input, prev_input);
                    __m512i sc = check_special_cases(input, prev1);
                    this->error = _mm512_or_si512(
                        check_multibyte_lengths(input, prev_input, sc), this->error);
                }

                // The only problem that can happen at EOF is that a multibyte character is
                // too short or a byte value too large in the last bytes: check_special_cases
                // only checks for bytes too large in the first of two bytes.
                simdutf_really_inline void check_eof()
                {
                    // If the previous block had incomplete UTF-8 characters at the end, an
                    // ASCII block can't possibly finish them.
                    this->error = _mm512_or_si512(this->error, this->prev_incomplete);
                }

                // returns true if ASCII.
                simdutf_really_inline bool check_next_input(const __m512i input)
                {
                    const __m512i v_80 = _mm512_set1_epi8(char(0x80));
                    const __mmask64 ascii = _mm512_test_epi8_mask(input, v_80);
                    if (ascii == 0)
                    {
                        this->error = _mm512_or_si512(this->error, this->prev_incomplete);
                        return true;
                    }
                    else
                    {
                        this->check_utf8_bytes(input, this->prev_input_block);
                        this->prev_incomplete = is_incomplete(input);
                        this->prev_input_block = input;
                        return false;
                    }
                }
                // do not forget to call check_eof!
                simdutf_really_inline bool errors() const
                {
                    return _mm512_test_epi8_mask(this->error, this->error) != 0;
                }
            }; // struct avx512_utf8_checker
            /* end file src/icelake/icelake_utf8_validation.inl.cpp */

            /* begin file src/icelake/icelake_convert_latin1_to_utf8.inl.cpp */
            // file included directly

            static inline size_t latin1_to_utf8_avx512_vec(__m512i input, size_t input_len,
                char* utf8_output,
                int mask_output)
            {
                __mmask64 nonascii = _mm512_movepi8_mask(input);
                size_t output_size = input_len + (size_t)count_ones(nonascii);

                // Mask to denote whether the byte is a leading byte that is not ascii
                __mmask64 sixth = _mm512_cmpge_epu8_mask(
                    input, _mm512_set1_epi8(-64)); // binary representation of -64: 1100 0000

                const uint64_t alternate_bits = UINT64_C(0x5555555555555555);
                uint64_t ascii = ~nonascii;
                // the bits in ascii are inverted and zeros are interspersed in between them
                uint64_t maskA = ~_pdep_u64(ascii, alternate_bits);
                uint64_t maskB = ~_pdep_u64(ascii >> 32, alternate_bits);

                // interleave bytes from top and bottom halves (abcd...ABCD -> aAbBcCdD)
                __m512i input_interleaved = _mm512_permutexvar_epi8(
                    _mm512_set_epi32(0x3f1f3e1e, 0x3d1d3c1c, 0x3b1b3a1a, 0x39193818,
                        0x37173616, 0x35153414, 0x33133212, 0x31113010,
                        0x2f0f2e0e, 0x2d0d2c0c, 0x2b0b2a0a, 0x29092808,
                        0x27072606, 0x25052404, 0x23032202, 0x21012000),
                    input);

                // double size of each byte, and insert the leading byte 1100 0010

                /*
                upscale the bytes to 16-bit value, adding the 0b11000000 leading byte in the
                process. We adjust for the bytes that have their two most significant bits.
                This takes care of the first 32 bytes, assuming we interleaved the bytes. */
                __m512i outputA = _mm512_shldi_epi16(input_interleaved, _mm512_set1_epi8(-62), 8);
                outputA = _mm512_mask_add_epi16(
                    outputA, (__mmask32)sixth, outputA,
                    _mm512_set1_epi16(1 - 0x4000)); // 1- 0x4000 = 1100 0000 0000 0001????

                // in the second 32-bit half, set first or second option based on whether
                // original input is leading byte (second case) or not (first case)
                __m512i leadingB = _mm512_mask_blend_epi16((__mmask32)(sixth >> 32),
                    _mm512_set1_epi16(0x00c2), // 0000 0000 1101 0010
                    _mm512_set1_epi16(0x40c3)); // 0100 0000 1100 0011
                __m512i outputB = _mm512_ternarylogic_epi32(
                    input_interleaved, leadingB, _mm512_set1_epi16((short)0xff00),
                    (240 & 170) ^ 204); // (input_interleaved & 0xff00) ^ leadingB

                // prune redundant bytes
                outputA = _mm512_maskz_compress_epi8(maskA, outputA);
                outputB = _mm512_maskz_compress_epi8(maskB, outputB);

                size_t output_sizeA = (size_t)count_ones((uint32_t)nonascii) + 32;

                if (mask_output)
                {
                    if (input_len > 32)
                    { // is the second half of the input vector used?
                        __mmask64 write_mask = _bzhi_u64(~0ULL, (unsigned int)output_sizeA);
                        _mm512_mask_storeu_epi8(utf8_output, write_mask, outputA);
                        utf8_output += output_sizeA;
                        write_mask = _bzhi_u64(~0ULL, (unsigned int)(output_size - output_sizeA));
                        _mm512_mask_storeu_epi8(utf8_output, write_mask, outputB);
                    }
                    else
                    {
                        __mmask64 write_mask = _bzhi_u64(~0ULL, (unsigned int)output_size);
                        _mm512_mask_storeu_epi8(utf8_output, write_mask, outputA);
                    }
                }
                else
                {
                    _mm512_storeu_si512(utf8_output, outputA);
                    utf8_output += output_sizeA;
                    _mm512_storeu_si512(utf8_output, outputB);
                }
                return output_size;
            }

            static inline size_t latin1_to_utf8_avx512_branch(__m512i input,
                char* utf8_output)
            {
                __mmask64 nonascii = _mm512_movepi8_mask(input);
                if (nonascii)
                {
                    return latin1_to_utf8_avx512_vec(input, 64, utf8_output, 0);
                }
                else
                {
                    _mm512_storeu_si512(utf8_output, input);
                    return 64;
                }
            }

            size_t latin1_to_utf8_avx512_start(const char* buf, size_t len,
                char* utf8_output)
            {
                char* start = utf8_output;
                size_t pos = 0;
                // if there's at least 128 bytes remaining, we don't need to mask the output
                for (; pos + 128 <= len; pos += 64)
                {
                    __m512i input = _mm512_loadu_si512((__m512i*)(buf + pos));
                    utf8_output += latin1_to_utf8_avx512_branch(input, utf8_output);
                }
                // in the last 128 bytes, the first 64 may require masking the output
                if (pos + 64 <= len)
                {
                    __m512i input = _mm512_loadu_si512((__m512i*)(buf + pos));
                    utf8_output += latin1_to_utf8_avx512_vec(input, 64, utf8_output, 1);
                    pos += 64;
                }
                // with the last 64 bytes, the input also needs to be masked
                if (pos < len)
                {
                    __mmask64 load_mask = _bzhi_u64(~0ULL, (unsigned int)(len - pos));
                    __m512i input = _mm512_maskz_loadu_epi8(load_mask, (__m512i*)(buf + pos));
                    utf8_output += latin1_to_utf8_avx512_vec(input, len - pos, utf8_output, 1);
                }
                return (size_t)(utf8_output - start);
            }
            /* end file src/icelake/icelake_convert_latin1_to_utf8.inl.cpp */

    #include <cstdint>

        } // namespace
    } // namespace icelake
} // namespace simdutf

namespace simdutf
{
    namespace icelake
    {

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* buf, size_t len) const noexcept
        {
            if (simdutf_unlikely(len == 0))
            {
                return true;
            }
            avx512_utf8_checker checker {};
            const char* ptr = buf;
            const char* end = ptr + len;
            for (; end - ptr >= 64; ptr += 64)
            {
                const __m512i utf8 = _mm512_loadu_si512((const __m512i*)ptr);
                checker.check_next_input(utf8);
            }
            if (end != ptr)
            {
                const __m512i utf8 = _mm512_maskz_loadu_epi8(
                    ~UINT64_C(0) >> (64 - (end - ptr)), (const __m512i*)ptr);
                checker.check_next_input(utf8);
            }
            checker.check_eof();
            return !checker.errors();
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* buf, size_t len) const noexcept
        {
            if (simdutf_unlikely(len == 0))
            {
                return result(error_code::SUCCESS, len);
            }
            avx512_utf8_checker checker {};
            const char* ptr = buf;
            const char* end = ptr + len;
            size_t count { 0 };
            for (; end - ptr >= 64; ptr += 64)
            {
                const __m512i utf8 = _mm512_loadu_si512((const __m512i*)ptr);
                checker.check_next_input(utf8);
                if (checker.errors())
                {
                    if (count != 0)
                    {
                        count--;
                    } // Sometimes the error is only detected in the next chunk
                    result res = scalar::utf8::rewind_and_validate_with_errors(
                        reinterpret_cast<const char*>(buf),
                        reinterpret_cast<const char*>(buf + count), len - count);
                    res.count += count;
                    return res;
                }
                count += 64;
            }
            if (end != ptr)
            {
                const __m512i utf8 = _mm512_maskz_loadu_epi8(
                    ~UINT64_C(0) >> (64 - (end - ptr)), (const __m512i*)ptr);
                checker.check_next_input(utf8);
            }
            checker.check_eof();
            if (checker.errors())
            {
                if (count != 0)
                {
                    count--;
                } // Sometimes the error is only detected in the next chunk
                result res = scalar::utf8::rewind_and_validate_with_errors(
                    reinterpret_cast<const char*>(buf),
                    reinterpret_cast<const char*>(buf + count), len - count);
                res.count += count;
                return res;
            }
            return result(error_code::SUCCESS, len);
        }

        simdutf_warn_unused size_t
        implementation::count_utf8(const char* input, size_t length) const noexcept
        {
            const uint8_t* str = reinterpret_cast<const uint8_t*>(input);
            size_t answer = length / sizeof(__m512i) * sizeof(__m512i); // Number of 512-bit chunks that fits into the length.
            size_t i = 0;
            __m512i unrolled_popcount { 0 };

            const __m512i continuation = _mm512_set1_epi8(char(0b10111111));

            while (i + sizeof(__m512i) <= length)
            {
                size_t iterations = (length - i) / sizeof(__m512i);

                size_t max_i = i + iterations * sizeof(__m512i) - sizeof(__m512i);
                for (; i + 8 * sizeof(__m512i) <= max_i; i += 8 * sizeof(__m512i))
                {
                    __m512i input1 = _mm512_loadu_si512((const __m512i*)(str + i));
                    __m512i input2 = _mm512_loadu_si512((const __m512i*)(str + i + sizeof(__m512i)));
                    __m512i input3 = _mm512_loadu_si512((const __m512i*)(str + i + 2 * sizeof(__m512i)));
                    __m512i input4 = _mm512_loadu_si512((const __m512i*)(str + i + 3 * sizeof(__m512i)));
                    __m512i input5 = _mm512_loadu_si512((const __m512i*)(str + i + 4 * sizeof(__m512i)));
                    __m512i input6 = _mm512_loadu_si512((const __m512i*)(str + i + 5 * sizeof(__m512i)));
                    __m512i input7 = _mm512_loadu_si512((const __m512i*)(str + i + 6 * sizeof(__m512i)));
                    __m512i input8 = _mm512_loadu_si512((const __m512i*)(str + i + 7 * sizeof(__m512i)));

                    __mmask64 mask1 = _mm512_cmple_epi8_mask(input1, continuation);
                    __mmask64 mask2 = _mm512_cmple_epi8_mask(input2, continuation);
                    __mmask64 mask3 = _mm512_cmple_epi8_mask(input3, continuation);
                    __mmask64 mask4 = _mm512_cmple_epi8_mask(input4, continuation);
                    __mmask64 mask5 = _mm512_cmple_epi8_mask(input5, continuation);
                    __mmask64 mask6 = _mm512_cmple_epi8_mask(input6, continuation);
                    __mmask64 mask7 = _mm512_cmple_epi8_mask(input7, continuation);
                    __mmask64 mask8 = _mm512_cmple_epi8_mask(input8, continuation);

                    __m512i mask_register = _mm512_set_epi64(mask8, mask7, mask6, mask5,
                        mask4, mask3, mask2, mask1);

                    unrolled_popcount = _mm512_add_epi64(unrolled_popcount,
                        _mm512_popcnt_epi64(mask_register));
                }

                for (; i <= max_i; i += sizeof(__m512i))
                {
                    __m512i more_input = _mm512_loadu_si512((const __m512i*)(str + i));
                    uint64_t continuation_bitmask = static_cast<uint64_t>(
                        _mm512_cmple_epi8_mask(more_input, continuation));
                    answer -= count_ones(continuation_bitmask);
                }
            }

            answer -= _mm512_reduce_add_epi64(unrolled_popcount);

            return answer + scalar::utf8::count_code_points(reinterpret_cast<const char*>(str + i), length - i);
        }

    } // namespace icelake
} // namespace simdutf

    /* begin file src/simdutf/icelake/end.h */
    #if SIMDUTF_CAN_ALWAYS_RUN_ICELAKE
    // nothing needed.
    #else
SIMDUTF_UNTARGET_REGION
    #endif

    #if SIMDUTF_GCC11ORMORE // workaround for
                            // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
SIMDUTF_POP_DISABLE_WARNINGS
    #endif // end of workaround
/* end file src/simdutf/icelake/end.h */
/* end file src/icelake/implementation.cpp */
#endif
#if SIMDUTF_IMPLEMENTATION_HASWELL
    /* begin file src/haswell/implementation.cpp */
    /* begin file src/simdutf/haswell/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "haswell"
    // #define SIMDUTF_IMPLEMENTATION haswell
    #define SIMDUTF_SIMD_HAS_BYTEMASK 1

    #if SIMDUTF_CAN_ALWAYS_RUN_HASWELL
    // nothing needed.
    #else
SIMDUTF_TARGET_HASWELL
    #endif

    #if SIMDUTF_GCC11ORMORE // workaround for
                            // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
// clang-format off
SIMDUTF_DISABLE_GCC_WARNING(-Wmaybe-uninitialized)
    // clang-format on
    #endif // end of workaround
/* end file src/simdutf/haswell/begin.h */

namespace simdutf
{
    namespace haswell
    {
        namespace
        {
    #ifndef SIMDUTF_HASWELL_H
        #error "haswell.h must be included"
    #endif
            using namespace simd;

            simdutf_really_inline bool is_ascii(const simd8x64<uint8_t>& input)
            {
                return input.reduce_or().is_ascii();
            }

            simdutf_really_inline simd8<bool>
            must_be_2_3_continuation(const simd8<uint8_t> prev2,
                const simd8<uint8_t> prev3)
            {
                simd8<uint8_t> is_third_byte = prev2.saturating_sub(0xe0u - 0x80); // Only 111_____ will be > 0x80
                simd8<uint8_t> is_fourth_byte = prev3.saturating_sub(0xf0u - 0x80); // Only 1111____ will be > 0x80
                return simd8<bool>(is_third_byte | is_fourth_byte);
            }

        } // unnamed namespace
    } // namespace haswell
} // namespace simdutf

/* begin file src/generic/buf_block_reader.h */
namespace simdutf
{
    namespace haswell
    {
        namespace
        {

            // Walks through a buffer in block-sized increments, loading the last part with
            // spaces
            template <size_t STEP_SIZE>
            struct buf_block_reader
            {
            public:
                simdutf_really_inline buf_block_reader(const uint8_t* _buf, size_t _len);
                simdutf_really_inline size_t block_index();
                simdutf_really_inline bool has_full_block() const;
                simdutf_really_inline const uint8_t* full_block() const;
                /**
                 * Get the last block, padded with spaces.
                 *
                 * There will always be a last block, with at least 1 byte, unless len == 0
                 * (in which case this function fills the buffer with spaces and returns 0. In
                 * particular, if len == STEP_SIZE there will be 0 full_blocks and 1 remainder
                 * block with STEP_SIZE bytes and no spaces for padding.
                 *
                 * @return the number of effective characters in the last block.
                 */
                simdutf_really_inline size_t get_remainder(uint8_t* dst) const;
                simdutf_really_inline void advance();

            private:
                const uint8_t* buf;
                const size_t len;
                const size_t lenminusstep;
                size_t idx;
            };

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text_64(const uint8_t* text)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    buf[i] = int8_t(text[i]) < ' ' ? '_' : int8_t(text[i]);
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text(const simd8x64<uint8_t>& in)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                in.store(reinterpret_cast<uint8_t*>(buf));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    if (buf[i] < ' ')
                    {
                        buf[i] = '_';
                    }
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            simdutf_unused static char* format_mask(uint64_t mask)
            {
                static char* buf = reinterpret_cast<char*>(malloc(64 + 1));
                for (size_t i = 0; i < 64; i++)
                {
                    buf[i] = (mask & (size_t(1) << i)) ? 'X' : ' ';
                }
                buf[64] = '\0';
                return buf;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline
            buf_block_reader<STEP_SIZE>::buf_block_reader(const uint8_t* _buf, size_t _len)
                : buf { _buf }
                , len { _len }
                , lenminusstep { len < STEP_SIZE ? 0 : len - STEP_SIZE }
                , idx { 0 }
            {
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t buf_block_reader<STEP_SIZE>::block_index()
            {
                return idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline bool buf_block_reader<STEP_SIZE>::has_full_block() const
            {
                return idx < lenminusstep;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline const uint8_t*
            buf_block_reader<STEP_SIZE>::full_block() const
            {
                return &buf[idx];
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t
            buf_block_reader<STEP_SIZE>::get_remainder(uint8_t* dst) const
            {
                if (len == idx)
                {
                    return 0;
                } // memcpy(dst, null, 0) will trigger an error with some sanitizers
                std::memset(dst, 0x20,
                    STEP_SIZE); // std::memset STEP_SIZE because it is more efficient
                                // to write out 8 or 16 bytes at once.
                std::memcpy(dst, buf + idx, len - idx);
                return len - idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance()
            {
                idx += STEP_SIZE;
            }

        } // unnamed namespace
    } // namespace haswell
} // namespace simdutf
/* end file src/generic/buf_block_reader.h */
/* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
namespace simdutf
{
    namespace haswell
    {
        namespace
        {
            namespace utf8_validation
            {

                using namespace simd;

                simdutf_really_inline simd8<uint8_t>
                check_special_cases(const simd8<uint8_t> input, const simd8<uint8_t> prev1)
                {
                    // Bit 0 = Too Short (lead byte/ASCII followed by lead byte/ASCII)
                    // Bit 1 = Too Long (ASCII followed by continuation)
                    // Bit 2 = Overlong 3-byte
                    // Bit 4 = Surrogate
                    // Bit 5 = Overlong 2-byte
                    // Bit 7 = Two Continuations
                    constexpr const uint8_t TOO_SHORT = 1 << 0; // 11______ 0_______
                                                                // 11______ 11______
                    constexpr const uint8_t TOO_LONG = 1 << 1; // 0_______ 10______
                    constexpr const uint8_t OVERLONG_3 = 1 << 2; // 11100000 100_____
                    constexpr const uint8_t SURROGATE = 1 << 4; // 11101101 101_____
                    constexpr const uint8_t OVERLONG_2 = 1 << 5; // 1100000_ 10______
                    constexpr const uint8_t TWO_CONTS = 1 << 7; // 10______ 10______
                    constexpr const uint8_t TOO_LARGE = 1 << 3; // 11110100 1001____
                                                                // 11110100 101_____
                                                                // 11110101 1001____
                                                                // 11110101 101_____
                                                                // 1111011_ 1001____
                                                                // 1111011_ 101_____
                                                                // 11111___ 1001____
                                                                // 11111___ 101_____
                    constexpr const uint8_t TOO_LARGE_1000 = 1 << 6;
                    // 11110101 1000____
                    // 1111011_ 1000____
                    // 11111___ 1000____
                    constexpr const uint8_t OVERLONG_4 = 1 << 6; // 11110000 1000____

                    const simd8<uint8_t> byte_1_high = prev1.shr<4>().lookup_16<uint8_t>(
                        // 0_______ ________ <ASCII in byte 1>
                        TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG,
                        TOO_LONG,
                        // 10______ ________ <continuation in byte 1>
                        TWO_CONTS, TWO_CONTS, TWO_CONTS, TWO_CONTS,
                        // 1100____ ________ <two byte lead in byte 1>
                        TOO_SHORT | OVERLONG_2,
                        // 1101____ ________ <two byte lead in byte 1>
                        TOO_SHORT,
                        // 1110____ ________ <three byte lead in byte 1>
                        TOO_SHORT | OVERLONG_3 | SURROGATE,
                        // 1111____ ________ <four+ byte lead in byte 1>
                        TOO_SHORT | TOO_LARGE | TOO_LARGE_1000 | OVERLONG_4);
                    constexpr const uint8_t CARRY = TOO_SHORT | TOO_LONG | TWO_CONTS; // These all have ____ in byte 1 .
                    const simd8<uint8_t> byte_1_low = (prev1 & 0x0F)
                                                          .lookup_16<uint8_t>(
                                                              // ____0000 ________
                                                              CARRY | OVERLONG_3 | OVERLONG_2 | OVERLONG_4,
                                                              // ____0001 ________
                                                              CARRY | OVERLONG_2,
                                                              // ____001_ ________
                                                              CARRY, CARRY,

                                                              // ____0100 ________
                                                              CARRY | TOO_LARGE,
                                                              // ____0101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____011_ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,

                                                              // ____1___ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____1101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000 | SURROGATE,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000);
                    const simd8<uint8_t> byte_2_high = input.shr<4>().lookup_16<uint8_t>(
                        // ________ 0_______ <ASCII in byte 2>
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT,
                        TOO_SHORT, TOO_SHORT,

                        // ________ 1000____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE_1000 | OVERLONG_4,
                        // ________ 1001____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE,
                        // ________ 101_____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,

                        // ________ 11______
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT);
                    return (byte_1_high & byte_1_low & byte_2_high);
                }
                simdutf_really_inline simd8<uint8_t>
                check_multibyte_lengths(const simd8<uint8_t> input,
                    const simd8<uint8_t> prev_input,
                    const simd8<uint8_t> sc)
                {
                    simd8<uint8_t> prev2 = input.prev<2>(prev_input);
                    simd8<uint8_t> prev3 = input.prev<3>(prev_input);
                    simd8<uint8_t> must23 = simd8<uint8_t>(must_be_2_3_continuation(prev2, prev3));
                    simd8<uint8_t> must23_80 = must23 & uint8_t(0x80);
                    return must23_80 ^ sc;
                }

                //
                // Return nonzero if there are incomplete multibyte characters at the end of the
                // block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
                //
                simdutf_really_inline simd8<uint8_t> is_incomplete(const simd8<uint8_t> input)
                {
                    // If the previous input's last 3 bytes match this, they're too short (they
                    // ended at EOF):
                    // ... 1111____ 111_____ 11______
                    static const uint8_t max_array[32] = { 255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        0b11110000u - 1,
                        0b11100000u - 1,
                        0b11000000u - 1 };
                    const simd8<uint8_t> max_value(
                        &max_array[sizeof(max_array) - sizeof(simd8<uint8_t>)]);
                    return input.gt_bits(max_value);
                }

                struct utf8_checker
                {
                    // If this is nonzero, there has been a UTF-8 error.
                    simd8<uint8_t> error;
                    // The last input we received
                    simd8<uint8_t> prev_input_block;
                    // Whether the last input we received was incomplete (used for ASCII fast
                    // path)
                    simd8<uint8_t> prev_incomplete;

                    //
                    // Check whether the current bytes are valid UTF-8.
                    //
                    simdutf_really_inline void check_utf8_bytes(const simd8<uint8_t> input,
                        const simd8<uint8_t> prev_input)
                    {
                        // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
                        // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
                        // small negative numbers)
                        simd8<uint8_t> prev1 = input.prev<1>(prev_input);
                        simd8<uint8_t> sc = check_special_cases(input, prev1);
                        this->error |= check_multibyte_lengths(input, prev_input, sc);
                    }

                    // The only problem that can happen at EOF is that a multibyte character is
                    // too short or a byte value too large in the last bytes: check_special_cases
                    // only checks for bytes too large in the first of two bytes.
                    simdutf_really_inline void check_eof()
                    {
                        // If the previous block had incomplete UTF-8 characters at the end, an
                        // ASCII block can't possibly finish them.
                        this->error |= this->prev_incomplete;
                    }

                    simdutf_really_inline void check_next_input(const simd8x64<uint8_t>& input)
                    {
                        if (simdutf_likely(is_ascii(input)))
                        {
                            this->error |= this->prev_incomplete;
                        }
                        else
                        {
                            // you might think that a for-loop would work, but under Visual Studio, it
                            // is not good enough.
                            static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),
                                "We support either two or four chunks per 64-byte block.");
                            if (simd8x64<uint8_t>::NUM_CHUNKS == 2)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                            }
                            else if (simd8x64<uint8_t>::NUM_CHUNKS == 4)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                                this->check_utf8_bytes(input.chunks[2], input.chunks[1]);
                                this->check_utf8_bytes(input.chunks[3], input.chunks[2]);
                            }
                            this->prev_incomplete = is_incomplete(input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1]);
                            this->prev_input_block = input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1];
                        }
                    }

                    // do not forget to call check_eof!
                    simdutf_really_inline bool errors() const
                    {
                        return this->error.any_bits_set_anywhere();
                    }

                }; // struct utf8_checker
            } // namespace utf8_validation

            using utf8_validation::utf8_checker;

        } // unnamed namespace
    } // namespace haswell
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
/* begin file src/generic/utf8_validation/utf8_validator.h */
namespace simdutf
{
    namespace haswell
    {
        namespace
        {
            namespace utf8_validation
            {

                /**
                 * Validates that the string is actual UTF-8.
                 */
                template <class checker>
                bool generic_validate_utf8(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        reader.advance();
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    return !c.errors();
                }

                bool generic_validate_utf8(const char* input, size_t length)
                {
                    return generic_validate_utf8<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

                /**
                 * Validates that the string is actual UTF-8 and stops on errors.
                 */
                template <class checker>
                result generic_validate_utf8_with_errors(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    size_t count { 0 };
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        if (c.errors())
                        {
                            if (count != 0)
                            {
                                count--;
                            } // Sometimes the error is only detected in the next chunk
                            result res = scalar::utf8::rewind_and_validate_with_errors(
                                reinterpret_cast<const char*>(input),
                                reinterpret_cast<const char*>(input + count), length - count);
                            res.count += count;
                            return res;
                        }
                        reader.advance();
                        count += 64;
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    if (c.errors())
                    {
                        if (count != 0)
                        {
                            count--;
                        } // Sometimes the error is only detected in the next chunk
                        result res = scalar::utf8::rewind_and_validate_with_errors(
                            reinterpret_cast<const char*>(input),
                            reinterpret_cast<const char*>(input) + count, length - count);
                        res.count += count;
                        return res;
                    }
                    else
                    {
                        return result(error_code::SUCCESS, length);
                    }
                }

                result generic_validate_utf8_with_errors(const char* input, size_t length)
                {
                    return generic_validate_utf8_with_errors<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

            } // namespace utf8_validation
        } // unnamed namespace
    } // namespace haswell
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_validator.h */

// other functions
/* begin file src/generic/utf8.h */
namespace simdutf
{
    namespace haswell
    {
        namespace
        {
            namespace utf8
            {

                using namespace simd;

                simdutf_really_inline size_t count_code_points(const char* in, size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.gt(-65);
                        count += count_ones(utf8_continuation_mask);
                    }
                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }

    #ifdef SIMDUTF_SIMD_HAS_BYTEMASK
                simdutf_really_inline size_t count_code_points_bytemask(const char* in,
                    size_t size)
                {
                    using vector_i8 = simd8<int8_t>;
                    using vector_u8 = simd8<uint8_t>;
                    using vector_u64 = simd64<uint64_t>;

                    constexpr size_t N = vector_i8::SIZE;
                    constexpr size_t max_iterations = 255 / 4;

                    size_t pos = 0;
                    size_t count = 0;

                    auto counters = vector_u64::zero();
                    auto local = vector_u8::zero();
                    size_t iterations = 0;
                    for (; pos + 4 * N <= size; pos += 4 * N)
                    {
                        const auto input0 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 0 * N));
                        const auto input1 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 1 * N));
                        const auto input2 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 2 * N));
                        const auto input3 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 3 * N));
                        const auto mask0 = input0 > int8_t(-65);
                        const auto mask1 = input1 > int8_t(-65);
                        const auto mask2 = input2 > int8_t(-65);
                        const auto mask3 = input3 > int8_t(-65);

                        local -= vector_u8(mask0);
                        local -= vector_u8(mask1);
                        local -= vector_u8(mask2);
                        local -= vector_u8(mask3);

                        iterations += 1;
                        if (iterations == max_iterations)
                        {
                            counters += sum_8bytes(local);
                            local = vector_u8::zero();
                            iterations = 0;
                        }
                    }

                    if (iterations > 0)
                    {
                        count += local.sum_bytes();
                    }

                    count += counters.sum();

                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }
    #endif

                simdutf_really_inline size_t utf16_length_from_utf8(const char* in,
                    size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    // This algorithm could no doubt be improved!
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.lt(-65 + 1);
                        // We count one word for anything that is not a continuation (so
                        // leading bytes).
                        count += 64 - count_ones(utf8_continuation_mask);
                        int64_t utf8_4byte = input.gteq_unsigned(240);
                        count += count_ones(utf8_4byte);
                    }
                    return count + scalar::utf8::utf16_length_from_utf8(in + pos, size - pos);
                }
            } // namespace utf8
        } // unnamed namespace
    } // namespace haswell
} // namespace simdutf
/* end file src/generic/utf8.h */

namespace simdutf
{
    namespace haswell
    {

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* buf, size_t len) const noexcept
        {
            return haswell::utf8_validation::generic_validate_utf8(buf, len);
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* buf, size_t len) const noexcept
        {
            return haswell::utf8_validation::generic_validate_utf8_with_errors(buf, len);
        }

        simdutf_warn_unused size_t
        implementation::count_utf8(const char* in, size_t size) const noexcept
        {
            return utf8::count_code_points_bytemask(in, size);
        }

    } // namespace haswell
} // namespace simdutf

    /* begin file src/simdutf/haswell/end.h */
    #if SIMDUTF_CAN_ALWAYS_RUN_HASWELL
    // nothing needed.
    #else
SIMDUTF_UNTARGET_REGION
    #endif

    #undef SIMDUTF_SIMD_HAS_BYTEMASK

    #if SIMDUTF_GCC11ORMORE // workaround for
                            // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=105593
SIMDUTF_POP_DISABLE_WARNINGS
    #endif // end of workaround
/* end file src/simdutf/haswell/end.h */
/* end file src/haswell/implementation.cpp */
#endif
#if SIMDUTF_IMPLEMENTATION_PPC64
    /* begin file src/ppc64/implementation.cpp */
    /* begin file src/simdutf/ppc64/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "ppc64"
    // #define SIMDUTF_IMPLEMENTATION ppc64
    /* end file src/simdutf/ppc64/begin.h */

    /* begin file src/ppc64/ppc64_utf16_to_utf8_tables.h */
    // Code generated automatically; DO NOT EDIT
    // file generated by scripts/ppc64_convert_utf16_to_utf8.py
    #ifndef PPC64_SIMDUTF_UTF16_TO_UTF8_TABLES_H
        #define PPC64_SIMDUTF_UTF16_TO_UTF8_TABLES_H

namespace simdutf
{
    namespace
    {
        namespace tables
        {
            namespace ppc64_utf16_to_utf8
            {

        #if SIMDUTF_IS_BIG_ENDIAN
                // 1 byte for length, 16 bytes for mask
                const uint8_t pack_1_2_3_utf8_bytes[256][17] = {
                    { 12, 1, 0, 16, 3, 2, 18, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 3, 2, 18, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 0, 16, 3, 2, 18, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 17, 3, 2, 18, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 1, 0, 16, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 11, 1, 0, 16, 2, 18, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 2, 18, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 0, 16, 2, 18, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 17, 2, 18, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 1, 0, 16, 19, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 19, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 16, 19, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 17, 19, 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 0, 16, 3, 2, 18, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 3, 2, 18, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 3, 2, 18, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 3, 2, 18, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 1, 0, 16, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 1, 0, 16, 2, 18, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 18, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 2, 18, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 2, 18, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 0, 16, 19, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 19, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 19, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 19, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 11, 1, 0, 16, 3, 2, 18, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 3, 2, 18, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 0, 16, 3, 2, 18, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 17, 3, 2, 18, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 1, 0, 16, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 1, 0, 16, 2, 18, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 2, 18, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 16, 2, 18, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 17, 2, 18, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 0, 16, 19, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 19, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 19, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 19, 4, 20, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 1, 0, 16, 3, 2, 18, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 3, 2, 18, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 16, 3, 2, 18, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 17, 3, 2, 18, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 1, 0, 16, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 1, 0, 16, 2, 18, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 18, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 2, 18, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 2, 18, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 1, 0, 16, 19, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 19, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 19, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 19, 21, 7, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 1, 0, 16, 3, 2, 18, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 3, 2, 18, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 3, 2, 18, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 3, 2, 18, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 1, 0, 16, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 1, 0, 16, 2, 18, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 18, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 2, 18, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 2, 18, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 0, 16, 19, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 19, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 19, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 19, 5, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 1, 0, 16, 3, 2, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 3, 2, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 3, 2, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 3, 2, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 1, 0, 16, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 2, 0, 16, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 17, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 5, 1, 0, 16, 2, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 2, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 0, 16, 2, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 17, 2, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 1, 0, 16, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 0, 16, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 17, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 8, 1, 0, 16, 3, 2, 18, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 3, 2, 18, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 3, 2, 18, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 3, 2, 18, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 1, 0, 16, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 0, 16, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 17, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 1, 0, 16, 2, 18, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 2, 18, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 2, 18, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 2, 18, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 1, 0, 16, 19, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 19, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 19, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 19, 4, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 1, 0, 16, 3, 2, 18, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 3, 2, 18, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 3, 2, 18, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 3, 2, 18, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 1, 0, 16, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 0, 16, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 17, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 6, 1, 0, 16, 2, 18, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 2, 18, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 2, 18, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 2, 18, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 0, 16, 19, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 19, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 4, 0, 16, 19, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 17, 19, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 11, 1, 0, 16, 3, 2, 18, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 3, 2, 18, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 0, 16, 3, 2, 18, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 17, 3, 2, 18, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 1, 0, 16, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 1, 0, 16, 2, 18, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 2, 18, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 16, 2, 18, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 17, 2, 18, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 0, 16, 19, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 19, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 19, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 19, 5, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 1, 0, 16, 3, 2, 18, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 3, 2, 18, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 3, 2, 18, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 3, 2, 18, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 1, 0, 16, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 0, 16, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 17, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 1, 0, 16, 2, 18, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 2, 18, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 2, 18, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 2, 18, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 1, 0, 16, 19, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 19, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 19, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 19, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 10, 1, 0, 16, 3, 2, 18, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 3, 2, 18, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 16, 3, 2, 18, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 17, 3, 2, 18, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 1, 0, 16, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 1, 0, 16, 2, 18, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 18, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 2, 18, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 2, 18, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 1, 0, 16, 19, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 19, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 19, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 19, 4, 20, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 1, 0, 16, 3, 2, 18, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 3, 2, 18, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 3, 2, 18, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 3, 2, 18, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 1, 0, 16, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 1, 0, 16, 2, 18, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 18, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 2, 18, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 2, 18, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 0, 16, 19, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 19, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 19, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 19, 21, 6, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 1, 0, 16, 3, 2, 18, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 3, 2, 18, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 16, 3, 2, 18, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 17, 3, 2, 18, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 1, 0, 16, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 1, 0, 16, 2, 18, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 18, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 2, 18, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 2, 18, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 1, 0, 16, 19, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 19, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 19, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 19, 5, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 0, 16, 3, 2, 18, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 3, 2, 18, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 3, 2, 18, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 3, 2, 18, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 1, 0, 16, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 0, 16, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 17, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 6, 1, 0, 16, 2, 18, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 2, 18, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 2, 18, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 2, 18, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 0, 16, 19, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 19, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 4, 0, 16, 19, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 17, 19, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 9, 1, 0, 16, 3, 2, 18, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 3, 2, 18, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 16, 3, 2, 18, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 17, 3, 2, 18, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 1, 0, 16, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 1, 0, 16, 2, 18, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 18, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 2, 18, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 2, 18, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 0, 16, 19, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 19, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 19, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 19, 4, 20, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 0, 16, 3, 2, 18, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 3, 2, 18, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 16, 3, 2, 18, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 17, 3, 2, 18, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 1, 0, 16, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 4, 0, 16, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 17, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 1, 0, 16, 2, 18, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 2, 18, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 0, 16, 2, 18, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 17, 2, 18, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 1, 0, 16, 19, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 19, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 16, 19, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 17, 19, 21, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                };
        #else
                // 1 byte for length, 16 bytes for mask
                const uint8_t pack_1_2_3_utf8_bytes[256][17] = {
                    { 12, 0, 1, 17, 2, 3, 19, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 2, 3, 19, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 11, 1, 17, 2, 3, 19, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 10, 16, 2, 3, 19, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 0, 1, 17, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 11, 0, 1, 17, 3, 19, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 3, 19, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 1, 17, 3, 19, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 16, 3, 19, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 0, 1, 17, 18, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 18, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 17, 18, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 16, 18, 4, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 1, 17, 2, 3, 19, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 2, 3, 19, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 2, 3, 19, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 2, 3, 19, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 1, 17, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 0, 1, 17, 3, 19, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 3, 19, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 3, 19, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 3, 19, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 1, 17, 18, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 18, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 18, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 18, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 11, 0, 1, 17, 2, 3, 19, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 2, 3, 19, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 1, 17, 2, 3, 19, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 16, 2, 3, 19, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 1, 17, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 0, 1, 17, 3, 19, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 3, 19, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 17, 3, 19, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 16, 3, 19, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 1, 17, 18, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 18, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 18, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 18, 5, 21, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 0, 1, 17, 2, 3, 19, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 2, 3, 19, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 17, 2, 3, 19, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 16, 2, 3, 19, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 1, 17, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 0, 1, 17, 3, 19, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 3, 19, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 3, 19, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 3, 19, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 1, 17, 18, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 18, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 18, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 18, 20, 6, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 0, 1, 17, 2, 3, 19, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 6, 2, 3, 19, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 2, 3, 19, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 2, 3, 19, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 1, 17, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 0, 1, 17, 3, 19, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 3, 19, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 3, 19, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 3, 19, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 1, 17, 18, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 18, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 18, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 18, 4, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 0, 1, 17, 2, 3, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 2, 3, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 2, 3, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 2, 3, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 0, 1, 17, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 2, 1, 17, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 16, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 5, 0, 1, 17, 3, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 3, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 1, 17, 3, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 16, 3, 19, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 0, 1, 17, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 1, 17, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 16, 18, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 8, 0, 1, 17, 2, 3, 19, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 3, 19, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 2, 3, 19, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 2, 3, 19, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 1, 17, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 1, 17, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 16, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 0, 1, 17, 3, 19, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 3, 19, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 3, 19, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 3, 19, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 0, 1, 17, 18, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 18, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 18, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 18, 5, 21, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 0, 1, 17, 2, 3, 19, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 2, 3, 19, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 2, 3, 19, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 2, 3, 19, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 1, 17, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 1, 17, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 16, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 6, 0, 1, 17, 3, 19, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 3, 19, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 3, 19, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 3, 19, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 1, 17, 18, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 18, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 4, 1, 17, 18, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 16, 18, 20, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 11, 0, 1, 17, 2, 3, 19, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 8, 2, 3, 19, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 10, 1, 17, 2, 3, 19, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 9, 16, 2, 3, 19, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 1, 17, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 0, 1, 17, 3, 19, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 3, 19, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 17, 3, 19, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 16, 3, 19, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 0, 1, 17, 18, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 18, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 18, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 18, 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 1, 17, 2, 3, 19, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 3, 19, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 2, 3, 19, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 2, 3, 19, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 1, 17, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 4, 1, 17, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 16, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 0, 1, 17, 3, 19, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 3, 19, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 3, 19, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 3, 19, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 0, 1, 17, 18, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 18, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 18, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 18, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 10, 0, 1, 17, 2, 3, 19, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 2, 3, 19, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 17, 2, 3, 19, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 16, 2, 3, 19, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 1, 17, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 0, 1, 17, 3, 19, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 3, 19, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 3, 19, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 3, 19, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 1, 17, 18, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 18, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 18, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 18, 5, 21, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 0, 1, 17, 2, 3, 19, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 3, 19, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 2, 3, 19, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 2, 3, 19, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 1, 17, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 0, 1, 17, 3, 19, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 3, 19, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 3, 19, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 3, 19, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 1, 17, 18, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 18, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 18, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 18, 20, 7, 23, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 10, 0, 1, 17, 2, 3, 19, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80 },
                    { 7, 2, 3, 19, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 9, 1, 17, 2, 3, 19, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 16, 2, 3, 19, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 0, 1, 17, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 9, 0, 1, 17, 3, 19, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 3, 19, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 3, 19, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 3, 19, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 8, 0, 1, 17, 18, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 18, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 18, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 18, 4, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 1, 17, 2, 3, 19, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 2, 3, 19, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 2, 3, 19, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 2, 3, 19, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 0, 1, 17, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 1, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 3, 1, 17, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 2, 16, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 6, 0, 1, 17, 3, 19, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 3, 19, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 3, 19, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 3, 19, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 0, 1, 17, 18, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 18, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 4, 1, 17, 18, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 16, 18, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 9, 0, 1, 17, 2, 3, 19, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 2, 3, 19, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 1, 17, 2, 3, 19, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 7, 16, 2, 3, 19, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 0, 1, 17, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 8, 0, 1, 17, 3, 19, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 3, 19, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 3, 19, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 3, 19, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 0, 1, 17, 18, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 18, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 18, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 18, 5, 21, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 8, 0, 1, 17, 2, 3, 19, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 5, 2, 3, 19, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 7, 1, 17, 2, 3, 19, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 6, 16, 2, 3, 19, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 0, 1, 17, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 2, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80, 0x80 },
                    { 4, 1, 17, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 3, 16, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 7, 0, 1, 17, 3, 19, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80 },
                    { 4, 3, 19, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 6, 1, 17, 3, 19, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 5, 16, 3, 19, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 6, 0, 1, 17, 18, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 3, 18, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                    { 5, 1, 17, 18, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80 },
                    { 4, 16, 18, 20, 22, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
                        0x80, 0x80, 0x80 },
                };
        #endif // SIMDUTF_IS_BIG_ENDIAN
            } // namespace ppc64_utf16_to_utf8
        } // namespace tables
    } // unnamed namespace
} // namespace simdutf

    #endif // PPC64_SIMDUTF_UTF16_TO_UTF8_TABLES_H
/* end file src/ppc64/ppc64_utf16_to_utf8_tables.h */

namespace simdutf
{
    namespace ppc64
    {
        namespace
        {
    #ifndef SIMDUTF_PPC64_H
        #error "ppc64.h must be included"
    #endif
            using namespace simd;

            simdutf_really_inline bool is_ascii(const simd8x64<uint8_t>& input)
            {
                // careful: 0x80 is not ascii.
                return input.reduce_or().saturating_sub(0b01111111u).bits_not_set_anywhere();
            }

            simdutf_really_inline simd8<bool>
            must_be_2_3_continuation(const simd8<uint8_t> prev2,
                const simd8<uint8_t> prev3)
            {
                simd8<uint8_t> is_third_byte = prev2.saturating_sub(0xe0u - 0x80); // Only 111_____ will be >= 0x80
                simd8<uint8_t> is_fourth_byte = prev3.saturating_sub(0xf0u - 0x80); // Only 1111____ will be >= 0x80
                // Caller requires a bool (all 1's). All values resulting from the subtraction
                // will be <= 64, so signed comparison is fine.
                return simd8<bool>(is_third_byte | is_fourth_byte);
            }

            /// ErrorReporting describes behaviour of a vectorized procedure regarding error
            /// checking
            enum class ErrorReporting
            {
                precise, // the procedure will report *approximate* or *precise* error
                         // position
                at_the_end, // the procedure will only inform about an error after scanning
                            // the whole input (or its significant portion)
                none, // no error checking is done, we assume valid inputs
            };

        } // unnamed namespace
    } // namespace ppc64
} // namespace simdutf

/* begin file src/generic/buf_block_reader.h */
namespace simdutf
{
    namespace ppc64
    {
        namespace
        {

            // Walks through a buffer in block-sized increments, loading the last part with
            // spaces
            template <size_t STEP_SIZE>
            struct buf_block_reader
            {
            public:
                simdutf_really_inline buf_block_reader(const uint8_t* _buf, size_t _len);
                simdutf_really_inline size_t block_index();
                simdutf_really_inline bool has_full_block() const;
                simdutf_really_inline const uint8_t* full_block() const;
                /**
                 * Get the last block, padded with spaces.
                 *
                 * There will always be a last block, with at least 1 byte, unless len == 0
                 * (in which case this function fills the buffer with spaces and returns 0. In
                 * particular, if len == STEP_SIZE there will be 0 full_blocks and 1 remainder
                 * block with STEP_SIZE bytes and no spaces for padding.
                 *
                 * @return the number of effective characters in the last block.
                 */
                simdutf_really_inline size_t get_remainder(uint8_t* dst) const;
                simdutf_really_inline void advance();

            private:
                const uint8_t* buf;
                const size_t len;
                const size_t lenminusstep;
                size_t idx;
            };

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text_64(const uint8_t* text)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    buf[i] = int8_t(text[i]) < ' ' ? '_' : int8_t(text[i]);
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text(const simd8x64<uint8_t>& in)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                in.store(reinterpret_cast<uint8_t*>(buf));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    if (buf[i] < ' ')
                    {
                        buf[i] = '_';
                    }
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            simdutf_unused static char* format_mask(uint64_t mask)
            {
                static char* buf = reinterpret_cast<char*>(malloc(64 + 1));
                for (size_t i = 0; i < 64; i++)
                {
                    buf[i] = (mask & (size_t(1) << i)) ? 'X' : ' ';
                }
                buf[64] = '\0';
                return buf;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline
            buf_block_reader<STEP_SIZE>::buf_block_reader(const uint8_t* _buf, size_t _len)
                : buf { _buf }
                , len { _len }
                , lenminusstep { len < STEP_SIZE ? 0 : len - STEP_SIZE }
                , idx { 0 }
            {
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t buf_block_reader<STEP_SIZE>::block_index()
            {
                return idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline bool buf_block_reader<STEP_SIZE>::has_full_block() const
            {
                return idx < lenminusstep;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline const uint8_t*
            buf_block_reader<STEP_SIZE>::full_block() const
            {
                return &buf[idx];
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t
            buf_block_reader<STEP_SIZE>::get_remainder(uint8_t* dst) const
            {
                if (len == idx)
                {
                    return 0;
                } // memcpy(dst, null, 0) will trigger an error with some sanitizers
                std::memset(dst, 0x20,
                    STEP_SIZE); // std::memset STEP_SIZE because it is more efficient
                                // to write out 8 or 16 bytes at once.
                std::memcpy(dst, buf + idx, len - idx);
                return len - idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance()
            {
                idx += STEP_SIZE;
            }

        } // unnamed namespace
    } // namespace ppc64
} // namespace simdutf
/* end file src/generic/buf_block_reader.h */
/* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
namespace simdutf
{
    namespace ppc64
    {
        namespace
        {
            namespace utf8_validation
            {

                using namespace simd;

                simdutf_really_inline simd8<uint8_t>
                check_special_cases(const simd8<uint8_t> input, const simd8<uint8_t> prev1)
                {
                    // Bit 0 = Too Short (lead byte/ASCII followed by lead byte/ASCII)
                    // Bit 1 = Too Long (ASCII followed by continuation)
                    // Bit 2 = Overlong 3-byte
                    // Bit 4 = Surrogate
                    // Bit 5 = Overlong 2-byte
                    // Bit 7 = Two Continuations
                    constexpr const uint8_t TOO_SHORT = 1 << 0; // 11______ 0_______
                                                                // 11______ 11______
                    constexpr const uint8_t TOO_LONG = 1 << 1; // 0_______ 10______
                    constexpr const uint8_t OVERLONG_3 = 1 << 2; // 11100000 100_____
                    constexpr const uint8_t SURROGATE = 1 << 4; // 11101101 101_____
                    constexpr const uint8_t OVERLONG_2 = 1 << 5; // 1100000_ 10______
                    constexpr const uint8_t TWO_CONTS = 1 << 7; // 10______ 10______
                    constexpr const uint8_t TOO_LARGE = 1 << 3; // 11110100 1001____
                                                                // 11110100 101_____
                                                                // 11110101 1001____
                                                                // 11110101 101_____
                                                                // 1111011_ 1001____
                                                                // 1111011_ 101_____
                                                                // 11111___ 1001____
                                                                // 11111___ 101_____
                    constexpr const uint8_t TOO_LARGE_1000 = 1 << 6;
                    // 11110101 1000____
                    // 1111011_ 1000____
                    // 11111___ 1000____
                    constexpr const uint8_t OVERLONG_4 = 1 << 6; // 11110000 1000____

                    const simd8<uint8_t> byte_1_high = prev1.shr<4>().lookup_16<uint8_t>(
                        // 0_______ ________ <ASCII in byte 1>
                        TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG,
                        TOO_LONG,
                        // 10______ ________ <continuation in byte 1>
                        TWO_CONTS, TWO_CONTS, TWO_CONTS, TWO_CONTS,
                        // 1100____ ________ <two byte lead in byte 1>
                        TOO_SHORT | OVERLONG_2,
                        // 1101____ ________ <two byte lead in byte 1>
                        TOO_SHORT,
                        // 1110____ ________ <three byte lead in byte 1>
                        TOO_SHORT | OVERLONG_3 | SURROGATE,
                        // 1111____ ________ <four+ byte lead in byte 1>
                        TOO_SHORT | TOO_LARGE | TOO_LARGE_1000 | OVERLONG_4);
                    constexpr const uint8_t CARRY = TOO_SHORT | TOO_LONG | TWO_CONTS; // These all have ____ in byte 1 .
                    const simd8<uint8_t> byte_1_low = (prev1 & 0x0F)
                                                          .lookup_16<uint8_t>(
                                                              // ____0000 ________
                                                              CARRY | OVERLONG_3 | OVERLONG_2 | OVERLONG_4,
                                                              // ____0001 ________
                                                              CARRY | OVERLONG_2,
                                                              // ____001_ ________
                                                              CARRY, CARRY,

                                                              // ____0100 ________
                                                              CARRY | TOO_LARGE,
                                                              // ____0101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____011_ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,

                                                              // ____1___ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____1101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000 | SURROGATE,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000);
                    const simd8<uint8_t> byte_2_high = input.shr<4>().lookup_16<uint8_t>(
                        // ________ 0_______ <ASCII in byte 2>
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT,
                        TOO_SHORT, TOO_SHORT,

                        // ________ 1000____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE_1000 | OVERLONG_4,
                        // ________ 1001____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE,
                        // ________ 101_____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,

                        // ________ 11______
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT);
                    return (byte_1_high & byte_1_low & byte_2_high);
                }
                simdutf_really_inline simd8<uint8_t>
                check_multibyte_lengths(const simd8<uint8_t> input,
                    const simd8<uint8_t> prev_input,
                    const simd8<uint8_t> sc)
                {
                    simd8<uint8_t> prev2 = input.prev<2>(prev_input);
                    simd8<uint8_t> prev3 = input.prev<3>(prev_input);
                    simd8<uint8_t> must23 = simd8<uint8_t>(must_be_2_3_continuation(prev2, prev3));
                    simd8<uint8_t> must23_80 = must23 & uint8_t(0x80);
                    return must23_80 ^ sc;
                }

                //
                // Return nonzero if there are incomplete multibyte characters at the end of the
                // block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
                //
                simdutf_really_inline simd8<uint8_t> is_incomplete(const simd8<uint8_t> input)
                {
                    // If the previous input's last 3 bytes match this, they're too short (they
                    // ended at EOF):
                    // ... 1111____ 111_____ 11______
                    static const uint8_t max_array[32] = { 255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        0b11110000u - 1,
                        0b11100000u - 1,
                        0b11000000u - 1 };
                    const simd8<uint8_t> max_value(
                        &max_array[sizeof(max_array) - sizeof(simd8<uint8_t>)]);
                    return input.gt_bits(max_value);
                }

                struct utf8_checker
                {
                    // If this is nonzero, there has been a UTF-8 error.
                    simd8<uint8_t> error;
                    // The last input we received
                    simd8<uint8_t> prev_input_block;
                    // Whether the last input we received was incomplete (used for ASCII fast
                    // path)
                    simd8<uint8_t> prev_incomplete;

                    //
                    // Check whether the current bytes are valid UTF-8.
                    //
                    simdutf_really_inline void check_utf8_bytes(const simd8<uint8_t> input,
                        const simd8<uint8_t> prev_input)
                    {
                        // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
                        // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
                        // small negative numbers)
                        simd8<uint8_t> prev1 = input.prev<1>(prev_input);
                        simd8<uint8_t> sc = check_special_cases(input, prev1);
                        this->error |= check_multibyte_lengths(input, prev_input, sc);
                    }

                    // The only problem that can happen at EOF is that a multibyte character is
                    // too short or a byte value too large in the last bytes: check_special_cases
                    // only checks for bytes too large in the first of two bytes.
                    simdutf_really_inline void check_eof()
                    {
                        // If the previous block had incomplete UTF-8 characters at the end, an
                        // ASCII block can't possibly finish them.
                        this->error |= this->prev_incomplete;
                    }

                    simdutf_really_inline void check_next_input(const simd8x64<uint8_t>& input)
                    {
                        if (simdutf_likely(is_ascii(input)))
                        {
                            this->error |= this->prev_incomplete;
                        }
                        else
                        {
                            // you might think that a for-loop would work, but under Visual Studio, it
                            // is not good enough.
                            static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),
                                "We support either two or four chunks per 64-byte block.");
                            if (simd8x64<uint8_t>::NUM_CHUNKS == 2)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                            }
                            else if (simd8x64<uint8_t>::NUM_CHUNKS == 4)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                                this->check_utf8_bytes(input.chunks[2], input.chunks[1]);
                                this->check_utf8_bytes(input.chunks[3], input.chunks[2]);
                            }
                            this->prev_incomplete = is_incomplete(input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1]);
                            this->prev_input_block = input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1];
                        }
                    }

                    // do not forget to call check_eof!
                    simdutf_really_inline bool errors() const
                    {
                        return this->error.any_bits_set_anywhere();
                    }

                }; // struct utf8_checker
            } // namespace utf8_validation

            using utf8_validation::utf8_checker;

        } // unnamed namespace
    } // namespace ppc64
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
/* begin file src/generic/utf8_validation/utf8_validator.h */
namespace simdutf
{
    namespace ppc64
    {
        namespace
        {
            namespace utf8_validation
            {

                /**
                 * Validates that the string is actual UTF-8.
                 */
                template <class checker>
                bool generic_validate_utf8(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        reader.advance();
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    return !c.errors();
                }

                bool generic_validate_utf8(const char* input, size_t length)
                {
                    return generic_validate_utf8<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

                /**
                 * Validates that the string is actual UTF-8 and stops on errors.
                 */
                template <class checker>
                result generic_validate_utf8_with_errors(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    size_t count { 0 };
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        if (c.errors())
                        {
                            if (count != 0)
                            {
                                count--;
                            } // Sometimes the error is only detected in the next chunk
                            result res = scalar::utf8::rewind_and_validate_with_errors(
                                reinterpret_cast<const char*>(input),
                                reinterpret_cast<const char*>(input + count), length - count);
                            res.count += count;
                            return res;
                        }
                        reader.advance();
                        count += 64;
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    if (c.errors())
                    {
                        if (count != 0)
                        {
                            count--;
                        } // Sometimes the error is only detected in the next chunk
                        result res = scalar::utf8::rewind_and_validate_with_errors(
                            reinterpret_cast<const char*>(input),
                            reinterpret_cast<const char*>(input) + count, length - count);
                        res.count += count;
                        return res;
                    }
                    else
                    {
                        return result(error_code::SUCCESS, length);
                    }
                }

                result generic_validate_utf8_with_errors(const char* input, size_t length)
                {
                    return generic_validate_utf8_with_errors<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

            } // namespace utf8_validation
        } // unnamed namespace
    } // namespace ppc64
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_validator.h */

/* begin file src/generic/utf8.h */
namespace simdutf
{
    namespace ppc64
    {
        namespace
        {
            namespace utf8
            {

                using namespace simd;

                simdutf_really_inline size_t count_code_points(const char* in, size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.gt(-65);
                        count += count_ones(utf8_continuation_mask);
                    }
                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }

    #ifdef SIMDUTF_SIMD_HAS_BYTEMASK
                simdutf_really_inline size_t count_code_points_bytemask(const char* in,
                    size_t size)
                {
                    using vector_i8 = simd8<int8_t>;
                    using vector_u8 = simd8<uint8_t>;
                    using vector_u64 = simd64<uint64_t>;

                    constexpr size_t N = vector_i8::SIZE;
                    constexpr size_t max_iterations = 255 / 4;

                    size_t pos = 0;
                    size_t count = 0;

                    auto counters = vector_u64::zero();
                    auto local = vector_u8::zero();
                    size_t iterations = 0;
                    for (; pos + 4 * N <= size; pos += 4 * N)
                    {
                        const auto input0 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 0 * N));
                        const auto input1 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 1 * N));
                        const auto input2 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 2 * N));
                        const auto input3 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 3 * N));
                        const auto mask0 = input0 > int8_t(-65);
                        const auto mask1 = input1 > int8_t(-65);
                        const auto mask2 = input2 > int8_t(-65);
                        const auto mask3 = input3 > int8_t(-65);

                        local -= vector_u8(mask0);
                        local -= vector_u8(mask1);
                        local -= vector_u8(mask2);
                        local -= vector_u8(mask3);

                        iterations += 1;
                        if (iterations == max_iterations)
                        {
                            counters += sum_8bytes(local);
                            local = vector_u8::zero();
                            iterations = 0;
                        }
                    }

                    if (iterations > 0)
                    {
                        count += local.sum_bytes();
                    }

                    count += counters.sum();

                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }
    #endif

                simdutf_really_inline size_t utf16_length_from_utf8(const char* in,
                    size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    // This algorithm could no doubt be improved!
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.lt(-65 + 1);
                        // We count one word for anything that is not a continuation (so
                        // leading bytes).
                        count += 64 - count_ones(utf8_continuation_mask);
                        int64_t utf8_4byte = input.gteq_unsigned(240);
                        count += count_ones(utf8_4byte);
                    }
                    return count + scalar::utf8::utf16_length_from_utf8(in + pos, size - pos);
                }
            } // namespace utf8
        } // unnamed namespace
    } // namespace ppc64
} // namespace simdutf
/* end file src/generic/utf8.h */

/* begin file src/ppc64/templates.cpp */
/*
    Template `convert_impl` implements generic conversion routine between
    different encodings. Procedure returns the number of written elements,
    or zero in the case of error.

    Parameters:
    * VectorizedConvert - vectorized procedure that returns structure having
      three fields: error_code (err), const Source* (input), Destination*
   (output)
    * ScalarConvert - scalar procedure that carries on conversion of tail
    * Source - type of input char (like char16_t, char)
    * Destination - type of input char
*/
template <typename VectorizedConvert, typename ScalarConvert, typename Source,
    typename Destination>
size_t convert_impl(VectorizedConvert vectorized_convert,
    ScalarConvert scalar_convert, const Source* buf, size_t len,
    Destination* output)
{
    const auto vr = vectorized_convert(buf, len, output);
    const size_t consumed = vr.input - buf;
    const size_t written = vr.output - output;
    if (vr.err != simdutf::error_code::SUCCESS)
    {
        if (vr.err == simdutf::error_code::OTHER)
        {
            // Vectorized procedure detected an error, but does not know
            // exact position. The scalar procedure rescan the portion of
            // input and figure out where the error is located.
            return scalar_convert(vr.input, len - consumed, vr.output);
        }
        return 0;
    }

    if (consumed == len)
    {
        return written;
    }

    const auto ret = scalar_convert(vr.input, len - consumed, vr.output);
    if (ret == 0)
    {
        return 0;
    }

    return written + ret;
}

/*
    Template `convert_with_errors_impl` implements generic conversion routine
    between different encodings. Procedure returns a `result` instance ---
    please refer to its documentation for details.

    Parameters:
    * VectorizedConvert - vectorized procedure that returns structure having
      three fields: error_code (err), const Source* (input), Destination*
   (output)
    * ScalarConvert - scalar procedure that carries on conversion of tail
    * Source - type of input char (like char16_t, char)
    * Destination - type of input char
*/
template <typename VectorizedConvert, typename ScalarConvert, typename Source,
    typename Destination>
simdutf::result convert_with_errors_impl(VectorizedConvert vectorized_convert,
    ScalarConvert scalar_convert,
    const Source* buf, size_t len,
    Destination* output)
{

    const auto vr = vectorized_convert(buf, len, output);
    const size_t consumed = vr.input - buf;
    const size_t written = vr.output - output;
    if (vr.err != simdutf::error_code::SUCCESS)
    {
        if (vr.err == simdutf::error_code::OTHER)
        {
            // Vectorized procedure detected an error, but does not know
            // exact position. The scalar procedure rescan the portion of
            // input and figure out where the error is located.
            auto sr = scalar_convert(vr.input, len - consumed, vr.output);
            sr.count += consumed;
            return sr;
        }
        return simdutf::result(vr.err, consumed);
    }

    if (consumed == len)
    {
        return simdutf::result(simdutf::error_code::SUCCESS, written);
    }

    simdutf::result sr = scalar_convert(vr.input, len - consumed, vr.output);
    if (sr.is_ok())
    {
        sr.count += written;
    }
    else
    {
        sr.count += consumed;
    }

    return sr;
}
/* end file src/ppc64/templates.cpp */

    #ifdef SIMDUTF_INTERNAL_TESTS
        #if SIMDUTF_FEATURE_BASE64
            #include "ppc64_base64_internal_tests.cpp"
        #endif // SIMDUTF_FEATURE_BASE64
    #endif // SIMDUTF_INTERNAL_TESTS
//
// Implementation-specific overrides
//
namespace simdutf
{
    namespace ppc64
    {

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* buf, size_t len) const noexcept
        {
            return ppc64::utf8_validation::generic_validate_utf8(buf, len);
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* buf, size_t len) const noexcept
        {
            return ppc64::utf8_validation::generic_validate_utf8_with_errors(buf, len);
        }

        simdutf_warn_unused size_t
        implementation::count_utf8(const char* input, size_t length) const noexcept
        {
            return utf8::count_code_points(input, length);
        }

    #ifdef SIMDUTF_INTERNAL_TESTS
        std::vector<implementation::TestProcedure>
        implementation::internal_tests() const
        {
        #define entry(proc) \
            TestProcedure { #proc, proc }
            return { entry(base64_encoding_translate_6bit_values),
                entry(base64_encoding_expand_6bit_fields),
                entry(base64_decoding_valid),
                entry(base64_decoding_invalid_ignore_errors),
                entry(base64url_decoding_invalid_ignore_errors),
                entry(base64_decoding_invalid_strict_errors),
                entry(base64url_decoding_invalid_strict_errors),
                entry(base64_decoding_pack),
                entry(base64_compress) };
        #undef entry
        }
    #endif

    } // namespace ppc64
} // namespace simdutf

/* begin file src/simdutf/ppc64/end.h */
/* end file src/simdutf/ppc64/end.h */
/* end file src/ppc64/implementation.cpp */
#endif
#if SIMDUTF_IMPLEMENTATION_RVV
/* begin file src/rvv/implementation.cpp */
/* begin file src/simdutf/rvv/begin.h */
// redefining SIMDUTF_IMPLEMENTATION to "rvv"
// #define SIMDUTF_IMPLEMENTATION rvv

    #if SIMDUTF_CAN_ALWAYS_RUN_RVV
    // nothing needed.
    #else
SIMDUTF_TARGET_RVV
    #endif
/* end file src/simdutf/rvv/begin.h */
namespace simdutf
{
    namespace rvv
    {
        namespace
        {
    #ifndef SIMDUTF_RVV_H
        #error "rvv.h must be included"
    #endif

        } // unnamed namespace
    } // namespace rvv
} // namespace simdutf

//
// Implementation-specific overrides
//
namespace simdutf
{
    namespace rvv
    {
        /* begin file src/rvv/rvv_helpers.inl.cpp */
        template <simdutf_ByteFlip bflip>
        simdutf_really_inline static size_t
        rvv_utf32_store_utf16_m4(uint16_t* dst, vuint32m4_t utf32, size_t vl,
            vbool4_t m4even)
        {
            /* convert [000000000000aaaa|aaaaaabbbbbbbbbb]
             * to      [110111bbbbbbbbbb|110110aaaaaaaaaa] */
            vuint32m4_t sur = __riscv_vsub_vx_u32m4(utf32, 0x10000, vl);
            sur = __riscv_vor_vv_u32m4(__riscv_vsll_vx_u32m4(sur, 16, vl),
                __riscv_vsrl_vx_u32m4(sur, 10, vl), vl);
            sur = __riscv_vand_vx_u32m4(sur, 0x3FF03FF, vl);
            sur = __riscv_vor_vx_u32m4(sur, 0xDC00D800, vl);
            /* merge 1 byte utf32 and 2 byte sur */
            vbool8_t m4 = __riscv_vmsgtu_vx_u32m4_b8(utf32, 0xFFFF, vl);
            vuint16m4_t utf32_16 = __riscv_vreinterpret_v_u32m4_u16m4(
                __riscv_vmerge_vvm_u32m4(utf32, sur, m4, vl));
            /* compress and store */
            vbool4_t mOut = __riscv_vmor_mm_b4(
                __riscv_vmsne_vx_u16m4_b4(utf32_16, 0, vl * 2), m4even, vl * 2);
            vuint16m4_t vout = __riscv_vcompress_vm_u16m4(utf32_16, mOut, vl * 2);
            vl = __riscv_vcpop_m_b4(mOut, vl * 2);
            __riscv_vse16_v_u16m4(dst, simdutf_byteflip<bflip>(vout, vl), vl);
            return vl;
        };
        /* end file src/rvv/rvv_helpers.inl.cpp */

        /* begin file src/rvv/rvv_length_from.inl.cpp */
        simdutf_warn_unused size_t
        implementation::count_utf8(const char* src, size_t len) const noexcept
        {
            return utf32_length_from_utf8(src, len);
        }

        simdutf_warn_unused size_t implementation::utf32_length_from_utf8(
            const char* src, size_t len) const noexcept
        {
            size_t count = 0;
            for (size_t vl; len > 0; len -= vl, src += vl)
            {
                vl = __riscv_vsetvl_e8m8(len);
                vint8m8_t v = __riscv_vle8_v_i8m8((int8_t*)src, vl);
                vbool1_t mask = __riscv_vmsgt_vx_i8m8_b1(v, -65, vl);
                count += __riscv_vcpop_m_b1(mask, vl);
            }
            return count;
        }

        /* end file src/rvv/rvv_length_from.inl.cpp */
        /* begin file src/rvv/rvv_validate.inl.cpp */
        /* Returns a close estimation of the number of valid UTF-8 bytes up to the
         * first invalid one, but never overestimating. */
        simdutf_really_inline static size_t rvv_count_valid_utf8(const char* src,
            size_t len)
        {
            const char* beg = src;
            if (len < 32)
                return 0;

            /* validate first three bytes */
            {
                size_t idx = 3;
                while (idx < len && (uint8_t(src[idx]) >> 6) == 0b10)
                    ++idx;
                if (idx > 3 + 3 || !scalar::utf8::validate(src, idx))
                    return 0;
            }

            static const uint64_t err1m[] = { 0x0202020202020202, 0x4915012180808080 };
            static const uint64_t err2m[] = { 0xCBCBCB8B8383A3E7, 0xCBCBDBCBCBCBCBCB };
            static const uint64_t err3m[] = { 0x0101010101010101, 0X01010101BABAAEE6 };

            const vuint8m1_t err1tbl = __riscv_vreinterpret_v_u64m1_u8m1(__riscv_vle64_v_u64m1(err1m, 2));
            const vuint8m1_t err2tbl = __riscv_vreinterpret_v_u64m1_u8m1(__riscv_vle64_v_u64m1(err2m, 2));
            const vuint8m1_t err3tbl = __riscv_vreinterpret_v_u64m1_u8m1(__riscv_vle64_v_u64m1(err3m, 2));

            size_t tail = 3;
            size_t n = len - tail;

            for (size_t vl; n > 0; n -= vl, src += vl)
            {
                vl = __riscv_vsetvl_e8m4(n);
                vuint8m4_t v0 = __riscv_vle8_v_u8m4((uint8_t const*)src, vl);

                uint8_t next0 = src[vl + 0];
                uint8_t next1 = src[vl + 1];
                uint8_t next2 = src[vl + 2];

                /* fast path: ASCII */
                if (__riscv_vfirst_m_b2(__riscv_vmsgtu_vx_u8m4_b2(v0, 0b01111111, vl), vl) < 0 && (next0 | next1 | next2) < 0b10000000)
                    continue;

                /* see "Validating UTF-8 In Less Than One Instruction Per Byte"
                 * https://arxiv.org/abs/2010.03090 */
                vuint8m4_t v1 = __riscv_vslide1down_vx_u8m4(v0, next0, vl);
                vuint8m4_t v2 = __riscv_vslide1down_vx_u8m4(v1, next1, vl);
                vuint8m4_t v3 = __riscv_vslide1down_vx_u8m4(v2, next2, vl);

                vuint8m4_t s1 = __riscv_vreinterpret_v_u16m4_u8m4(__riscv_vsrl_vx_u16m4(
                    __riscv_vreinterpret_v_u8m4_u16m4(v2), 4, __riscv_vsetvlmax_e16m4()));
                vuint8m4_t s3 = __riscv_vreinterpret_v_u16m4_u8m4(__riscv_vsrl_vx_u16m4(
                    __riscv_vreinterpret_v_u8m4_u16m4(v3), 4, __riscv_vsetvlmax_e16m4()));

                vuint8m4_t idx2 = __riscv_vand_vx_u8m4(v2, 0xF, vl);
                vuint8m4_t idx1 = __riscv_vand_vx_u8m4(s1, 0xF, vl);
                vuint8m4_t idx3 = __riscv_vand_vx_u8m4(s3, 0xF, vl);

                vuint8m4_t err1 = simdutf_vrgather_u8m1x4(err1tbl, idx1);
                vuint8m4_t err2 = simdutf_vrgather_u8m1x4(err2tbl, idx2);
                vuint8m4_t err3 = simdutf_vrgather_u8m1x4(err3tbl, idx3);
                vint8m4_t errs = __riscv_vreinterpret_v_u8m4_i8m4(
                    __riscv_vand_vv_u8m4(__riscv_vand_vv_u8m4(err1, err2, vl), err3, vl));

                vbool2_t is_3 = __riscv_vmsgtu_vx_u8m4_b2(v1, 0b11100000 - 1, vl);
                vbool2_t is_4 = __riscv_vmsgtu_vx_u8m4_b2(v0, 0b11110000 - 1, vl);
                vbool2_t is_34 = __riscv_vmor_mm_b2(is_3, is_4, vl);
                vbool2_t err34 = __riscv_vmxor_mm_b2(is_34, __riscv_vmslt_vx_i8m4_b2(errs, 0, vl), vl);
                vbool2_t errm = __riscv_vmor_mm_b2(__riscv_vmsgt_vx_i8m4_b2(errs, 0, vl), err34, vl);
                if (__riscv_vfirst_m_b2(errm, vl) >= 0)
                    break;
            }

            /* we need to validate the last character */
            while (tail < len && (uint8_t(src[0]) >> 6) == 0b10)
                --src, ++tail;
            return src - beg;
        }

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* src, size_t len) const noexcept
        {
            size_t count = rvv_count_valid_utf8(src, len);
            return scalar::utf8::validate(src + count, len - count);
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* src, size_t len) const noexcept
        {
            size_t count = rvv_count_valid_utf8(src, len);
            result res = scalar::utf8::validate_with_errors(src + count, len - count);
            return result(res.error, count + res.count);
        }

        /* end file src/rvv/rvv_validate.inl.cpp */

        /* begin file src/rvv/rvv_latin1_to.inl.cpp */
        /* end file src/rvv/rvv_latin1_to.inl.cpp */
        /* begin file src/rvv/rvv_utf16_to.inl.cpp */
        /* end file src/rvv/rvv_utf16_to.inl.cpp */

        /* begin file src/rvv/rvv_utf32_to.inl.cpp */
        /* end file src/rvv/rvv_utf32_to.inl.cpp */
        /* begin file src/rvv/rvv_utf8_to.inl.cpp */
        /* end file src/rvv/rvv_utf8_to.inl.cpp */

    } // namespace rvv
} // namespace simdutf

    /* begin file src/simdutf/rvv/end.h */
    #if SIMDUTF_CAN_ALWAYS_RUN_RVV
    // nothing needed.
    #else
SIMDUTF_UNTARGET_REGION
    #endif

/* end file src/simdutf/rvv/end.h */
/* end file src/rvv/implementation.cpp */
#endif
#if SIMDUTF_IMPLEMENTATION_WESTMERE
    /* begin file src/westmere/implementation.cpp */
    /* begin file src/simdutf/westmere/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "westmere"
    // #define SIMDUTF_IMPLEMENTATION westmere
    #define SIMDUTF_SIMD_HAS_BYTEMASK 1

    #if SIMDUTF_CAN_ALWAYS_RUN_WESTMERE
    // nothing needed.
    #else
SIMDUTF_TARGET_WESTMERE
    #endif
/* end file src/simdutf/westmere/begin.h */

namespace simdutf
{
    namespace westmere
    {
        namespace
        {
    #ifndef SIMDUTF_WESTMERE_H
        #error "westmere.h must be included"
    #endif
            using namespace simd;

            simdutf_really_inline bool is_ascii(const simd8x64<uint8_t>& input)
            {
                return input.reduce_or().is_ascii();
            }

            simdutf_really_inline simd8<bool>
            must_be_2_3_continuation(const simd8<uint8_t> prev2,
                const simd8<uint8_t> prev3)
            {
                simd8<uint8_t> is_third_byte = prev2.saturating_sub(0xe0u - 0x80); // Only 111_____ will be >= 0x80
                simd8<uint8_t> is_fourth_byte = prev3.saturating_sub(0xf0u - 0x80); // Only 1111____ will be >= 0x80
                return simd8<bool>(is_third_byte | is_fourth_byte);
            }

            /* begin file src/westmere/internal/loader.cpp */
            namespace internal
            {
                namespace westmere
                {

                    /* begin file src/westmere/internal/write_v_u16_11bits_to_utf8.cpp */
                    /*
                     * reads a vector of uint16 values
                     * bits after 11th are ignored
                     * first 11 bits are encoded into utf8
                     * !important! utf8_output must have at least 16 writable bytes
                     */

                    inline void write_v_u16_11bits_to_utf8(const __m128i v_u16, char*& utf8_output,
                        const __m128i one_byte_bytemask,
                        const uint16_t one_byte_bitmask)
                    {
                        // 0b1100_0000_1000_0000
                        const __m128i v_c080 = _mm_set1_epi16((int16_t)0xc080);
                        // 0b0001_1111_0000_0000
                        const __m128i v_1f00 = _mm_set1_epi16((int16_t)0x1f00);
                        // 0b0000_0000_0011_1111
                        const __m128i v_003f = _mm_set1_epi16((int16_t)0x003f);

                        // 1. prepare 2-byte values
                        // input 16-bit word : [0000|0aaa|aabb|bbbb] x 8
                        // expected output   : [110a|aaaa|10bb|bbbb] x 8

                        // t0 = [000a|aaaa|bbbb|bb00]
                        const __m128i t0 = _mm_slli_epi16(v_u16, 2);
                        // t1 = [000a|aaaa|0000|0000]
                        const __m128i t1 = _mm_and_si128(t0, v_1f00);
                        // t2 = [0000|0000|00bb|bbbb]
                        const __m128i t2 = _mm_and_si128(v_u16, v_003f);
                        // t3 = [000a|aaaa|00bb|bbbb]
                        const __m128i t3 = _mm_or_si128(t1, t2);
                        // t4 = [110a|aaaa|10bb|bbbb]
                        const __m128i t4 = _mm_or_si128(t3, v_c080);

                        // 2. merge ASCII and 2-byte codewords
                        const __m128i utf8_unpacked = _mm_blendv_epi8(t4, v_u16, one_byte_bytemask);

                        // 3. prepare bitmask for 8-bit lookup
                        //    one_byte_bitmask = hhggffeeddccbbaa -- the bits are doubled (h - MSB, a
                        //    - LSB)
                        const uint16_t m0 = one_byte_bitmask & 0x5555; // m0 = 0h0g0f0e0d0c0b0a
                        const uint16_t m1 = static_cast<uint16_t>(m0 >> 7); // m1 = 00000000h0g0f0e0
                        const uint8_t m2 = static_cast<uint8_t>((m0 | m1) & 0xff); // m2 = hdgcfbea
                        // 4. pack the bytes
                        const uint8_t* row = &simdutf::tables::utf16_to_utf8::pack_1_2_utf8_bytes[m2][0];
                        const __m128i shuffle = _mm_loadu_si128((__m128i*)(row + 1));
                        const __m128i utf8_packed = _mm_shuffle_epi8(utf8_unpacked, shuffle);

                        // 5. store bytes
                        _mm_storeu_si128((__m128i*)utf8_output, utf8_packed);

                        // 6. adjust pointers
                        utf8_output += row[0];
                    }

                    inline void write_v_u16_11bits_to_utf8(const __m128i v_u16, char*& utf8_output,
                        const __m128i v_0000,
                        const __m128i v_ff80)
                    {
                        // no bits set above 7th bit
                        const __m128i one_byte_bytemask = _mm_cmpeq_epi16(_mm_and_si128(v_u16, v_ff80), v_0000);
                        const uint16_t one_byte_bitmask = static_cast<uint16_t>(_mm_movemask_epi8(one_byte_bytemask));

                        write_v_u16_11bits_to_utf8(v_u16, utf8_output, one_byte_bytemask,
                            one_byte_bitmask);
                    }
                    /* end file src/westmere/internal/write_v_u16_11bits_to_utf8.cpp */

                } // namespace westmere
            } // namespace internal
            /* end file src/westmere/internal/loader.cpp */

        } // unnamed namespace
    } // namespace westmere
} // namespace simdutf

/* begin file src/generic/buf_block_reader.h */
namespace simdutf
{
    namespace westmere
    {
        namespace
        {

            // Walks through a buffer in block-sized increments, loading the last part with
            // spaces
            template <size_t STEP_SIZE>
            struct buf_block_reader
            {
            public:
                simdutf_really_inline buf_block_reader(const uint8_t* _buf, size_t _len);
                simdutf_really_inline size_t block_index();
                simdutf_really_inline bool has_full_block() const;
                simdutf_really_inline const uint8_t* full_block() const;
                /**
                 * Get the last block, padded with spaces.
                 *
                 * There will always be a last block, with at least 1 byte, unless len == 0
                 * (in which case this function fills the buffer with spaces and returns 0. In
                 * particular, if len == STEP_SIZE there will be 0 full_blocks and 1 remainder
                 * block with STEP_SIZE bytes and no spaces for padding.
                 *
                 * @return the number of effective characters in the last block.
                 */
                simdutf_really_inline size_t get_remainder(uint8_t* dst) const;
                simdutf_really_inline void advance();

            private:
                const uint8_t* buf;
                const size_t len;
                const size_t lenminusstep;
                size_t idx;
            };

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text_64(const uint8_t* text)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    buf[i] = int8_t(text[i]) < ' ' ? '_' : int8_t(text[i]);
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text(const simd8x64<uint8_t>& in)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                in.store(reinterpret_cast<uint8_t*>(buf));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    if (buf[i] < ' ')
                    {
                        buf[i] = '_';
                    }
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            simdutf_unused static char* format_mask(uint64_t mask)
            {
                static char* buf = reinterpret_cast<char*>(malloc(64 + 1));
                for (size_t i = 0; i < 64; i++)
                {
                    buf[i] = (mask & (size_t(1) << i)) ? 'X' : ' ';
                }
                buf[64] = '\0';
                return buf;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline
            buf_block_reader<STEP_SIZE>::buf_block_reader(const uint8_t* _buf, size_t _len)
                : buf { _buf }
                , len { _len }
                , lenminusstep { len < STEP_SIZE ? 0 : len - STEP_SIZE }
                , idx { 0 }
            {
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t buf_block_reader<STEP_SIZE>::block_index()
            {
                return idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline bool buf_block_reader<STEP_SIZE>::has_full_block() const
            {
                return idx < lenminusstep;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline const uint8_t*
            buf_block_reader<STEP_SIZE>::full_block() const
            {
                return &buf[idx];
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t
            buf_block_reader<STEP_SIZE>::get_remainder(uint8_t* dst) const
            {
                if (len == idx)
                {
                    return 0;
                } // memcpy(dst, null, 0) will trigger an error with some sanitizers
                std::memset(dst, 0x20,
                    STEP_SIZE); // std::memset STEP_SIZE because it is more efficient
                                // to write out 8 or 16 bytes at once.
                std::memcpy(dst, buf + idx, len - idx);
                return len - idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance()
            {
                idx += STEP_SIZE;
            }

        } // unnamed namespace
    } // namespace westmere
} // namespace simdutf
/* end file src/generic/buf_block_reader.h */
/* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
namespace simdutf
{
    namespace westmere
    {
        namespace
        {
            namespace utf8_validation
            {

                using namespace simd;

                simdutf_really_inline simd8<uint8_t>
                check_special_cases(const simd8<uint8_t> input, const simd8<uint8_t> prev1)
                {
                    // Bit 0 = Too Short (lead byte/ASCII followed by lead byte/ASCII)
                    // Bit 1 = Too Long (ASCII followed by continuation)
                    // Bit 2 = Overlong 3-byte
                    // Bit 4 = Surrogate
                    // Bit 5 = Overlong 2-byte
                    // Bit 7 = Two Continuations
                    constexpr const uint8_t TOO_SHORT = 1 << 0; // 11______ 0_______
                                                                // 11______ 11______
                    constexpr const uint8_t TOO_LONG = 1 << 1; // 0_______ 10______
                    constexpr const uint8_t OVERLONG_3 = 1 << 2; // 11100000 100_____
                    constexpr const uint8_t SURROGATE = 1 << 4; // 11101101 101_____
                    constexpr const uint8_t OVERLONG_2 = 1 << 5; // 1100000_ 10______
                    constexpr const uint8_t TWO_CONTS = 1 << 7; // 10______ 10______
                    constexpr const uint8_t TOO_LARGE = 1 << 3; // 11110100 1001____
                                                                // 11110100 101_____
                                                                // 11110101 1001____
                                                                // 11110101 101_____
                                                                // 1111011_ 1001____
                                                                // 1111011_ 101_____
                                                                // 11111___ 1001____
                                                                // 11111___ 101_____
                    constexpr const uint8_t TOO_LARGE_1000 = 1 << 6;
                    // 11110101 1000____
                    // 1111011_ 1000____
                    // 11111___ 1000____
                    constexpr const uint8_t OVERLONG_4 = 1 << 6; // 11110000 1000____

                    const simd8<uint8_t> byte_1_high = prev1.shr<4>().lookup_16<uint8_t>(
                        // 0_______ ________ <ASCII in byte 1>
                        TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG,
                        TOO_LONG,
                        // 10______ ________ <continuation in byte 1>
                        TWO_CONTS, TWO_CONTS, TWO_CONTS, TWO_CONTS,
                        // 1100____ ________ <two byte lead in byte 1>
                        TOO_SHORT | OVERLONG_2,
                        // 1101____ ________ <two byte lead in byte 1>
                        TOO_SHORT,
                        // 1110____ ________ <three byte lead in byte 1>
                        TOO_SHORT | OVERLONG_3 | SURROGATE,
                        // 1111____ ________ <four+ byte lead in byte 1>
                        TOO_SHORT | TOO_LARGE | TOO_LARGE_1000 | OVERLONG_4);
                    constexpr const uint8_t CARRY = TOO_SHORT | TOO_LONG | TWO_CONTS; // These all have ____ in byte 1 .
                    const simd8<uint8_t> byte_1_low = (prev1 & 0x0F)
                                                          .lookup_16<uint8_t>(
                                                              // ____0000 ________
                                                              CARRY | OVERLONG_3 | OVERLONG_2 | OVERLONG_4,
                                                              // ____0001 ________
                                                              CARRY | OVERLONG_2,
                                                              // ____001_ ________
                                                              CARRY, CARRY,

                                                              // ____0100 ________
                                                              CARRY | TOO_LARGE,
                                                              // ____0101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____011_ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,

                                                              // ____1___ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____1101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000 | SURROGATE,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000);
                    const simd8<uint8_t> byte_2_high = input.shr<4>().lookup_16<uint8_t>(
                        // ________ 0_______ <ASCII in byte 2>
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT,
                        TOO_SHORT, TOO_SHORT,

                        // ________ 1000____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE_1000 | OVERLONG_4,
                        // ________ 1001____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE,
                        // ________ 101_____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,

                        // ________ 11______
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT);
                    return (byte_1_high & byte_1_low & byte_2_high);
                }
                simdutf_really_inline simd8<uint8_t>
                check_multibyte_lengths(const simd8<uint8_t> input,
                    const simd8<uint8_t> prev_input,
                    const simd8<uint8_t> sc)
                {
                    simd8<uint8_t> prev2 = input.prev<2>(prev_input);
                    simd8<uint8_t> prev3 = input.prev<3>(prev_input);
                    simd8<uint8_t> must23 = simd8<uint8_t>(must_be_2_3_continuation(prev2, prev3));
                    simd8<uint8_t> must23_80 = must23 & uint8_t(0x80);
                    return must23_80 ^ sc;
                }

                //
                // Return nonzero if there are incomplete multibyte characters at the end of the
                // block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
                //
                simdutf_really_inline simd8<uint8_t> is_incomplete(const simd8<uint8_t> input)
                {
                    // If the previous input's last 3 bytes match this, they're too short (they
                    // ended at EOF):
                    // ... 1111____ 111_____ 11______
                    static const uint8_t max_array[32] = { 255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        0b11110000u - 1,
                        0b11100000u - 1,
                        0b11000000u - 1 };
                    const simd8<uint8_t> max_value(
                        &max_array[sizeof(max_array) - sizeof(simd8<uint8_t>)]);
                    return input.gt_bits(max_value);
                }

                struct utf8_checker
                {
                    // If this is nonzero, there has been a UTF-8 error.
                    simd8<uint8_t> error;
                    // The last input we received
                    simd8<uint8_t> prev_input_block;
                    // Whether the last input we received was incomplete (used for ASCII fast
                    // path)
                    simd8<uint8_t> prev_incomplete;

                    //
                    // Check whether the current bytes are valid UTF-8.
                    //
                    simdutf_really_inline void check_utf8_bytes(const simd8<uint8_t> input,
                        const simd8<uint8_t> prev_input)
                    {
                        // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
                        // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
                        // small negative numbers)
                        simd8<uint8_t> prev1 = input.prev<1>(prev_input);
                        simd8<uint8_t> sc = check_special_cases(input, prev1);
                        this->error |= check_multibyte_lengths(input, prev_input, sc);
                    }

                    // The only problem that can happen at EOF is that a multibyte character is
                    // too short or a byte value too large in the last bytes: check_special_cases
                    // only checks for bytes too large in the first of two bytes.
                    simdutf_really_inline void check_eof()
                    {
                        // If the previous block had incomplete UTF-8 characters at the end, an
                        // ASCII block can't possibly finish them.
                        this->error |= this->prev_incomplete;
                    }

                    simdutf_really_inline void check_next_input(const simd8x64<uint8_t>& input)
                    {
                        if (simdutf_likely(is_ascii(input)))
                        {
                            this->error |= this->prev_incomplete;
                        }
                        else
                        {
                            // you might think that a for-loop would work, but under Visual Studio, it
                            // is not good enough.
                            static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),
                                "We support either two or four chunks per 64-byte block.");
                            if (simd8x64<uint8_t>::NUM_CHUNKS == 2)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                            }
                            else if (simd8x64<uint8_t>::NUM_CHUNKS == 4)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                                this->check_utf8_bytes(input.chunks[2], input.chunks[1]);
                                this->check_utf8_bytes(input.chunks[3], input.chunks[2]);
                            }
                            this->prev_incomplete = is_incomplete(input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1]);
                            this->prev_input_block = input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1];
                        }
                    }

                    // do not forget to call check_eof!
                    simdutf_really_inline bool errors() const
                    {
                        return this->error.any_bits_set_anywhere();
                    }

                }; // struct utf8_checker
            } // namespace utf8_validation

            using utf8_validation::utf8_checker;

        } // unnamed namespace
    } // namespace westmere
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
/* begin file src/generic/utf8_validation/utf8_validator.h */
namespace simdutf
{
    namespace westmere
    {
        namespace
        {
            namespace utf8_validation
            {

                /**
                 * Validates that the string is actual UTF-8.
                 */
                template <class checker>
                bool generic_validate_utf8(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        reader.advance();
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    return !c.errors();
                }

                bool generic_validate_utf8(const char* input, size_t length)
                {
                    return generic_validate_utf8<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

                /**
                 * Validates that the string is actual UTF-8 and stops on errors.
                 */
                template <class checker>
                result generic_validate_utf8_with_errors(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    size_t count { 0 };
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        if (c.errors())
                        {
                            if (count != 0)
                            {
                                count--;
                            } // Sometimes the error is only detected in the next chunk
                            result res = scalar::utf8::rewind_and_validate_with_errors(
                                reinterpret_cast<const char*>(input),
                                reinterpret_cast<const char*>(input + count), length - count);
                            res.count += count;
                            return res;
                        }
                        reader.advance();
                        count += 64;
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    if (c.errors())
                    {
                        if (count != 0)
                        {
                            count--;
                        } // Sometimes the error is only detected in the next chunk
                        result res = scalar::utf8::rewind_and_validate_with_errors(
                            reinterpret_cast<const char*>(input),
                            reinterpret_cast<const char*>(input) + count, length - count);
                        res.count += count;
                        return res;
                    }
                    else
                    {
                        return result(error_code::SUCCESS, length);
                    }
                }

                result generic_validate_utf8_with_errors(const char* input, size_t length)
                {
                    return generic_validate_utf8_with_errors<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

            } // namespace utf8_validation
        } // unnamed namespace
    } // namespace westmere
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_validator.h */

/* begin file src/generic/utf8.h */
namespace simdutf
{
    namespace westmere
    {
        namespace
        {
            namespace utf8
            {

                using namespace simd;

                simdutf_really_inline size_t count_code_points(const char* in, size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.gt(-65);
                        count += count_ones(utf8_continuation_mask);
                    }
                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }

    #ifdef SIMDUTF_SIMD_HAS_BYTEMASK
                simdutf_really_inline size_t count_code_points_bytemask(const char* in,
                    size_t size)
                {
                    using vector_i8 = simd8<int8_t>;
                    using vector_u8 = simd8<uint8_t>;
                    using vector_u64 = simd64<uint64_t>;

                    constexpr size_t N = vector_i8::SIZE;
                    constexpr size_t max_iterations = 255 / 4;

                    size_t pos = 0;
                    size_t count = 0;

                    auto counters = vector_u64::zero();
                    auto local = vector_u8::zero();
                    size_t iterations = 0;
                    for (; pos + 4 * N <= size; pos += 4 * N)
                    {
                        const auto input0 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 0 * N));
                        const auto input1 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 1 * N));
                        const auto input2 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 2 * N));
                        const auto input3 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 3 * N));
                        const auto mask0 = input0 > int8_t(-65);
                        const auto mask1 = input1 > int8_t(-65);
                        const auto mask2 = input2 > int8_t(-65);
                        const auto mask3 = input3 > int8_t(-65);

                        local -= vector_u8(mask0);
                        local -= vector_u8(mask1);
                        local -= vector_u8(mask2);
                        local -= vector_u8(mask3);

                        iterations += 1;
                        if (iterations == max_iterations)
                        {
                            counters += sum_8bytes(local);
                            local = vector_u8::zero();
                            iterations = 0;
                        }
                    }

                    if (iterations > 0)
                    {
                        count += local.sum_bytes();
                    }

                    count += counters.sum();

                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }
    #endif

                simdutf_really_inline size_t utf16_length_from_utf8(const char* in,
                    size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    // This algorithm could no doubt be improved!
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.lt(-65 + 1);
                        // We count one word for anything that is not a continuation (so
                        // leading bytes).
                        count += 64 - count_ones(utf8_continuation_mask);
                        int64_t utf8_4byte = input.gteq_unsigned(240);
                        count += count_ones(utf8_4byte);
                    }
                    return count + scalar::utf8::utf16_length_from_utf8(in + pos, size - pos);
                }
            } // namespace utf8
        } // unnamed namespace
    } // namespace westmere
} // namespace simdutf
/* end file src/generic/utf8.h */

//
// Implementation-specific overrides
//

namespace simdutf
{
    namespace westmere
    {

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* buf, size_t len) const noexcept
        {
            return westmere::utf8_validation::generic_validate_utf8(buf, len);
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* buf, size_t len) const noexcept
        {
            return westmere::utf8_validation::generic_validate_utf8_with_errors(buf, len);
        }

        simdutf_warn_unused size_t
        implementation::count_utf8(const char* input, size_t length) const noexcept
        {
            return utf8::count_code_points_bytemask(input, length);
        }

    } // namespace westmere
} // namespace simdutf

    /* begin file src/simdutf/westmere/end.h */
    #if SIMDUTF_CAN_ALWAYS_RUN_WESTMERE
    // nothing needed.
    #else
SIMDUTF_UNTARGET_REGION
    #endif

    #undef SIMDUTF_SIMD_HAS_BYTEMASK
/* end file src/simdutf/westmere/end.h */
/* end file src/westmere/implementation.cpp */
#endif
#if SIMDUTF_IMPLEMENTATION_LSX
    /* begin file src/lsx/implementation.cpp */
    /* begin file src/simdutf/lsx/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "lsx"
    // #define SIMDUTF_IMPLEMENTATION lsx
    #define SIMDUTF_SIMD_HAS_UNSIGNED_CMP 1
/* end file src/simdutf/lsx/begin.h */
namespace simdutf
{
    namespace lsx
    {
        namespace
        {
    #ifndef SIMDUTF_LSX_H
        #error "lsx.h must be included"
    #endif
            using namespace simd;

            // convert vmskltz/vmskgez/vmsknz to
            // simdutf::tables::utf16_to_utf8::pack_1_2_utf8_bytes index
            const uint8_t lsx_1_2_utf8_bytes_mask[] = {
                0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84,
                85, 2, 3, 6, 7, 18, 19, 22, 23, 66, 67, 70, 71, 82, 83,
                86, 87, 8, 9, 12, 13, 24, 25, 28, 29, 72, 73, 76, 77, 88,
                89, 92, 93, 10, 11, 14, 15, 26, 27, 30, 31, 74, 75, 78, 79,
                90, 91, 94, 95, 32, 33, 36, 37, 48, 49, 52, 53, 96, 97, 100,
                101, 112, 113, 116, 117, 34, 35, 38, 39, 50, 51, 54, 55, 98, 99,
                102, 103, 114, 115, 118, 119, 40, 41, 44, 45, 56, 57, 60, 61, 104,
                105, 108, 109, 120, 121, 124, 125, 42, 43, 46, 47, 58, 59, 62, 63,
                106, 107, 110, 111, 122, 123, 126, 127, 128, 129, 132, 133, 144, 145, 148,
                149, 192, 193, 196, 197, 208, 209, 212, 213, 130, 131, 134, 135, 146, 147,
                150, 151, 194, 195, 198, 199, 210, 211, 214, 215, 136, 137, 140, 141, 152,
                153, 156, 157, 200, 201, 204, 205, 216, 217, 220, 221, 138, 139, 142, 143,
                154, 155, 158, 159, 202, 203, 206, 207, 218, 219, 222, 223, 160, 161, 164,
                165, 176, 177, 180, 181, 224, 225, 228, 229, 240, 241, 244, 245, 162, 163,
                166, 167, 178, 179, 182, 183, 226, 227, 230, 231, 242, 243, 246, 247, 168,
                169, 172, 173, 184, 185, 188, 189, 232, 233, 236, 237, 248, 249, 252, 253,
                170, 171, 174, 175, 186, 187, 190, 191, 234, 235, 238, 239, 250, 251, 254,
                255
            };

            simdutf_really_inline bool is_ascii(const simd8x64<uint8_t>& input)
            {
                return input.is_ascii();
            }

            simdutf_really_inline simd8<bool>
            must_be_2_3_continuation(const simd8<uint8_t> prev2,
                const simd8<uint8_t> prev3)
            {
                simd8<bool> is_third_byte = prev2 >= uint8_t(0b11100000u);
                simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
                return is_third_byte ^ is_fourth_byte;
            }

        } // namespace
    } // namespace lsx
} // namespace simdutf

/* begin file src/generic/buf_block_reader.h */
namespace simdutf
{
    namespace lsx
    {
        namespace
        {

            // Walks through a buffer in block-sized increments, loading the last part with
            // spaces
            template <size_t STEP_SIZE>
            struct buf_block_reader
            {
            public:
                simdutf_really_inline buf_block_reader(const uint8_t* _buf, size_t _len);
                simdutf_really_inline size_t block_index();
                simdutf_really_inline bool has_full_block() const;
                simdutf_really_inline const uint8_t* full_block() const;
                /**
                 * Get the last block, padded with spaces.
                 *
                 * There will always be a last block, with at least 1 byte, unless len == 0
                 * (in which case this function fills the buffer with spaces and returns 0. In
                 * particular, if len == STEP_SIZE there will be 0 full_blocks and 1 remainder
                 * block with STEP_SIZE bytes and no spaces for padding.
                 *
                 * @return the number of effective characters in the last block.
                 */
                simdutf_really_inline size_t get_remainder(uint8_t* dst) const;
                simdutf_really_inline void advance();

            private:
                const uint8_t* buf;
                const size_t len;
                const size_t lenminusstep;
                size_t idx;
            };

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text_64(const uint8_t* text)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    buf[i] = int8_t(text[i]) < ' ' ? '_' : int8_t(text[i]);
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text(const simd8x64<uint8_t>& in)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                in.store(reinterpret_cast<uint8_t*>(buf));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    if (buf[i] < ' ')
                    {
                        buf[i] = '_';
                    }
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            simdutf_unused static char* format_mask(uint64_t mask)
            {
                static char* buf = reinterpret_cast<char*>(malloc(64 + 1));
                for (size_t i = 0; i < 64; i++)
                {
                    buf[i] = (mask & (size_t(1) << i)) ? 'X' : ' ';
                }
                buf[64] = '\0';
                return buf;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline
            buf_block_reader<STEP_SIZE>::buf_block_reader(const uint8_t* _buf, size_t _len)
                : buf { _buf }
                , len { _len }
                , lenminusstep { len < STEP_SIZE ? 0 : len - STEP_SIZE }
                , idx { 0 }
            {
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t buf_block_reader<STEP_SIZE>::block_index()
            {
                return idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline bool buf_block_reader<STEP_SIZE>::has_full_block() const
            {
                return idx < lenminusstep;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline const uint8_t*
            buf_block_reader<STEP_SIZE>::full_block() const
            {
                return &buf[idx];
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t
            buf_block_reader<STEP_SIZE>::get_remainder(uint8_t* dst) const
            {
                if (len == idx)
                {
                    return 0;
                } // memcpy(dst, null, 0) will trigger an error with some sanitizers
                std::memset(dst, 0x20,
                    STEP_SIZE); // std::memset STEP_SIZE because it is more efficient
                                // to write out 8 or 16 bytes at once.
                std::memcpy(dst, buf + idx, len - idx);
                return len - idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance()
            {
                idx += STEP_SIZE;
            }

        } // unnamed namespace
    } // namespace lsx
} // namespace simdutf
/* end file src/generic/buf_block_reader.h */
/* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
namespace simdutf
{
    namespace lsx
    {
        namespace
        {
            namespace utf8_validation
            {

                using namespace simd;

                simdutf_really_inline simd8<uint8_t>
                check_special_cases(const simd8<uint8_t> input, const simd8<uint8_t> prev1)
                {
                    // Bit 0 = Too Short (lead byte/ASCII followed by lead byte/ASCII)
                    // Bit 1 = Too Long (ASCII followed by continuation)
                    // Bit 2 = Overlong 3-byte
                    // Bit 4 = Surrogate
                    // Bit 5 = Overlong 2-byte
                    // Bit 7 = Two Continuations
                    constexpr const uint8_t TOO_SHORT = 1 << 0; // 11______ 0_______
                                                                // 11______ 11______
                    constexpr const uint8_t TOO_LONG = 1 << 1; // 0_______ 10______
                    constexpr const uint8_t OVERLONG_3 = 1 << 2; // 11100000 100_____
                    constexpr const uint8_t SURROGATE = 1 << 4; // 11101101 101_____
                    constexpr const uint8_t OVERLONG_2 = 1 << 5; // 1100000_ 10______
                    constexpr const uint8_t TWO_CONTS = 1 << 7; // 10______ 10______
                    constexpr const uint8_t TOO_LARGE = 1 << 3; // 11110100 1001____
                                                                // 11110100 101_____
                                                                // 11110101 1001____
                                                                // 11110101 101_____
                                                                // 1111011_ 1001____
                                                                // 1111011_ 101_____
                                                                // 11111___ 1001____
                                                                // 11111___ 101_____
                    constexpr const uint8_t TOO_LARGE_1000 = 1 << 6;
                    // 11110101 1000____
                    // 1111011_ 1000____
                    // 11111___ 1000____
                    constexpr const uint8_t OVERLONG_4 = 1 << 6; // 11110000 1000____

                    const simd8<uint8_t> byte_1_high = prev1.shr<4>().lookup_16<uint8_t>(
                        // 0_______ ________ <ASCII in byte 1>
                        TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG,
                        TOO_LONG,
                        // 10______ ________ <continuation in byte 1>
                        TWO_CONTS, TWO_CONTS, TWO_CONTS, TWO_CONTS,
                        // 1100____ ________ <two byte lead in byte 1>
                        TOO_SHORT | OVERLONG_2,
                        // 1101____ ________ <two byte lead in byte 1>
                        TOO_SHORT,
                        // 1110____ ________ <three byte lead in byte 1>
                        TOO_SHORT | OVERLONG_3 | SURROGATE,
                        // 1111____ ________ <four+ byte lead in byte 1>
                        TOO_SHORT | TOO_LARGE | TOO_LARGE_1000 | OVERLONG_4);
                    constexpr const uint8_t CARRY = TOO_SHORT | TOO_LONG | TWO_CONTS; // These all have ____ in byte 1 .
                    const simd8<uint8_t> byte_1_low = (prev1 & 0x0F)
                                                          .lookup_16<uint8_t>(
                                                              // ____0000 ________
                                                              CARRY | OVERLONG_3 | OVERLONG_2 | OVERLONG_4,
                                                              // ____0001 ________
                                                              CARRY | OVERLONG_2,
                                                              // ____001_ ________
                                                              CARRY, CARRY,

                                                              // ____0100 ________
                                                              CARRY | TOO_LARGE,
                                                              // ____0101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____011_ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,

                                                              // ____1___ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____1101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000 | SURROGATE,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000);
                    const simd8<uint8_t> byte_2_high = input.shr<4>().lookup_16<uint8_t>(
                        // ________ 0_______ <ASCII in byte 2>
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT,
                        TOO_SHORT, TOO_SHORT,

                        // ________ 1000____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE_1000 | OVERLONG_4,
                        // ________ 1001____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE,
                        // ________ 101_____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,

                        // ________ 11______
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT);
                    return (byte_1_high & byte_1_low & byte_2_high);
                }
                simdutf_really_inline simd8<uint8_t>
                check_multibyte_lengths(const simd8<uint8_t> input,
                    const simd8<uint8_t> prev_input,
                    const simd8<uint8_t> sc)
                {
                    simd8<uint8_t> prev2 = input.prev<2>(prev_input);
                    simd8<uint8_t> prev3 = input.prev<3>(prev_input);
                    simd8<uint8_t> must23 = simd8<uint8_t>(must_be_2_3_continuation(prev2, prev3));
                    simd8<uint8_t> must23_80 = must23 & uint8_t(0x80);
                    return must23_80 ^ sc;
                }

                //
                // Return nonzero if there are incomplete multibyte characters at the end of the
                // block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
                //
                simdutf_really_inline simd8<uint8_t> is_incomplete(const simd8<uint8_t> input)
                {
                    // If the previous input's last 3 bytes match this, they're too short (they
                    // ended at EOF):
                    // ... 1111____ 111_____ 11______
                    static const uint8_t max_array[32] = { 255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        0b11110000u - 1,
                        0b11100000u - 1,
                        0b11000000u - 1 };
                    const simd8<uint8_t> max_value(
                        &max_array[sizeof(max_array) - sizeof(simd8<uint8_t>)]);
                    return input.gt_bits(max_value);
                }

                struct utf8_checker
                {
                    // If this is nonzero, there has been a UTF-8 error.
                    simd8<uint8_t> error;
                    // The last input we received
                    simd8<uint8_t> prev_input_block;
                    // Whether the last input we received was incomplete (used for ASCII fast
                    // path)
                    simd8<uint8_t> prev_incomplete;

                    //
                    // Check whether the current bytes are valid UTF-8.
                    //
                    simdutf_really_inline void check_utf8_bytes(const simd8<uint8_t> input,
                        const simd8<uint8_t> prev_input)
                    {
                        // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
                        // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
                        // small negative numbers)
                        simd8<uint8_t> prev1 = input.prev<1>(prev_input);
                        simd8<uint8_t> sc = check_special_cases(input, prev1);
                        this->error |= check_multibyte_lengths(input, prev_input, sc);
                    }

                    // The only problem that can happen at EOF is that a multibyte character is
                    // too short or a byte value too large in the last bytes: check_special_cases
                    // only checks for bytes too large in the first of two bytes.
                    simdutf_really_inline void check_eof()
                    {
                        // If the previous block had incomplete UTF-8 characters at the end, an
                        // ASCII block can't possibly finish them.
                        this->error |= this->prev_incomplete;
                    }

                    simdutf_really_inline void check_next_input(const simd8x64<uint8_t>& input)
                    {
                        if (simdutf_likely(is_ascii(input)))
                        {
                            this->error |= this->prev_incomplete;
                        }
                        else
                        {
                            // you might think that a for-loop would work, but under Visual Studio, it
                            // is not good enough.
                            static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),
                                "We support either two or four chunks per 64-byte block.");
                            if (simd8x64<uint8_t>::NUM_CHUNKS == 2)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                            }
                            else if (simd8x64<uint8_t>::NUM_CHUNKS == 4)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                                this->check_utf8_bytes(input.chunks[2], input.chunks[1]);
                                this->check_utf8_bytes(input.chunks[3], input.chunks[2]);
                            }
                            this->prev_incomplete = is_incomplete(input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1]);
                            this->prev_input_block = input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1];
                        }
                    }

                    // do not forget to call check_eof!
                    simdutf_really_inline bool errors() const
                    {
                        return this->error.any_bits_set_anywhere();
                    }

                }; // struct utf8_checker
            } // namespace utf8_validation

            using utf8_validation::utf8_checker;

        } // unnamed namespace
    } // namespace lsx
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
/* begin file src/generic/utf8_validation/utf8_validator.h */
namespace simdutf
{
    namespace lsx
    {
        namespace
        {
            namespace utf8_validation
            {

                /**
                 * Validates that the string is actual UTF-8.
                 */
                template <class checker>
                bool generic_validate_utf8(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        reader.advance();
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    return !c.errors();
                }

                bool generic_validate_utf8(const char* input, size_t length)
                {
                    return generic_validate_utf8<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

                /**
                 * Validates that the string is actual UTF-8 and stops on errors.
                 */
                template <class checker>
                result generic_validate_utf8_with_errors(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    size_t count { 0 };
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        if (c.errors())
                        {
                            if (count != 0)
                            {
                                count--;
                            } // Sometimes the error is only detected in the next chunk
                            result res = scalar::utf8::rewind_and_validate_with_errors(
                                reinterpret_cast<const char*>(input),
                                reinterpret_cast<const char*>(input + count), length - count);
                            res.count += count;
                            return res;
                        }
                        reader.advance();
                        count += 64;
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    if (c.errors())
                    {
                        if (count != 0)
                        {
                            count--;
                        } // Sometimes the error is only detected in the next chunk
                        result res = scalar::utf8::rewind_and_validate_with_errors(
                            reinterpret_cast<const char*>(input),
                            reinterpret_cast<const char*>(input) + count, length - count);
                        res.count += count;
                        return res;
                    }
                    else
                    {
                        return result(error_code::SUCCESS, length);
                    }
                }

                result generic_validate_utf8_with_errors(const char* input, size_t length)
                {
                    return generic_validate_utf8_with_errors<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

            } // namespace utf8_validation
        } // unnamed namespace
    } // namespace lsx
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_validator.h */

/* begin file src/generic/utf8.h */
namespace simdutf
{
    namespace lsx
    {
        namespace
        {
            namespace utf8
            {

                using namespace simd;

                simdutf_really_inline size_t count_code_points(const char* in, size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.gt(-65);
                        count += count_ones(utf8_continuation_mask);
                    }
                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }

    #ifdef SIMDUTF_SIMD_HAS_BYTEMASK
                simdutf_really_inline size_t count_code_points_bytemask(const char* in,
                    size_t size)
                {
                    using vector_i8 = simd8<int8_t>;
                    using vector_u8 = simd8<uint8_t>;
                    using vector_u64 = simd64<uint64_t>;

                    constexpr size_t N = vector_i8::SIZE;
                    constexpr size_t max_iterations = 255 / 4;

                    size_t pos = 0;
                    size_t count = 0;

                    auto counters = vector_u64::zero();
                    auto local = vector_u8::zero();
                    size_t iterations = 0;
                    for (; pos + 4 * N <= size; pos += 4 * N)
                    {
                        const auto input0 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 0 * N));
                        const auto input1 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 1 * N));
                        const auto input2 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 2 * N));
                        const auto input3 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 3 * N));
                        const auto mask0 = input0 > int8_t(-65);
                        const auto mask1 = input1 > int8_t(-65);
                        const auto mask2 = input2 > int8_t(-65);
                        const auto mask3 = input3 > int8_t(-65);

                        local -= vector_u8(mask0);
                        local -= vector_u8(mask1);
                        local -= vector_u8(mask2);
                        local -= vector_u8(mask3);

                        iterations += 1;
                        if (iterations == max_iterations)
                        {
                            counters += sum_8bytes(local);
                            local = vector_u8::zero();
                            iterations = 0;
                        }
                    }

                    if (iterations > 0)
                    {
                        count += local.sum_bytes();
                    }

                    count += counters.sum();

                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }
    #endif

                simdutf_really_inline size_t utf16_length_from_utf8(const char* in,
                    size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    // This algorithm could no doubt be improved!
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.lt(-65 + 1);
                        // We count one word for anything that is not a continuation (so
                        // leading bytes).
                        count += 64 - count_ones(utf8_continuation_mask);
                        int64_t utf8_4byte = input.gteq_unsigned(240);
                        count += count_ones(utf8_4byte);
                    }
                    return count + scalar::utf8::utf16_length_from_utf8(in + pos, size - pos);
                }
            } // namespace utf8
        } // unnamed namespace
    } // namespace lsx
} // namespace simdutf
/* end file src/generic/utf8.h */

//
// Implementation-specific overrides
//
namespace simdutf
{
    namespace lsx
    {

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* buf, size_t len) const noexcept
        {
            return lsx::utf8_validation::generic_validate_utf8(buf, len);
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* buf, size_t len) const noexcept
        {
            return lsx::utf8_validation::generic_validate_utf8_with_errors(buf, len);
        }

        simdutf_warn_unused size_t
        implementation::count_utf8(const char* input, size_t length) const noexcept
        {
            return utf8::count_code_points(input, length);
        }

    } // namespace lsx
} // namespace simdutf

    /* begin file src/simdutf/lsx/end.h */
    #undef SIMDUTF_SIMD_HAS_UNSIGNED_CMP
/* end file src/simdutf/lsx/end.h */
/* end file src/lsx/implementation.cpp */
#endif
#if SIMDUTF_IMPLEMENTATION_LASX
    /* begin file src/lasx/implementation.cpp */
    /* begin file src/simdutf/lasx/begin.h */
    // redefining SIMDUTF_IMPLEMENTATION to "lasx"
    // #define SIMDUTF_IMPLEMENTATION lasx
    #define SIMDUTF_SIMD_HAS_UNSIGNED_CMP 1
/* end file src/simdutf/lasx/begin.h */
namespace simdutf
{
    namespace lasx
    {
        namespace
        {
    #ifndef SIMDUTF_LASX_H
        #error "lasx.h must be included"
    #endif
            using namespace simd;

            // convert vmskltz/vmskgez/vmsknz to
            // simdutf::tables::utf16_to_utf8::pack_1_2_utf8_bytes index
            const uint8_t lasx_1_2_utf8_bytes_mask[] = {
                0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84,
                85, 2, 3, 6, 7, 18, 19, 22, 23, 66, 67, 70, 71, 82, 83,
                86, 87, 8, 9, 12, 13, 24, 25, 28, 29, 72, 73, 76, 77, 88,
                89, 92, 93, 10, 11, 14, 15, 26, 27, 30, 31, 74, 75, 78, 79,
                90, 91, 94, 95, 32, 33, 36, 37, 48, 49, 52, 53, 96, 97, 100,
                101, 112, 113, 116, 117, 34, 35, 38, 39, 50, 51, 54, 55, 98, 99,
                102, 103, 114, 115, 118, 119, 40, 41, 44, 45, 56, 57, 60, 61, 104,
                105, 108, 109, 120, 121, 124, 125, 42, 43, 46, 47, 58, 59, 62, 63,
                106, 107, 110, 111, 122, 123, 126, 127, 128, 129, 132, 133, 144, 145, 148,
                149, 192, 193, 196, 197, 208, 209, 212, 213, 130, 131, 134, 135, 146, 147,
                150, 151, 194, 195, 198, 199, 210, 211, 214, 215, 136, 137, 140, 141, 152,
                153, 156, 157, 200, 201, 204, 205, 216, 217, 220, 221, 138, 139, 142, 143,
                154, 155, 158, 159, 202, 203, 206, 207, 218, 219, 222, 223, 160, 161, 164,
                165, 176, 177, 180, 181, 224, 225, 228, 229, 240, 241, 244, 245, 162, 163,
                166, 167, 178, 179, 182, 183, 226, 227, 230, 231, 242, 243, 246, 247, 168,
                169, 172, 173, 184, 185, 188, 189, 232, 233, 236, 237, 248, 249, 252, 253,
                170, 171, 174, 175, 186, 187, 190, 191, 234, 235, 238, 239, 250, 251, 254,
                255
            };

            simdutf_really_inline bool is_ascii(const simd8x64<uint8_t>& input)
            {
                return input.is_ascii();
            }

            simdutf_really_inline simd8<bool>
            must_be_2_3_continuation(const simd8<uint8_t> prev2,
                const simd8<uint8_t> prev3)
            {
                simd8<bool> is_third_byte = prev2 >= uint8_t(0b11100000u);
                simd8<bool> is_fourth_byte = prev3 >= uint8_t(0b11110000u);
                return is_third_byte ^ is_fourth_byte;
            }

        } // namespace
    } // namespace lasx
} // namespace simdutf

/* begin file src/generic/buf_block_reader.h */
namespace simdutf
{
    namespace lasx
    {
        namespace
        {

            // Walks through a buffer in block-sized increments, loading the last part with
            // spaces
            template <size_t STEP_SIZE>
            struct buf_block_reader
            {
            public:
                simdutf_really_inline buf_block_reader(const uint8_t* _buf, size_t _len);
                simdutf_really_inline size_t block_index();
                simdutf_really_inline bool has_full_block() const;
                simdutf_really_inline const uint8_t* full_block() const;
                /**
                 * Get the last block, padded with spaces.
                 *
                 * There will always be a last block, with at least 1 byte, unless len == 0
                 * (in which case this function fills the buffer with spaces and returns 0. In
                 * particular, if len == STEP_SIZE there will be 0 full_blocks and 1 remainder
                 * block with STEP_SIZE bytes and no spaces for padding.
                 *
                 * @return the number of effective characters in the last block.
                 */
                simdutf_really_inline size_t get_remainder(uint8_t* dst) const;
                simdutf_really_inline void advance();

            private:
                const uint8_t* buf;
                const size_t len;
                const size_t lenminusstep;
                size_t idx;
            };

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text_64(const uint8_t* text)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    buf[i] = int8_t(text[i]) < ' ' ? '_' : int8_t(text[i]);
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            // Routines to print masks and text for debugging bitmask operations
            simdutf_unused static char* format_input_text(const simd8x64<uint8_t>& in)
            {
                static char* buf = reinterpret_cast<char*>(malloc(sizeof(simd8x64<uint8_t>) + 1));
                in.store(reinterpret_cast<uint8_t*>(buf));
                for (size_t i = 0; i < sizeof(simd8x64<uint8_t>); i++)
                {
                    if (buf[i] < ' ')
                    {
                        buf[i] = '_';
                    }
                }
                buf[sizeof(simd8x64<uint8_t>)] = '\0';
                return buf;
            }

            simdutf_unused static char* format_mask(uint64_t mask)
            {
                static char* buf = reinterpret_cast<char*>(malloc(64 + 1));
                for (size_t i = 0; i < 64; i++)
                {
                    buf[i] = (mask & (size_t(1) << i)) ? 'X' : ' ';
                }
                buf[64] = '\0';
                return buf;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline
            buf_block_reader<STEP_SIZE>::buf_block_reader(const uint8_t* _buf, size_t _len)
                : buf { _buf }
                , len { _len }
                , lenminusstep { len < STEP_SIZE ? 0 : len - STEP_SIZE }
                , idx { 0 }
            {
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t buf_block_reader<STEP_SIZE>::block_index()
            {
                return idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline bool buf_block_reader<STEP_SIZE>::has_full_block() const
            {
                return idx < lenminusstep;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline const uint8_t*
            buf_block_reader<STEP_SIZE>::full_block() const
            {
                return &buf[idx];
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline size_t
            buf_block_reader<STEP_SIZE>::get_remainder(uint8_t* dst) const
            {
                if (len == idx)
                {
                    return 0;
                } // memcpy(dst, null, 0) will trigger an error with some sanitizers
                std::memset(dst, 0x20,
                    STEP_SIZE); // std::memset STEP_SIZE because it is more efficient
                                // to write out 8 or 16 bytes at once.
                std::memcpy(dst, buf + idx, len - idx);
                return len - idx;
            }

            template <size_t STEP_SIZE>
            simdutf_really_inline void buf_block_reader<STEP_SIZE>::advance()
            {
                idx += STEP_SIZE;
            }

        } // unnamed namespace
    } // namespace lasx
} // namespace simdutf
/* end file src/generic/buf_block_reader.h */
/* begin file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
namespace simdutf
{
    namespace lasx
    {
        namespace
        {
            namespace utf8_validation
            {

                using namespace simd;

                simdutf_really_inline simd8<uint8_t>
                check_special_cases(const simd8<uint8_t> input, const simd8<uint8_t> prev1)
                {
                    // Bit 0 = Too Short (lead byte/ASCII followed by lead byte/ASCII)
                    // Bit 1 = Too Long (ASCII followed by continuation)
                    // Bit 2 = Overlong 3-byte
                    // Bit 4 = Surrogate
                    // Bit 5 = Overlong 2-byte
                    // Bit 7 = Two Continuations
                    constexpr const uint8_t TOO_SHORT = 1 << 0; // 11______ 0_______
                                                                // 11______ 11______
                    constexpr const uint8_t TOO_LONG = 1 << 1; // 0_______ 10______
                    constexpr const uint8_t OVERLONG_3 = 1 << 2; // 11100000 100_____
                    constexpr const uint8_t SURROGATE = 1 << 4; // 11101101 101_____
                    constexpr const uint8_t OVERLONG_2 = 1 << 5; // 1100000_ 10______
                    constexpr const uint8_t TWO_CONTS = 1 << 7; // 10______ 10______
                    constexpr const uint8_t TOO_LARGE = 1 << 3; // 11110100 1001____
                                                                // 11110100 101_____
                                                                // 11110101 1001____
                                                                // 11110101 101_____
                                                                // 1111011_ 1001____
                                                                // 1111011_ 101_____
                                                                // 11111___ 1001____
                                                                // 11111___ 101_____
                    constexpr const uint8_t TOO_LARGE_1000 = 1 << 6;
                    // 11110101 1000____
                    // 1111011_ 1000____
                    // 11111___ 1000____
                    constexpr const uint8_t OVERLONG_4 = 1 << 6; // 11110000 1000____

                    const simd8<uint8_t> byte_1_high = prev1.shr<4>().lookup_16<uint8_t>(
                        // 0_______ ________ <ASCII in byte 1>
                        TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG, TOO_LONG,
                        TOO_LONG,
                        // 10______ ________ <continuation in byte 1>
                        TWO_CONTS, TWO_CONTS, TWO_CONTS, TWO_CONTS,
                        // 1100____ ________ <two byte lead in byte 1>
                        TOO_SHORT | OVERLONG_2,
                        // 1101____ ________ <two byte lead in byte 1>
                        TOO_SHORT,
                        // 1110____ ________ <three byte lead in byte 1>
                        TOO_SHORT | OVERLONG_3 | SURROGATE,
                        // 1111____ ________ <four+ byte lead in byte 1>
                        TOO_SHORT | TOO_LARGE | TOO_LARGE_1000 | OVERLONG_4);
                    constexpr const uint8_t CARRY = TOO_SHORT | TOO_LONG | TWO_CONTS; // These all have ____ in byte 1 .
                    const simd8<uint8_t> byte_1_low = (prev1 & 0x0F)
                                                          .lookup_16<uint8_t>(
                                                              // ____0000 ________
                                                              CARRY | OVERLONG_3 | OVERLONG_2 | OVERLONG_4,
                                                              // ____0001 ________
                                                              CARRY | OVERLONG_2,
                                                              // ____001_ ________
                                                              CARRY, CARRY,

                                                              // ____0100 ________
                                                              CARRY | TOO_LARGE,
                                                              // ____0101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____011_ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,

                                                              // ____1___ ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              // ____1101 ________
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000 | SURROGATE,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000,
                                                              CARRY | TOO_LARGE | TOO_LARGE_1000);
                    const simd8<uint8_t> byte_2_high = input.shr<4>().lookup_16<uint8_t>(
                        // ________ 0_______ <ASCII in byte 2>
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT,
                        TOO_SHORT, TOO_SHORT,

                        // ________ 1000____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE_1000 | OVERLONG_4,
                        // ________ 1001____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | OVERLONG_3 | TOO_LARGE,
                        // ________ 101_____
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,
                        TOO_LONG | OVERLONG_2 | TWO_CONTS | SURROGATE | TOO_LARGE,

                        // ________ 11______
                        TOO_SHORT, TOO_SHORT, TOO_SHORT, TOO_SHORT);
                    return (byte_1_high & byte_1_low & byte_2_high);
                }
                simdutf_really_inline simd8<uint8_t>
                check_multibyte_lengths(const simd8<uint8_t> input,
                    const simd8<uint8_t> prev_input,
                    const simd8<uint8_t> sc)
                {
                    simd8<uint8_t> prev2 = input.prev<2>(prev_input);
                    simd8<uint8_t> prev3 = input.prev<3>(prev_input);
                    simd8<uint8_t> must23 = simd8<uint8_t>(must_be_2_3_continuation(prev2, prev3));
                    simd8<uint8_t> must23_80 = must23 & uint8_t(0x80);
                    return must23_80 ^ sc;
                }

                //
                // Return nonzero if there are incomplete multibyte characters at the end of the
                // block: e.g. if there is a 4-byte character, but it is 3 bytes from the end.
                //
                simdutf_really_inline simd8<uint8_t> is_incomplete(const simd8<uint8_t> input)
                {
                    // If the previous input's last 3 bytes match this, they're too short (they
                    // ended at EOF):
                    // ... 1111____ 111_____ 11______
                    static const uint8_t max_array[32] = { 255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        0b11110000u - 1,
                        0b11100000u - 1,
                        0b11000000u - 1 };
                    const simd8<uint8_t> max_value(
                        &max_array[sizeof(max_array) - sizeof(simd8<uint8_t>)]);
                    return input.gt_bits(max_value);
                }

                struct utf8_checker
                {
                    // If this is nonzero, there has been a UTF-8 error.
                    simd8<uint8_t> error;
                    // The last input we received
                    simd8<uint8_t> prev_input_block;
                    // Whether the last input we received was incomplete (used for ASCII fast
                    // path)
                    simd8<uint8_t> prev_incomplete;

                    //
                    // Check whether the current bytes are valid UTF-8.
                    //
                    simdutf_really_inline void check_utf8_bytes(const simd8<uint8_t> input,
                        const simd8<uint8_t> prev_input)
                    {
                        // Flip prev1...prev3 so we can easily determine if they are 2+, 3+ or 4+
                        // lead bytes (2, 3, 4-byte leads become large positive numbers instead of
                        // small negative numbers)
                        simd8<uint8_t> prev1 = input.prev<1>(prev_input);
                        simd8<uint8_t> sc = check_special_cases(input, prev1);
                        this->error |= check_multibyte_lengths(input, prev_input, sc);
                    }

                    // The only problem that can happen at EOF is that a multibyte character is
                    // too short or a byte value too large in the last bytes: check_special_cases
                    // only checks for bytes too large in the first of two bytes.
                    simdutf_really_inline void check_eof()
                    {
                        // If the previous block had incomplete UTF-8 characters at the end, an
                        // ASCII block can't possibly finish them.
                        this->error |= this->prev_incomplete;
                    }

                    simdutf_really_inline void check_next_input(const simd8x64<uint8_t>& input)
                    {
                        if (simdutf_likely(is_ascii(input)))
                        {
                            this->error |= this->prev_incomplete;
                        }
                        else
                        {
                            // you might think that a for-loop would work, but under Visual Studio, it
                            // is not good enough.
                            static_assert((simd8x64<uint8_t>::NUM_CHUNKS == 2) || (simd8x64<uint8_t>::NUM_CHUNKS == 4),
                                "We support either two or four chunks per 64-byte block.");
                            if (simd8x64<uint8_t>::NUM_CHUNKS == 2)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                            }
                            else if (simd8x64<uint8_t>::NUM_CHUNKS == 4)
                            {
                                this->check_utf8_bytes(input.chunks[0], this->prev_input_block);
                                this->check_utf8_bytes(input.chunks[1], input.chunks[0]);
                                this->check_utf8_bytes(input.chunks[2], input.chunks[1]);
                                this->check_utf8_bytes(input.chunks[3], input.chunks[2]);
                            }
                            this->prev_incomplete = is_incomplete(input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1]);
                            this->prev_input_block = input.chunks[simd8x64<uint8_t>::NUM_CHUNKS - 1];
                        }
                    }

                    // do not forget to call check_eof!
                    simdutf_really_inline bool errors() const
                    {
                        return this->error.any_bits_set_anywhere();
                    }

                }; // struct utf8_checker
            } // namespace utf8_validation

            using utf8_validation::utf8_checker;

        } // unnamed namespace
    } // namespace lasx
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_lookup4_algorithm.h */
/* begin file src/generic/utf8_validation/utf8_validator.h */
namespace simdutf
{
    namespace lasx
    {
        namespace
        {
            namespace utf8_validation
            {

                /**
                 * Validates that the string is actual UTF-8.
                 */
                template <class checker>
                bool generic_validate_utf8(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        reader.advance();
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    return !c.errors();
                }

                bool generic_validate_utf8(const char* input, size_t length)
                {
                    return generic_validate_utf8<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

                /**
                 * Validates that the string is actual UTF-8 and stops on errors.
                 */
                template <class checker>
                result generic_validate_utf8_with_errors(const uint8_t* input, size_t length)
                {
                    checker c {};
                    buf_block_reader<64> reader(input, length);
                    size_t count { 0 };
                    while (reader.has_full_block())
                    {
                        simd::simd8x64<uint8_t> in(reader.full_block());
                        c.check_next_input(in);
                        if (c.errors())
                        {
                            if (count != 0)
                            {
                                count--;
                            } // Sometimes the error is only detected in the next chunk
                            result res = scalar::utf8::rewind_and_validate_with_errors(
                                reinterpret_cast<const char*>(input),
                                reinterpret_cast<const char*>(input + count), length - count);
                            res.count += count;
                            return res;
                        }
                        reader.advance();
                        count += 64;
                    }
                    uint8_t block[64] {};
                    reader.get_remainder(block);
                    simd::simd8x64<uint8_t> in(block);
                    c.check_next_input(in);
                    reader.advance();
                    c.check_eof();
                    if (c.errors())
                    {
                        if (count != 0)
                        {
                            count--;
                        } // Sometimes the error is only detected in the next chunk
                        result res = scalar::utf8::rewind_and_validate_with_errors(
                            reinterpret_cast<const char*>(input),
                            reinterpret_cast<const char*>(input) + count, length - count);
                        res.count += count;
                        return res;
                    }
                    else
                    {
                        return result(error_code::SUCCESS, length);
                    }
                }

                result generic_validate_utf8_with_errors(const char* input, size_t length)
                {
                    return generic_validate_utf8_with_errors<utf8_checker>(
                        reinterpret_cast<const uint8_t*>(input), length);
                }

            } // namespace utf8_validation
        } // unnamed namespace
    } // namespace lasx
} // namespace simdutf
/* end file src/generic/utf8_validation/utf8_validator.h */

/* begin file src/generic/utf8.h */
namespace simdutf
{
    namespace lasx
    {
        namespace
        {
            namespace utf8
            {

                using namespace simd;

                simdutf_really_inline size_t count_code_points(const char* in, size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.gt(-65);
                        count += count_ones(utf8_continuation_mask);
                    }
                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }

    #ifdef SIMDUTF_SIMD_HAS_BYTEMASK
                simdutf_really_inline size_t count_code_points_bytemask(const char* in,
                    size_t size)
                {
                    using vector_i8 = simd8<int8_t>;
                    using vector_u8 = simd8<uint8_t>;
                    using vector_u64 = simd64<uint64_t>;

                    constexpr size_t N = vector_i8::SIZE;
                    constexpr size_t max_iterations = 255 / 4;

                    size_t pos = 0;
                    size_t count = 0;

                    auto counters = vector_u64::zero();
                    auto local = vector_u8::zero();
                    size_t iterations = 0;
                    for (; pos + 4 * N <= size; pos += 4 * N)
                    {
                        const auto input0 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 0 * N));
                        const auto input1 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 1 * N));
                        const auto input2 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 2 * N));
                        const auto input3 = simd8<int8_t>::load(reinterpret_cast<const int8_t*>(in + pos + 3 * N));
                        const auto mask0 = input0 > int8_t(-65);
                        const auto mask1 = input1 > int8_t(-65);
                        const auto mask2 = input2 > int8_t(-65);
                        const auto mask3 = input3 > int8_t(-65);

                        local -= vector_u8(mask0);
                        local -= vector_u8(mask1);
                        local -= vector_u8(mask2);
                        local -= vector_u8(mask3);

                        iterations += 1;
                        if (iterations == max_iterations)
                        {
                            counters += sum_8bytes(local);
                            local = vector_u8::zero();
                            iterations = 0;
                        }
                    }

                    if (iterations > 0)
                    {
                        count += local.sum_bytes();
                    }

                    count += counters.sum();

                    return count + scalar::utf8::count_code_points(in + pos, size - pos);
                }
    #endif

                simdutf_really_inline size_t utf16_length_from_utf8(const char* in,
                    size_t size)
                {
                    size_t pos = 0;
                    size_t count = 0;
                    // This algorithm could no doubt be improved!
                    for (; pos + 64 <= size; pos += 64)
                    {
                        simd8x64<int8_t> input(reinterpret_cast<const int8_t*>(in + pos));
                        uint64_t utf8_continuation_mask = input.lt(-65 + 1);
                        // We count one word for anything that is not a continuation (so
                        // leading bytes).
                        count += 64 - count_ones(utf8_continuation_mask);
                        int64_t utf8_4byte = input.gteq_unsigned(240);
                        count += count_ones(utf8_4byte);
                    }
                    return count + scalar::utf8::utf16_length_from_utf8(in + pos, size - pos);
                }
            } // namespace utf8
        } // unnamed namespace
    } // namespace lasx
} // namespace simdutf
/* end file src/generic/utf8.h */

//
// Implementation-specific overrides
//
namespace simdutf
{
    namespace lasx
    {

        simdutf_warn_unused bool
        implementation::validate_utf8(const char* buf, size_t len) const noexcept
        {
            return lasx::utf8_validation::generic_validate_utf8(buf, len);
        }

        simdutf_warn_unused result implementation::validate_utf8_with_errors(
            const char* buf, size_t len) const noexcept
        {
            return lasx::utf8_validation::generic_validate_utf8_with_errors(buf, len);
        }

        simdutf_warn_unused size_t
        implementation::count_utf8(const char* input, size_t length) const noexcept
        {
            size_t pos = 0;
            size_t count = 0;
            // Performance degradation when memory address is not 32-byte aligned
            while ((((uint64_t)input + pos) & 0x1F && pos < length))
            {
                if (input[pos++] > -65)
                {
                    count++;
                }
            }
            __m256i v_bf = __lasx_xvldi(0xBF); // 0b10111111
            for (; pos + 32 <= length; pos += 32)
            {
                __m256i in = __lasx_xvld(reinterpret_cast<const int8_t*>(input + pos), 0);
                __m256i utf8_count = __lasx_xvpcnt_h(__lasx_xvmskltz_b(__lasx_xvslt_b(v_bf, in)));
                count = count + __lasx_xvpickve2gr_wu(utf8_count, 0) + __lasx_xvpickve2gr_wu(utf8_count, 4);
            }
            return count + scalar::utf8::count_code_points(input + pos, length - pos);
        }

    } // namespace lasx
} // namespace simdutf

    /* begin file src/simdutf/lasx/end.h */
    #undef SIMDUTF_SIMD_HAS_UNSIGNED_CMP
/* end file src/simdutf/lasx/end.h */
/* end file src/lasx/implementation.cpp */
#endif

SIMDUTF_POP_DISABLE_WARNINGS
/* end file src/simdutf.cpp */
